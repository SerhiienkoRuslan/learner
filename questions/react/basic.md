<details>
<summary>1. Чи працювали з класовими компонентами? У чому їхня особливість?</summary>

**Класові компоненти** - це JavaScript класи, які успадковуються від базового класу React.Component.
Вони мають стан, який можна змінювати за допомогою методу setState(), що призводить до перерендерингу компонентів.
Також вони мають метод render(), який повертає відображення компонента.

Основні **переваги** класових компонентів React.js включають:

1. Можливість зберігати стан компонентів.
2. Розширена функціональність - класові компоненти можуть мати життєвий цикл, методи для роботи зі станом та інші функції.
3. Зручне керування станом - за допомогою методу setState() можна змінювати стан компонентів і перерендерювати їх, що дозволяє створювати багатофункціональні динамічні інтерфейси користувача.
4. Однак, з випуском React 16.8 було додано підтримку функціональних компонентів з використанням хуків, що дозволило розширити функціональність React без необхідності використовувати класові компоненти. Тому, в даний час класові компоненти використовуються менше, ніж раніше, хоча все ще можуть бути корисними для деяких випадків використання.

</details>

<details>
<summary> 2. Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.</summary>

У React.js зазвичай зберігають в стані компонента ті дані, які можуть змінюватися протягом життєвого циклу компонента і викликати перерендеринг.
Отже, якщо дані не змінюються і не впливають на відображення компонента, то краще передавати їх через пропси.
Якщо ж дані можуть змінюватися внаслідок дій користувача або відповідно до змін з зовнішнього середовища
(наприклад, якщо компонент залежить від даних, отриманих з API), то краще зберігати їх у стані компонента.
Також варто зберігати в стані компонента дані, які потрібні для його внутрішньої логіки та обчислень.

Загалом, правило можна сформулювати так: якщо дані впливають на відображення компонента,
або їх зміна потребує перерендерингу компонента, то краще зберігати їх у стані компонента.
Якщо ж дані не впливають на відображення компонента та не потребують перерендерингу, то можна передавати їх через пропси.

</details>

<details>
<summary> 3. Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої, і з якою метою?</summary>

У React **хуки** - це функції, які дозволяють використовувати стан і інші функціональні можливості React в компонентах функцій.

Хуки можна використовувати для вирішення багатьох завдань, включаючи управління станом, виконання побічних ефектів, підключення до зовнішніх джерел даних і багато іншого.

Найбільш поширеними хуками є **useState, useEffect, useContext і useReducer**.

***Кастомні хуки*** - це хуки, які ви створюєте самостійно, використовуючи вбудовані хуки або інші вбудовані функції.
Вони дозволяють зберігати та повторно використовувати функціональні можливості від різних компонентів у вашій програмі.

Кастомні хуки можна використовувати для вирішення специфічних завдань, які не вирішуються вбудованими хуками,
таких як валідація форм, управління анімацією або підключення до зовнішніх API.

Основна перевага кастомних хуків полягає в тому, що вони дозволяють повторно використовувати логіку функціональності з різних компонентів без необхідності повторення коду.
Вони також допомагають зберігати ваш код чистим та організованим.

</details>

<details>
<summary>4. Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?</summary>

***Фрагменти (Fragments)*** - це спеціальний тип компонентів, що дозволяють групувати декілька елементів без необхідності створювати додатковий DOM-вузол.
Наприклад, якщо вам потрібно повернути два <div> елементи з компонента, замість того, щоб обгортати їх в якийсь контейнер,
ви можете використовувати фрагменти:

```jsx
import React, { Fragment } from 'react';

function MyComponent() {
  return (
    <Fragment>
      <div>Перший елемент</div>
      <div>Другий елемент</div>
    </Fragment>
  );
}
```

***Портали (Portals)*** - це механізм, що дозволяє відображати дочірні елементи компонента в іншому місці в DOM-дереві.
Наприклад, якщо ви хочете відобразити попап навігації, який потрібно розмістити над усіма іншими елементами,
можна використовувати портали:

```jsx
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function NavigationPopup() {
  return (
    <div className="navigation-popup">
      <ul>
        <li>Пункт 1</li>
        <li>Пункт 2</li>
        <li>Пункт 3</li>
      </ul>
    </div>
  );
}

function App() {
  const [showPopup, setShowPopup] = useState(false);

  return (
    <div>
      <button onClick={() => setShowPopup(!showPopup)}>Показати навігацію</button>
      {showPopup &&
        ReactDOM.createPortal(
          <NavigationPopup />,
          document.getElementById('navigation-popup-container')
        )
      }
      <div>Основний контент</div>
      <div id="navigation-popup-container"></div>
    </div>
  );
}

ReactDOM.render(<App />, document.getElementById('root'));
```

У цьому прикладі, коли користувач натискає на кнопку, компонент NavigationPopup відображається в DOM-елементі з id='navigation-popup-container',
який знаходиться за межами компонента App.


</details>

<details>
<summary>5. Коли й для чого використовують рефи (ref)?</summary>

В React, ref - це спеціальний атрибут, який може бути доданий до React-елементів або компонентів.
Він дозволяє отримати доступ до екземпляру DOM-вузла або React-компонента, який створюється під час рендерингу.

Основні використання ref в React:

1. Отримання доступу до DOM-елементів: ref можна використовувати для отримання доступу до реальних DOM-елементів, щоби здійснювати з ними операції відповідно до потреб проекту, такі як фокусування, встановлення розміру і т.д.

2. Отримання доступу до React-компонента: який дозволяє виконувати над ним додаткові операції, наприклад, викликати методи компонента.

3. Передача ref в компоненти: ref можна передавати в компоненти як пропс, щоби дозволити компоненту надавати доступ до свого внутрішнього стану, методів і властивостей.

4. В цілому, ref використовується там, де необхідно отримати доступ до елементів DOM або компонентів React з коду компонента, і зазвичай використовується для реалізації більш складної логіки в React-додатках.


</details>

<details>
<summary>6. Які ви знаєте методи життєвого циклу компонента?</summary>

Для класових компонентів:
1. **constructor()**: Цей метод викликається при створенні компонента і використовується для ініціалізації стану та інших ресурсів.

2. **componentDidMount()**: Викликається після того, як компонент вперше рендериться на сторінці. Використовується для виконання побічних ефектів, таких як отримання даних з сервера.

3. **componentDidUpdate()**: Викликається після оновлення компонента, наприклад, після зміни стану або властивостей.

4. **componentWillUnmount()**: Викликається перед тим, як компонент буде видалений зі сторінки. Використовується для видалення підписок та ресурсів.

5. **shouldComponentUpdate()**: Викликається перед оновленням компонента і дозволяє контролювати, чи потрібно виконувати оновлення.

Для функціональних компонентів з хуками:
1. **useEffect()**: Ця функція-хук дозволяє виконувати побічні ефекти в функціональних компонентах. Вона об'єднує функціональності `componentDidMount`, `componentDidUpdate` і `componentWillUnmount`.

2. **useState()**: Цей хук використовується для створення та оновлення стану компонента.

3. **useContext()**: Використовується для отримання доступу до контексту React, який дозволяє передавати дані вглиб ієрархії компонентів без необхідності передачі їх через пропи.

4. **useReducer()**: Дозволяє використовувати більш складний підхід до керування станом компонента.

</details>

<details>
<summary>7. В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?</summary>

Запити на сервер найкраще робити в методі `componentDidMount()` для класових компонентів та у `useEffect()` з пустим масивом залежностей для функціональних компонентів. Ці місця підходять для асинхронних операцій, оскільки не блокують рендеринг і виконуються після першого рендерингу компонента.

</details>

<details>
<summary>8. В якому методі життєвого циклу компонента краще робити підписку і відписку від лісенера? Чому? Навіщо відписуватися?</summary>

У класових компонентах React краще робити підписку на лісенера та відписку від нього в методах `componentDidMount()` та `componentWillUnmount()` відповідно. В функціональних компонентах з використанням хуків, ви можете робити це в `useEffect()` з пустим масивом залежностей та з використанням функції очищення.

Навіщо відписуватися від лісенера? Ось декілька причин:

1. **Ресурси і пам'ять**: Підписка на лісенера може займати пам'ять і інші ресурси. Якщо ви не відпишетеся від лісенера, це може призвести до витоку пам'яті та інших проблем з продуктивністю.

2. **Уникнення некоректної реакції на події**: Якщо ви не відпишетеся від лісенера, ваш компонент все ще може намагатися реагувати на події, коли він вже не повинен цього робити, що може призвести до помилок.

3. **Підтримка чистого стану компонентів**: Відписавшись від лісенера, ви допомагаєте забезпечити чистий стан компонентів, що робить їх більш передбачуваними та керованими.

Отже, важливо завжди відписуватися від лісенера, коли ви більше не потребуєте слухати події або коли компонент буде видалений зі сторінки.

</details> 

<details>
<summary>9. Чи був досвід роботи з контекстом? Коли його варто використовувати?</summary>

Контекст в React варто використовувати, коли потрібно передавати дані між багатьма компонентами безпосередньо, якщо передача пропів через багато проміжних компонентів стає надто незручною. Зазвичай використовують його для роботи з аутентифікацією, темами, міжнароднізацією, управлінням станом додатку та загальними конфігураціями.

</details>

<details>
<summary>10. У чому особливість PureComponent?</summary>

`PureComponent` - це спеціальний клас компонента в React, який автоматично реалізує метод `shouldComponentUpdate()`, щоб здійснити оптимізацію перерендерингу компонента. Основна особливість `PureComponent` полягає в тому, що він порівнює попередній стан та властивості з поточними і автоматично визначає, чи потрібно рендерити компонент знову.

Основні особливості `PureComponent`:

1. **Автоматична оптимізація**: `PureComponent` виконує поверхневе порівняння попереднього стану та властивостей з поточними значеннями. Якщо вони ідентичні, то компонент не буде рендеритися знову, що допомагає зекономити ресурси та покращити продуктивність.

2. **Зручний для використання**: Використання `PureComponent` не вимагає написання власного методу `shouldComponentUpdate()`, як у звичайних класових компонентах. Він вже має цей метод, який обробляє оптимізацію за замовчуванням.

3. **Обмеження**: Однак, `PureComponent` має свої обмеження. Він виконує поверхневе порівняння об'єктів, тому, якщо ваш стан містить вкладені об'єкти або масиви, `PureComponent` може не правильно визначити, чи сталася зміна. У таких випадках вам може знадобитися ручне керування оптимізацією за допомогою `shouldComponentUpdate()`.

Загалом, `PureComponent` корисний для багатьох випадків, але важливо розуміти, як він працює та враховувати його обмеження при використанні.

</details>

<details>
<summary>11. Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?</summary>

Мемоізовані селектори - це паттерн для покращення продуктивності в React за допомогою кешування результатів обчислень та уникнення зайвого перерендерення компонентів.
В React для мемоізації селекторів часто використовуються такі засоби:

**useMemo() хук**: Цей хук дозволяє мемоізувати результати обчислення селектора, коли змінюються вхідні дані. Ви можете використовувати `useMemo()` для створення мемоізованих селекторів у функціональних компонентах.

Приклад використання `useMemo()` для мемоізованого селектора:

```jsx
import { useMemo } from 'react';

function MyComponent(props) {
  const memoizedSelector = useMemo(() => {
    // Обчислення результату селектора тут
  }, [props.inputData]); // props.inputData - вхідні дані селектора

  // Використання memoizedSelector у компоненті
}
```

</details>

<details>
<summary>12. У чому бачите переваги бібліотеки React?</summary>

React - це популярна бібліотека для розробки інтерфейсів, і вона має багато переваг:

1. **Компонентна архітектура**: React сприяє розробці за допомогою компонентів, що дозволяє створювати відокремлені, перевикористовувані частини коду, спрощуючи розробку та підтримку додатку.

2. **Віртуальний DOM**: React використовує віртуальний DOM для оптимізації оновлення інтерфейсу. Це дозволяє виробляти мінімальну кількість змін в реальному DOM під час оновлення, що робить додаток швидшим і продуктивнішим.

3. **Односторінкові додатки (SPA)**: React добре підходить для розробки SPA, де весь інтерфейс завантажується під час першого запуску, і подальша навігація відбувається без перезавантаження сторінки.

4. **Розширюваність**: Багато бібліотек та фреймворків розробки, таких як Redux, Mobx, та React Router, добре поєднуються з React, дозволяючи будувати потужні додатки.

5. **Велике спільнота та екосистема**: React має велику та активну спільноту розробників. Існує безліч сторонніх бібліотек та розширень, які допомагають спростити розробку і вирішити різні завдання.

6. **Підтримка серверного рендерингу**: React дозволяє рендерити сторінки на сервері (server-side rendering), що поліпшує SEO та допомагає знизити час завантаження сторінок.

7. **Компоненти для мобільних додатків**: За допомогою React Native, ви можете використовувати React для розробки мобільних додатків для iOS та Android, використовуючи звичайний JavaScript або TypeScript.

8. **Офіційна підтримка Facebook**: React підтримується Facebook, що означає стабільність та активний розвиток.

</details>

<details>
<summary>13. Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?</summary>

React швидка завдяки використанню віртуального DOM (Virtual DOM). Віртуальний DOM - це легка копія реального DOM, яка знаходиться в пам'яті. При зміні даних в React, віртуальний DOM порівнює новий стан з попереднім і знаходить мінімальні зміни, які потрібно зробити в реальному DOM. Це дозволяє робити ефективні оновлення і зменшує кількість зайвих маніпуляцій з реальним DOM, що робить React швидким.

Shadow DOM (тіневий DOM) - це інша технологія, яка дозволяє ізолювати структуру та стилі компонентів на веб-сторінці від зовнішнього впливу. Він дозволяє створювати окремі області (тіневі DOM-елементи), які не впливають на решту сторінки та не піддаються зовнішнім стилям. Shadow DOM допомагає зменшити конфлікти стилів та підвищити ізольованість компонентів.

</details>

<details>
<summary>14. Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?</summary>

Ключі в React використовуються для ідентифікації елементів в списку при оновленні та рендерингу. Вони допомагають React визначити, які елементи були додані, видалені чи переміщені в масиві, і це дозволяє виконувати ефективніше оновлення віртуального DOM та реального DOM.

Важливі моменти щодо ключів в списках:

1. **Унікальність**: Ключі повинні бути унікальними серед всіх елементів в масиві. Це допомагає React правильно ідентифікувати кожен елемент.

2. **Постійність**: Ключі повинні залишатися постійними при рендерингу. Не робіть ключів змінними, що можуть змінюватися при кожному рендерингу.

3. **Не використовуйте індекси масиву як ключі**: Найкраще уникати використання індексів масиву як ключів. Це може призвести до некоректного рендерингу під час додавання чи видалення елементів. Якщо порядок елементів може змінюватися, краще використовувати унікальні ідентифікатори для ключів.

4. **Виправданість використання індексів**: Іноді виправдано використовувати індекси як ключі, якщо масив елементів не змінюється, і ви впевнені, що порядок елементів не зміниться. Однак це слід робити з розумінням можливих наслідків.

Ключі в списках особливо важливі в контексті динамічно змінюваних списків, де елементи можуть додаватися, видалятися чи переміщатися. Правильне використання ключів допомагає підтримувати коректний рендеринг та продуктивність додатку при змінах у списку.

</details>

<details>
<summary>15. В чому основна ідея Redux?</summary>

**Основна ідея Redux** - це зберігати всю інформацію про ваш додаток в одній великій коробці (store). Ви користуєтесь цією коробкою для зберігання всіх даних та стану вашого додатку. Коли ви хочете змінити щось у додатку, ви створюєте "запит" (action) і кажете коробці, що потрібно змінити. Коробка (Redux) виконує цей запит та змінює свій вміст. Всі частини вашого додатку завжди знають, де знаходиться поточний стан, і можуть спостерігати за змінами (підписка на store).

Redux допомагає зробити ваш додаток більш зрозумілим і простішим для розробки, оскільки всі дані та їх зміни в одному місці.

</details>

<details>
<summary>16. Робота зі стилями в React.</summary>

Робота зі стилями в React може бути виконана кількома способами. Найпоширеніші з них включають в себе:

1. **CSS Класи**: Використання звичайних CSS класів в компонентах. Ви створюєте CSS файли зі стилями і використовуєте класи у вашому JSX коді. React дозволяє додавати класи до компонентів за допомогою атрибуту `className`.

```jsx
import React from 'react';
import './MyComponent.css';

function MyComponent() {
  return <div className="my-component">Зміст компоненту</div>;
}
```

2. **Inline Стилі**: Ви можете використовувати inline стилі, визначені в об'єктах JavaScript, напряму в компонентах. Це особливо корисно, коли стиль пов'язаний зі станом компонента.

```jsx
import React, { useState } from 'react';

function MyComponent() {
  const [isHovered, setIsHovered] = useState(false);

  const style = {
    backgroundColor: isHovered ? 'blue' : 'red',
    color: 'white',
  };

  return (
    <div
      style={style}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      Зміст компоненту
    </div>
  );
}
```

3. **CSS-в-JS бібліотеки**: Використання бібліотек, таких як Styled-components або Emotion, які дозволяють описувати стилі прямо в JavaScript. Це дозволяє створювати компоненти з вбудованими стилями, які автоматично генерують CSS під капотом.

```jsx
import styled from 'styled-components';

const StyledButton = styled.button`
  background-color: blue;
  color: white;
`;

function MyComponent() {
  return <StyledButton>Моя кнопка</StyledButton>;
}
```
Модулярна система стилів допомагає управляти стилями в React, забезпечуючи їх ізоляцію та уникнення конфліктів між компонентами. Декілька популярних бібліотек для модульної обробки стилів у React включають CSS Modules, Styled-components, та Emotion.

Кожен із цих підходів має свої переваги та недоліки, і ви можете вибрати той, який найкраще підходить вашому проекту. Inline стилі зазвичай допомагають зберігати стилі разом з компонентами, CSS-класи дозволяють застосовувати стилі за допомогою зовнішніх CSS файлів, а CSS-в-JS бібліотеки надають більшу контроль та ізольованість стилів в компонентах.

</details>


<details>
<summary>17. React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.</summary>
React - це бібліотека, а не фреймворк. Щоб зрозуміти різницю між цими двома поняттями, ось їх означення:

1. **Бібліотека (Library)**:
    - Бібліотека - це набір корисних функцій та компонентів, які допомагають вирішувати певні завдання у вашому програмному коді.
    - Ви контролюєте, де і як використовувати функції бібліотеки.
    - Бібліотека зазвичай не накладає жорстких обмежень на структуру вашого проекту.

2. **Фреймворк (Framework)**:
    - Фреймворк - це комплексна система, яка включає в себе правила та структуру для розробки програм, включаючи деякі ключові компоненти.
    - Ви повинні дотримуватися структури та правил, встановлених фреймворком.
    - Фреймворки зазвичай надають багато готових рішень та компонентів для розробки.

Отже, React - це бібліотека, яка надає компоненти та інструменти для розробки інтерфейсів, але вона не накладає жорстких обмежень на те, як ви будуєте ваш додаток. Ви вільні вибирати інші бібліотеки та інструменти для інших аспектів вашого додатку. Фреймворк, навпаки, зазвичай надає більше обмежень та структури для розробки, вимагаючи від розробників слідувати певній парадигмі або структурі.

</details>

<details>
<summary>18. Чи можна використовувати jQuery разом з React? Чому так / ні?</summary>

Теоретично, ви можете використовувати jQuery разом з React, але це не є рекомендованим підходом, і є кілька важливих причин для цього:

1. **Конфлікти з React**: jQuery і React можуть конфліктувати між собою, оскільки обидва бібліотеки можуть намагатися керувати DOM-елементами. Це може призвести до непередбачуваної поведінки вашого додатку.

2. **Надлишковий обсяг коду**: Використання jQuery разом із React може призвести до надмірної складності та збільшення обсягу коду в проекті, оскільки обидві бібліотеки надають подібні функціональності.

3. **Робота із станом і компонентами**: React пропонує більш сучасні та декларативні підходи до роботи із станом та компонентами. Використання jQuery може ускладнити роботу зі станом та взаємодією між компонентами.

4. **Ефективність та продуктивність**: React використовує віртуальний DOM для оптимізації оновлення інтерфейсу, що робить додаток більш продуктивним. jQuery не має такого механізму, тому він може бути менш ефективним.

Зазвичай рекомендовано уникати використання jQuery в додатках, побудованих на React. Замість цього ви можете використовувати рішення, які підтримуються React, такі як обробники подій React, React Hooks, та бібліотеки для роботи з AJAX-запитами, як axios чи Fetch API. Це допоможе забезпечити більш зручну та однорідну розробку в вашому проекті на React.

</details>

<details>
<summary>19. Що таке codemod?</summary>

Codemod (скорочено від "code modification") - це програма або скрипт, яка використовується для автоматизованої модифікації або перетворення коду в іншому форматі чи стилі. Це корисний інструмент для виконання великомасштабних змін в коді без необхідності ручного редагування кожного файлу.

Codemods можуть бути використані для різних цілей, таких як:

1. **Автоматичне оновлення до нової версії бібліотеки чи фреймворку**: Після виходу нової версії бібліотеки, ви можете використовувати codemod, щоб автоматично оновити ваш код та внести необхідні зміни.

2. **Виправлення стилю коду**: Codemod може допомогти виправити стиль коду, дотримуючись правил кодування чи стандартів оформлення, таких як вирівнювання, розділення рядків тощо.

3. **Масова заміна часткового коду**: Якщо вам потрібно замінити однаковий чи подібний код в багатьох місцях у вашому проекті, codemod може зробити це автоматично.

4. **Перетворення коду в інший формат чи мову програмування**: Codemod може використовуватися для перетворення коду з однієї мови програмування в іншу або з одного формату в інший.

Codemods зазвичай використовуються розробниками для автоматизації та спрощення процесу рефакторингу та обслуговування коду. Вони можуть бути написані самостійно або використовувати існуючі бібліотеки, такі як jscodeshift для JavaScript.

</details>

<details>
<summary>20. Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?</summary>

</details>

<details>
<summary>21. Перерахуйте всі бібліотеки, які використовували у зв’язці з React.</summary>

</details>

<details>
<summary>22. Що найскладніше доводилося реалізовувати за допомогою React?</summary>

</details>

<details>
<summary>23.Що таке JSX? Що лежить в його основі?</summary>



</details>


<details>
<summary>24.Як працює алгоритм Virtual DOM?</summary>



</details>


<details>
<summary>25.Для чого потрібна властивість key під час рендерингу списків?</summary>



</details>


<details>
<summary>26.У чому різниця між функціональними та класовими компонентами?</summary>



</details>


<details>
<summary>27.Навіщо і коли потрібно передавати props в super () при використанні класових компонентів?</summary>



</details>


<details>
<summary>28.Чому потрібно використовувати setState () для оновлення внутрішнього стану компонента?</summary>



</details>


<details>
<summary>29.У чому полягає принцип «підйому стану»?</summary>



</details>


<details>
<summary>30.Які бібліотеки менеджменту стану React-застосунку ви знаєте? Навіщо вони?</summary>



</details>


<details>
<summary>31.Коли варто використовувати Redux? Які є альтернативи?</summary>



</details>


<details>
<summary>32.Redux vs Mobx?</summary>



</details>


<details>
<summary>33.Розкажіть про базовий принцип роботи React Hooks.</summary>



</details>


<details>
<summary>34.У чому різниця між createRef і useRef?</summary>



</details>

<details>
<summary>35.Коли варто використовувати React refs? Коли не варто?</summary>



</details>

<details>
<summary>36.Які недоліки бібліотеки React бачите?</summary>



</details>

<details>
<summary>37.Які патерни використовуєте разом з React?</summary>



</details>

<details>
<summary>38.Як ставитесь до типізації разом з React?</summary>



</details>

<details>
<summary>39.Як побудувати хорошу архітектуру React-проєкту?</summary>



</details>

<details>
<summary>40.Оптимізація React-застосунків? Як виміряти продуктивність програми?</summary>



</details>

<details>
<summary>41.Чи можна застосунок на React вбудувати в інший застосунок на React?</summary>



</details>


