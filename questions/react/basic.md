## 1. Чи працювали з класовими компонентами? У чому їхня особливість?

Класові компоненти - це JavaScript класи, які успадковуються від базового класу React.Component.
Вони мають стан, який можна змінювати за допомогою методу setState(), що призводить до перерендерингу компонентів.
Також вони мають метод render(), який повертає відображення компонента.

#### Основні переваги класових компонентів React.js включають:

1. Можливість зберігати стан компонентів.
2. Розширена функціональність - класові компоненти можуть мати життєвий цикл, методи для роботи зі станом та інші функції.
3. Зручне керування станом - за допомогою методу setState() можна змінювати стан компонентів і перерендерювати їх, що дозволяє створювати багатофункціональні динамічні інтерфейси користувача.
4. Однак, з випуском React 16.8 було додано підтримку функціональних компонентів з використанням хуків, що дозволило розширити функціональність React без необхідності використовувати класові компоненти. Тому, в даний час класові компоненти використовуються менше, ніж раніше, хоча все ще можуть бути корисними для деяких випадків використання.

## 2. Які дані краще зберігати в стані компонента, а які передавати через пропси? Наведіть приклад.

У React.js зазвичай зберігають в стані компонента ті дані, які можуть змінюватися протягом життєвого циклу компонента і викликати перерендеринг.
Отже, якщо дані не змінюються і не впливають на відображення компонента, то краще передавати їх через пропси.
Якщо ж дані можуть змінюватися внаслідок дій користувача або відповідно до змін з зовнішнього середовища
(наприклад, якщо компонент залежить від даних, отриманих з API), то краще зберігати їх у стані компонента.
Також варто зберігати в стані компонента дані, які потрібні для його внутрішньої логіки та обчислень.

Загалом, правило можна сформулювати так: якщо дані впливають на відображення компонента,
або їх зміна потребує перерендерингу компонента, то краще зберігати їх у стані компонента.
Якщо ж дані не впливають на відображення компонента та не потребують перерендерингу, то можна передавати їх через пропси.

### 3. Чи ознайомлені з хуками? У чому їхні переваги? Чи доводилося робити свої і з якою метою?

У React ***хуки*** - це функції, які дозволяють використовувати стан і інші функціональні можливості React в компонентах функцій.

Хуки можна використовувати для вирішення багатьох завдань,
включаючи управління станом, виконання побічних ефектів,
підключення до зовнішніх джерел даних і багато іншого.

Найбільш поширеними хуками є useState, useEffect, useContext і useReducer.

***Кастомні хуки*** - це хуки, які ви створюєте самостійно, використовуючи вбудовані хуки або інші вбудовані функції.
Вони дозволяють зберігати та повторно використовувати функціональні можливості від різних компонентів у вашій програмі.

Кастомні хуки можна використовувати для вирішення специфічних завдань, які не вирішуються вбудованими хуками,
таких як валідація форм, управління анімацією або підключення до зовнішніх API.

Основна перевага кастомних хуків полягає в тому, що вони дозволяють повторно використовувати логіку функціональності з різних компонентів без необхідності повторення коду.
Вони також допомагають зберігати ваш код чистим та організованим.

### 4. Чи ознайомлені з фрагментами та порталами? Навіщо вони потрібні?

***Фрагменти (Fragments)*** - це спеціальний тип компонентів, що дозволяють групувати декілька елементів без необхідності створювати додатковий DOM-вузол.
Наприклад, якщо вам потрібно повернути два <div> елементи з компонента, замість того, щоб обгортати їх в якийсь контейнер,
ви можете використовувати фрагменти:

```jsx
import React, { Fragment } from 'react';

function MyComponent() {
  return (
    <Fragment>
      <div>Перший елемент</div>
      <div>Другий елемент</div>
    </Fragment>
  );
}
```

***Портали (Portals)*** - це механізм, що дозволяє відображати дочірні елементи компонента в іншому місці в DOM-дереві.
Наприклад, якщо ви хочете відобразити попап навігації, який потрібно розмістити над усіма іншими елементами,
можна використовувати портали:

```jsx
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function NavigationPopup() {
  return (
    <div className="navigation-popup">
      <ul>
        <li>Пункт 1</li>
        <li>Пункт 2</li>
        <li>Пункт 3</li>
      </ul>
    </div>
  );
}

function App() {
  const [showPopup, setShowPopup] = useState(false);

  return (
    <div>
      <button onClick={() => setShowPopup(!showPopup)}>Показати навігацію</button>
      {showPopup &&
        ReactDOM.createPortal(
          <NavigationPopup />,
          document.getElementById('navigation-popup-container')
        )
      }
      <div>Основний контент</div>
      <div id="navigation-popup-container"></div>
    </div>
  );
}

ReactDOM.render(<App />, document.getElementById('root'));
```

У цьому прикладі, коли користувач натискає на кнопку, компонент NavigationPopup відображається в DOM-елементі з id='navigation-popup-container',
який знаходиться за межами компонента App.

## 5. Коли й для чого використовують рефи (ref)?

В React, ref - це спеціальний атрибут, який може бути доданий до React-елементів або компонентів.
Він дозволяє отримати доступ до екземпляру DOM-вузла або React-компонента, який створюється під час рендерингу.

Основні використання ref в React:

1. Отримання доступу до DOM-елементів: ref можна використовувати для отримання доступу до реальних DOM-елементів,
щоби здійснювати з ними операції відповідно до потреб проекту, такі як фокусування, встановлення розміру і т.д.

2. Отримання доступу до React-компонентів: ref можна використовувати для отримання доступу до екземпляру React-компонента, який дозволяє виконувати над ним додаткові операції, наприклад, викликати методи компонента.

Передача ref в компоненти: ref можна передавати в компоненти як пропс, щоби дозволити компоненту надавати доступ до свого внутрішнього стану, методів і властивостей.

В цілому, ref використовується там, де необхідно отримати доступ до елементів DOM або компонентів React з коду компонента, і зазвичай використовується для реалізації більш складної логіки в React-додатках.

### 6. Які ви знаєте методи життєвого циклу компонента?

### 7. В якому методі життєвого циклу компонента краще робити запити на сервер? Чому?

### 8. В якому методі життєвого циклу компонента краще робити підписку і відписку від лістенера? Чому? Навіщо відписуватися?

### 9. Чи був досвід роботи з контекстом? Коли його варто використовувати?

### 10. У чому особливість PureComponent?

### 11. Чи працював з мемоізованими селекторами (memoized selectors)? Для чого їх використовують і який принцип роботи?

### 12. У чому бачите переваги бібліотеки React?

### 13. Чому бібліотека React швидка? Що таке Virtual DOM і Shadow DOM?

### 14. Навіщо в списках ключі? Чи можна робити ключами індекси елементів масиву? Коли це виправдано?

### 15. В чому основна ідея Redux?

### 16. Робота зі стилями в React.

### 17. React — це бібліотека чи фреймворк? Яка різниця між цими двома поняттями.

### 18. Чи можна використовувати jQuery разом з React? Чому так / ні?

### 19. Що таке codemod?

### 20. Чи доводилося налаштовувати проєкт React з нуля? За допомогою яких інструментів ви це робили?

### 21. Перерахуйте всі бібліотеки, які використовували у зв’язці з React.

### 22. Що найскладніше доводилося реалізовувати за допомогою React?

98.Що таке JSX? Що лежить в його основі?
99.Як працює алгоритм Virtual DOM?
100.Для чого потрібна властивість key під час рендерингу списків?
101.У чому різниця між функціональними та класовими компонентами?
102.Навіщо і коли потрібно передавати props в super () при використанні класових компонентів?
103.Чому потрібно використовувати setState () для оновлення внутрішнього стану компонента?
104.У чому полягає принцип «підйому стану»?
105.Які бібліотеки менеджменту стану React-застосунку ви знаєте? Навіщо вони?
106.Коли варто використовувати Redux? Які є альтернативи?
107.Redux vs Mobx?
108.Розкажіть про базовий принцип роботи React Hooks.
109.У чому різниця між createRef і useRef?
110.Коли варто використовувати React refs? Коли не варто?
111.Які недоліки бібліотеки React бачите?
112.Які патерни використовуєте разом з React?
113.Як ставитесь до типізації разом з React?
114.Як побудувати хорошу архітектуру React-проєкту?
115.Оптимізація React-застосунків? Як виміряти продуктивність програми?
116.Чи можна застосунок на React вбудувати в інший застосунок на React?
