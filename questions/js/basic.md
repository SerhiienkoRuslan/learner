### 1.Які методи HTTP-запитів ви знаєте?

***GET*** - запитує певний ресурс (наприклад, веб-сторінку) у сервера.
***POST*** - надсилає дані для обробки сервером.
***PUT*** - завантажує ресурс на сервер або замінює існуючий ресурс.
***DELETE*** - запитує сервер про видалення певного ресурсу.
***HEAD*** - запитує метадані про ресурс, не запитуючи сам ресурс.
***OPTIONS*** - запитує інформацію про параметри зв'язку, доступні для ресурсу.
***CONNECT*** - встановлює мережеве з'єднання з ресурсом.
***TRACE*** - відтворює отриманий запит, дозволяючи клієнту побачити, що отримав сервер.

### 2.Які версії HTTP-протоколу вам відомі?

HTTP/0.9: Це була перша версія HTTP, яка була створена в 1991 році. Це був простий протокол, який використовувався для
передачі звичайних текстових документів між веб-серверами та клієнтами.
HTTP/1.0: Ця версія HTTP була випущена в 1996 році і представила кілька поліпшень у порівнянні з попередньою версією,
включаючи можливість передачі мультимедійного контенту і підтримку файлів cookie.
HTTP/1.1: Ця версія була випущена в 1999 році і досі є найбільш широко використовуваною версією HTTP. У ній з'явилося
кілька нових функцій, зокрема підтримка постійних з'єднань, блокове кодування та покращене кешування.
HTTP/2: Ця версія була випущена в 2015 році і представила кілька нових функцій для підвищення продуктивності веб-сайтів,
включаючи мультиплексування, серверне підштовхування і стиснення заголовків.
HTTP/3: це остання версія HTTP, яка була випущена в 2020 році. Вона використовує новий протокол під назвою QUIC для
підвищення продуктивності та безпеки за рахунок зменшення затримок і мінімізації відмов з'єднання.

### 3.Які знаєте коди відповіді (стану) HTTP?

200 OK - Ця відповідь означає, що запит пройшов успішно і сервер повернув запитувані дані.
404 Не знайдено - Ця відповідь означає, що запитуваний ресурс не був знайдений на сервері.
301 Перенесено назавжди - ця відповідь означає, що запитуваний ресурс назавжди переміщено на нове місце, і це нове місце
було вказано в заголовку відповіді.
403 Заборонено - Ця відповідь вказує на те, що клієнт не має необхідних дозволів для доступу до запитуваного ресурсу.
500 Внутрішня помилка сервера - ця відповідь вказує на те, що сервер зіткнувся з помилкою при обробці запиту.
304 Not Modified - Ця відповідь вказує на те, що запитуваний ресурс не був змінений з моменту останнього звернення до
нього, і клієнт може використовувати його кешовану версію.
302 Знайдено - Ця відповідь вказує на те, що запитуваний ресурс тимчасово перемістився в нове місце, і нове місце було
вказано в заголовку відповіді.
401 Unauthorized - Ця відповідь вказує на те, що клієнт повинен пройти аутентифікацію, щоб отримати відповідь на запит.

### 4.Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?

- ***CORS*** (Cross-Origin Resource Sharing) - це функція безпеки, що реалізується веб-браузерами для запобігання
  запитам веб-сторінок до іншого домену, ніж той, який обслуговував вихідну веб-сторінку. ***CORS*** забезпечується
  веб-браузерами і не є частиною самого протоколу HTTP.
- Щоб вирішити проблеми з ***CORS***, сервер, який отримує запит, повинен бути налаштований так, щоб дозволяти запити з
  домену, з якого надходить запит. Це можна зробити, додавши відповідні CORS headers до відповіді сервера.
  Найпоширеніші заголовки, які використовуються для включення CORS, такі:
  Access-Control-Allow-Origin: вказує, якому домену дозволено робити запит
  Access-Control-Allow-Methods: вказує, які методи HTTP дозволені для запиту
  Access-Control-Allow-Headers: вказує, які HTTP-заголовки дозволені для запиту

### 5.Що таке cookie?

***Cookie*** - це невеликий текстовий файл, який веб-сайт надсилає веб-браузеру користувача і який зберігається на його
пристрої (наприклад, комп'ютері, смартфоні, планшеті).
Файли cookie використовуються веб-сайтами для різних цілей. Наприклад для управління сесіями. Файли cookie
використовуються для підтримки сеансів користувача. Коли ви входите на веб-сайт, створюється файл cookie, який містить
ідентифікатор вашого сеансу, що дозволяє веб-сайту запам'ятовувати вас і утримувати вас залогіненим під час навігації по
сайту.

### 6.Який максимальний розмір cookie?

4096 bytes (4 kilobytes)

### 7.Що означає директива use strict?

***"Use strict"*** - це директива, яка була введена в ECMAScript 5 для забезпечення більш суворих правил синтаксичного
аналізу та обробки помилок в JavaScript. Коли ця директива використовується, вона вмикає більш суворий режим виконання
JavaScript, що може допомогти відловлювати помилки та покращити якість коду.
Наприклад, коли ми оголушуємо змінну через var, таке оголошення викликає помилку у строгому режимі, оскільки для
оголошення змінної не використовується ключове слово let або const.

### 8.Чим JS відрізняється під час роботи на front-end і back-end?

Ключова відмінність між front-end і back-end JavaScript полягає в їхній сфері застосування. ***Front-end*** JavaScript
використовується для побудови користувацького інтерфейсу та обробки клієнтської функціональності, тоді як ***back-end***
JavaScript використовується для обробки логіки на стороні сервера та управління даними.

### 9.Що таке статична і динамічна типізації?

- ***Динамічна типізація*** означає, що типи даних визначаються і можуть бути змінені під час виконання коду.
- ***Статична типізація*** означає, що ви явно оголошуєте тип даних змінної або параметра функції, а компілятор
  перевіряє правильність типу. Це може допомогти виявити помилки на ранніх стадіях розробки і підвищити загальну
  надійність коду.
  JavaScript - це динамічно-типізована мова, але існують інструменти та бібліотеки, такі як TypeScript наприклад, які
  дозволяють використовувати статичну типізацію.

### 10.Як клієнт взаємодіє із сервером?

***Модель клієнт-сервер*** - це загальна архітектура, де клієнтська програма, запущена на комп'ютері або пристрої
користувача, взаємодіє з серверною програмою, запущеною на віддаленому комп'ютері або сервері.
Ось загальний огляд того, як клієнт взаємодіє з сервером:

1. Встановлення з'єднання: Клієнт ініціює з'єднання з сервером за допомогою мережевого протоколу, такого як TCP/IP або
   HTTP. Клієнт надсилає запит на сервер, який може бути простим повідомленням або більш складним запитом, що містить
   дані.
2. Обробка запиту: Сервер отримує запит і обробляє його. Це може включати доступ до бази даних, виконання певних
   обчислень або отримання інформації з інших серверів.
3. Відправлення відповіді: Після обробки запиту сервер надсилає відповідь клієнту. Відповідь може бути простим
   підтвердженням, повідомленням про помилку або даними, запитаними клієнтом.
4. Отримання відповіді: Клієнт отримує відповідь від сервера й обробляє її. Це може включати відображення інформації
   користувачеві, збереження даних локально або ініціювання подальших запитів до сервера.

### 11.Що таке REST?

REST - це конкретний тип архітектури API, який використовує HTTP-запити для отримання та маніпулювання даними (такі як
GET, POST, PUT і DELETE).

### 12.Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?

Мутабельність та іммутабельність - це поняття, пов'язані з тим, як зберігаються дані й чи можна їх змінювати після
створення.

- Примітивні типи (тип значення):

```jsx
let name = 'Maya';
console.log(name); // виведе "Maya"
let newName = name;
console.log(newName); // виведе "Maya"
name = 'Joe';
console.log(newName); // виведе "Maya"
```

- Не примітивні типи (тип посилання):

```jsx
let person = {name: 'Maya', age: 29};
console.log(person); // виведе об'єкт {name:'Maya', age:29}
let newPerson = person;
console.log(newPerson); // виведе об'єкт {name:'Maya', age:29}
person.name = 'Joe';
console.log(newPerson); // виведе об'єкт {name:'Joe', age:29}
```

Змінні дані можуть бути змінені або модифіковані після їх створення, тоді як незмінні дані не можуть бути змінені.
Іншими словами, якщо тип даних є змінюваним, це означає, що його значення може бути змінено без створення нового
екземпляра цього типу даних, тоді як якщо тип даних є незмінним, це означає, що після створення він не може бути
змінений.

З огляду на це, можна сказати, що ***тип-значення*** є іммутабельними там, де ***тип-посилання*** є мутабельнимим.

### 13.Як шукати помилки в коді? Чи використовуєте дебагер?

Є кілька загальних методів, для пошуку помилок у коді:

1. Прочитайте код: Почніть з уважного читання коду рядок за рядком. Це допоможе вам виявити синтаксичні помилки,
   друкарські помилки та інші помилки, які можуть призвести до збою в роботі коду.

2. Використовуйте console.log(): Розмістіть оператори console.log() у вашому коді, щоб відстежувати значення змінних і
   бачити, де ваш код дає збої.

3. Використовуйте лінтер: ***Лінтер*** - це інструмент, який аналізує ваш код і може допомогти виявити помилки, такі як
   синтаксичні помилки, невикористані змінні та інші поширені помилки.

4. Використовуйте дебагер: Налагоджувач - це інструмент, який дозволяє переглядати ваш код рядок за рядком і бачити стан
   змінних та інших даних під час виконання коду.

У JavaScript найпоширенішим дебагером є вбудований дебагер у браузері Google Chrome. Щоб скористатися ним, ви можете
додати ключове слово debugger до вашого коду в тому місці, де ви хочете почати налагодження. Коли ваш код досягне цієї
точки, він призупиниться, і ви зможете скористатися інструментами дебагера в Інструментах розробника Chrome, щоб
переміщатися по коду, перевіряти змінні і налагоджувати код.

### 14.Яких відомих людей зі світу JS знаєте?

- Брендан Айх - створив JavaScript. Він також є співзасновником і колишнім технічним директором Mozilla. Ця людина
  зібрала JavaScript всього за 10 днів.
- Брайан Ю - викладач комп’ютерних наук Гарвардського університету, який є викладачем курсу CS50.

### 15.Які існують типи даних у JS?

- ***String*** - представляє текстові дані. Приклад: ```'hello', 'hello world'```
- ***Number*** - ціле число або число з плаваючою комою. Приклад: ```3, 3.234, 3e-2```
- ***BigInt*** - ціле число з довільною точністю. Приклад: ```900719925124740999n, 1n```
- ***Boolean*** - будь-яке з двох значень: true або false. Приклад: ```true, false```
- ***undefined*** - тип даних, змінна якого не ініціалізована. Приклад: ```let a;```
- ***null*** - позначає null значення. Приклад: ```let a = null;```
- ***Symbol*** - тип даних, екземпляри якого є унікальними та незмінними. Приклад: ```let value = Symbol('hello');```
- ***Object*** - пари ключ-значення збору даних. Приклад: ```let student = { };```

Тип ***Object*** даних (непримітивний тип) може зберігати колекції даних, тоді як примітивний тип даних може зберігати
лише окремі дані.

### 16.Як перевірити, чи об’єкт є масивом?

Метод ***Array.isArray()*** повертає ***true***, якщо об’єкт є масивом, інакше повертає ***false***

```javascript
const someData = [1, 2, 3];
Array.isArray(someData) // return true

const someData = {
    name: 'Nick'
}
Array.isArray(someData) // return false
```

Для масиву ***typeof*** оператор повертає об’єкт.

```javascript
const arr = [1, 2, 3];
console.log(typeof arr); // object
```

### 17.Як перевірити, чи число є скінченним?

Метод ***isFinite()*** приймає значення як аргумент і повертає, ***false*** якщо значенням є +Infinity, -Infinity
або NaN; інакше він повертає ***true***.

```javascript
isFinite(1 / 0); // false (безкінечність)
isFinite(2 / 34); // true (скінченне значення)
isFinite(1 / '13'); // true (він спочатку приводить дане значення до числа, потім повертає true)
```

### 18.Як перевірити, що змінна рівна NaN?

У JavaScript немає можливості порівняти значення змінної зі значенням ***NaN*** за допомогою оператора рівності (==) або
нерівності (!=). Навіть якщо ви спробуєте порівняти змінну з ***NaN***, ви отримаєте завжди ***false***.

Існує спеціальна функція, ***isNaN()***, яка дозволяє перевірити, чи є значення змінної ***NaN***. Функція повертає
***true***, якщо переданий аргумент є ***NaN***, і ***false*** - якщо переданий аргумент є числом.

```javascript
console.log(isNaN(NaN)); // true
console.log(isNaN('hello')); // true
console.log(isNaN(42)); // false
```

### 19.Чим відрізняється поведінка isNaN() та Number.isNaN()?

***isNaN()*** метод повертає ***true***, якщо значення не є числом.
***Number.isNaN()*** повертає ***true***, якщо число не є числом.

Іншими словами:

***isNaN()*** перетворює значення на число перед його перевіркою.

```javascript
isNaN('Hello'); // true
isNaN("123"); // false

Number.isNaN('Hello'); // false
Number.isNaN("123"); // false
Number.isNaN(NaN); // true
```

Тому, якщо ви хочете перевірити, чи значення є саме ***NaN***, рекомендується використовувати ***Number.isNaN()***. Якщо
ви хочете перевірити, чи значення не є числом (включаючи нечислові рядки, об'єкти та масиви), використовуйте
***isNaN()***.

### 20.Порівняйте ключові слова var, let, const.

У JavaScript ***var***, ***let*** та ***const*** - ключові слова, що використовуються для оголошення змінних.

- ***var*** був початковим способом оголошення змінних у JavaScript, і він є функціонально-обмеженим. Це означає, що
  якщо змінна оголошена за допомогою ***var*** всередині функції, вона доступна лише в межах області видимості цієї
  функції.
  Однак, якщо змінна оголошена поза функцією, вона стає глобальною змінною і може бути доступною з будь-якого місця
  коду. Значення змінної, оголошеної за допомогою ***var***, можна переприсвоювати, і якщо вона не ініціалізована, їй
  буде присвоєно
  значення undefined.

- ***let***:
  Введений в ***ECMAScript 6***, let також використовується для оголошення змінних, але з блоковою областю видимості. Це
  означає, що якщо змінна оголошена за допомогою let всередині блоку, наприклад, інструкції if або циклу, доступ до неї
  можливий лише в межах області видимості цього блоку. Значення змінної, оголошеної за допомогою ***let***, можна
  переприсвоювати, і якщо вона не ініціалізована, їй також буде присвоєно значення undefined.

- ***const***:
  Як і ***let***, ***const*** також було введено в ***ECMAScript 6*** і має блокову область видимості. Однак змінні,
  оголошені за допомогою
  ***const***, не можна перепризначати, тобто після присвоєння значення змінній за допомогою ***const*** його не можна
  змінити. Це
  робить const корисним для оголошення констант або значень, які не повинні змінюватися під час виконання програми. Якщо
  змінну, оголошену з ***const***, не ініціалізувати, виникне синтаксична помилка.

Підсумовуючи, ***var*** має функціональну область видимості й може перепризначатися, ***let*** має блокову область
видимості й може
перепризначатися, а ***const*** має блокову область видимості, але не може перепризначатися.

### 21.Що таке область видимості?

***Область видимості*** – це політика, яка керує доступністю змінних. Змінна, визначена всередині області, доступна лише
в межах цієї області, але недоступна зовні.

У JavaScript області створюються блоками коду, функціями, модулями.

У той час як const і let змінні обмежені блоками коду, функціями або модулями, var змінні обмежені лише функціями або
модулями.

```javascript
function run() {
    var foo = "Foo";
    let bar = "Bar";

    console.log(foo, bar); // Foo Bar

    {
        var moo = "Mooo"
        let baz = "Bazz";
        console.log(moo, baz); // Mooo Bazz
    }

    console.log(moo); // Mooo
    console.log(baz); // ReferenceError
}

run();
```

Області можуть бути вкладеними. Усередині внутрішньої області ви можете отримати доступ до змінних зовнішньої області.

### 22.Що таке деструктуризація?

***Деструктуризація*** — це вираз JavaScript, який дозволяє нам витягувати дані з масивів, об’єктів і карт і
встановлювати їх
у нові, різні змінні. Деструктуризація дозволяє нам витягувати декілька властивостей або елементів із масиву одночасно.

```javascript
var employee = {    // Об'єкт, який ми хочемо деструктуризувати
    firstname: 'Jon',
    lastname: 'Snow',
    dateofbirth: '1990'
};

// Деструктуризація об'єкта на наші змінні
var {firstname, lastname, dateofbirth} = employee;
console.log(firstname, lastname, dateofbirth); // Jon Snow 1990
```

Також ми можемо присвоїти нові імена змінним:

```javascript
var employee = {
    firstname: 'Jon',
    lastname: 'Snow',
    dateofbirth: '1990'
};

// Деструктуризація об'єкта на змінні з іменами, відмінними від імен змінних об'єкту
var {firstname: fn, lastname: ln, dateofbirth: dob} = employee;
console.log(fn, ln, dob); // Jon Snow 1990
```

Крім того, можна присвоїти змінній значення за замовчуванням:

```javascript
var employee = {
    firstname: 'Jon',
    lastname: 'Snow',
    dateofbirth: '1990'
};

var {firstname, lastname, country} = employee;
console.log(firstname, lastname, country); // Jon Snow undefined

// Деструктуризація об'єкта на змінні шляхом присвоєння значень за замовчуванням
var {
    firstname = 'default firstname',
    lastname = 'default lastname',
    country = 'default country'
} = employee;
console.log(firstname, lastname, country); // Jon Snow default country
```

### 23.Для чого призначені методи setTimeout і setInterval?

У JavaScript ***setTimeout*** і ***setInterval*** - це методи, які дозволяють виконати функцію або блок коду через
певний проміжок
часу або повторно з фіксованим інтервалом відповідно.

- ***setTimeout*** використовується для того, щоб виконати функцію або блок коду один раз після того, як пройде
  вказаний проміжок часу. Він приймає два аргументи: ***функцію***, яку потрібно виконати, і ***час затримки*** в
  мілісекундах. Функція буде виконана після закінчення часу затримки.

Наприклад, наступний код встановлює таймаут у 2 секунди й виконує функцію, яка виводить повідомлення у консоль після
закінчення таймауту:

```javascript
var timerID = setTimeout(function () {
    console.log("Hello, world!");
}, 2000);
```

- ***setInterval*** використовується для повторного виконання функції або блоку коду з фіксованим інтервалом. Він
  також приймає два аргументи: ***функцію***, яку потрібно виконати, і ***час затримки*** в мілісекундах. Функція буде
  виконуватися з вказаним інтервалом до тих пір, поки не буде викликано метод clearInterval для її зупинки.

Наприклад, наступний код встановлює інтервал в 1 секунду і виконує функцію, яка щосекунди виводить повідомлення в
консоль:

```javascript
var intervalId = setInterval(function () {
    console.log("Hello, world!");
}, 1000);
```

Щоб видалити ці методи треба використати clearTimer() або clearInterval() відповідно й передати в них змінні:

```javascript
clearTimer(timerID);
clearInterval(intervalId);
```

### 24.Порівняйте підходи роботи з асинхронним кодом: callbacks vs promises vs async/await.

- ***callbacks*** - це традиційний підхід до роботи з асинхронним кодом. Функція зворотного виклику
  передається як аргумент асинхронній функції, а зворотний виклик викликається після завершення операції. Зворотні
  виклики можуть призвести до "пекла зворотних викликів", вкладеної структури з декількох зворотних викликів, що робить
  код складним для читання та обслуговування.

```javascript
function fetchData(callback) {
    setTimeout(() => {
        callback('Data fetched');
    }, 1000);
}

fetchData((result) => {
    console.log(result); // "Data fetched"
});
```

- ***Promises*** були введені для вирішення проблем з callbacks. ***Promises*** - це об'єкт, який представляє можливе
  завершення або невдачу асинхронної операції. ***Promises*** можуть перебувати в одному з трьох станів: в очікуванні,
  виконані або відхилені. ***Promises*** забезпечують більш організований і структурований спосіб роботи з асинхронним
  кодом і
  можуть обробляти декілька асинхронних операцій послідовно або паралельно.

```javascript
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 1000);
    });
}

fetchData().then((result) => {
    console.log(result); // "Data fetched"
}).catch((error) => {
    console.log(error);
});
```

- ***Async/await*** - це більш сучасний підхід до роботи з асинхронним кодом. Він побудований на основі ***promises*** і
  забезпечує
  більш синхронний спосіб роботи з ними. Ключове слово ***async*** використовується для позначення функції як
  асинхронної, а
  ключове слово ***await*** - для очікування завершення виконання обіцянки. ***Async/await*** робить асинхронний код
  більш
  читабельним і легшим в обслуговуванні, а також може обробляти декілька асинхронних операцій послідовно або паралельно.

```javascript
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 1000);
    });
}

async function fetchDataAsync() {
    const result = await fetchData();
    console.log(result); // "Data fetched"
}

fetchDataAsync();
```

***Callbacks*** є традиційним підходом, ***promises*** забезпечують більш структурований спосіб роботи з асинхронним
кодом, а
***async/await*** пропонує більш синхронний спосіб роботи з promises.

### 25.Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?

Так, можна. Однак, як правило, не рекомендується цього робити, оскільки це може мати непередбачувані наслідки й призвести до конфліктів з
іншим кодом, який використовує ці стандартні класи.

У деяких випадках може знадобитися розширити прототип стандартного класу, щоб додати додаткову функціональність.
Наприклад, вам може знадобитися додати до прототипу масиву Array користувацький метод, який виконує певну операцію, не
передбачену стандартними методами Array.

Щоб захистити себе при розширенні прототипу стандартного класу, слід дотримуватись наступних рекомендацій:

- Використовуйте унікальну та описову назву для вашої кастомної властивості або методу, щоб уникнути конфліктів з іншим
кодом.
- Перевірте, чи властивість або метод, який ви хочете додати, вже існує в прототипі, перш ніж додавати його, щоб уникнути
перезапису існуючої функціональності.
- Додавайте кастомну властивість або метод до нового об'єкта прототипу, а не безпосередньо до прототипу стандартного
класу. Таким чином, ви зможете легко видалити або змінити вашу кастомну функціональність, якщо це буде потрібно.
- Використовуйте метод Object.defineProperty, щоб додати вашу власну властивість або метод до прототипу. Це дозволяє
вказати додаткові атрибути для властивості або методу, наприклад, чи є вона перечислюваною або доступною для запису.

Ось приклад того, як можна розширити прототип Array за допомогою користувацького методу:

```javascript
Array.prototype.myCustomMethod = function() {
  // custom code here
};
```

А ось приклад того, як можна додати кастомну властивість до прототипу Array за допомогою Object.defineProperty:

```javascript
Object.defineProperty(Array.prototype, 'myCustomProperty', {
  value: 'my value',
  writable: true,
  enumerable: false,
  configurable: true
});
```

### 26.Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні.

- ***filter()*** використовується для фільтрації масиву відповідно до наших умов.

```javascript
function isCheck(value) {
    return value < 10;
}

var filter = [10, 5, 16, 4, 7, 12].filter(isCheck); // Новий масив: 5,4,7
```

- ***push()*** використовується для додавання нового елемента в кінець масиву.

```javascript
var lang = ["PHP", "Python", "Java", "C"];
lang.push("JavaScript"); // Новий масив: PHP, Python, Java, C, JavaScript
```

- ***map()*** створює масив, викликаючи певну функцію для кожного елемента вихідного масиву.

```javascript
var numbers = [4, 9, 16, 25];
var x = numbers.map(Math.sqrt);
document.write(x); // 2,3,4,5
```

- ***join()*** використовується для об'єднання елементів масиву в рядок.
Іншими словами, метод join() поміщає всі елементи масиву в рядковий список. Цей метод відрізняється від методу "toString()".

```javascript
var lang = ["PHP", "Python", "Java", "C"];
lang.join(" - "); // PHP - Python - Java - C
```

- ***splice()*** використовується для додавання і видалення елементів з масиву.

**array.splice(index, howMany, item1, item2, itemN);**

***index*** − вказує, куди слід вставити новий елемент.
***howMany*** − Ціле число, що вказує на кількість старих елементів масиву, які потрібно видалити.
Якщо howMany дорівнює 0, зі списку масиву не буде видалено жодного елемента.

```javascript
var lang = ["PHP", "Python", "Java", "C"];
lang.splice(2, 0, "Javascript", "Rust"); // Новий масив: PHP, Python, Javascript, Rust, Java, C
```

- ***forEach()*** дозволяє легко викликати функцію для кожного елемента масиву.

```javascript
var num = [18, 12, 10, 15];
num.forEach(function(item) {
   document.writeln(item);
});
// поверне 18 12 10 15
```

### 27.Які перебираючі методи масиву знаєте? У чому їхня відмінність?

- ***forEach()***: Цей ітератор виконує задану функцію один раз для кожного елемента масиву. Він не повертає новий масив, а
модифікує масив, що існує. Функція отримує три аргументи: поточний елемент, індекс поточного елемента і сам масив.

```javascript
arr.forEach(function callback(currentValue, index, array) {
    //your iterator
});
```

- ***map()***: Цей ітератор створює новий масив з результатами виклику наданої функції над кожним елементом вихідного масиву.
Він повертає новий масив з тією ж кількістю елементів, що і вихідний масив. Функція отримує три аргументи: поточний
елемент, індекс поточного елемента і сам масив.

```javascript
const numbers = [1, 4, 9];
const doubles = numbers.map((num) => num * 2);
// тепер doubles дорівнює [2, 8, 18], а numbers до сих пір дорівнює [1, 4, 9]
```

***filter()***: Цей ітератор створює новий масив з усіма елементами, які пройшли перевірку, реалізовану наданою функцією. Він
повертає новий масив, що містить лише ті елементи, які задовольняють заданій умові. Наведена функція приймає три
аргументи: поточний елемент, індекс поточного елемента і сам масив.

```javascript
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter(word => word.length > 6); // ["exuberant", "destruction", "present"]
```

- ***reduce()***: Цей ітератор застосовує функцію до акумулятора і кожного елемента в масиві, щоб звести його до єдиного
значення. Він повертає єдине значення, яке є результатом приведення. Наведена функція приймає чотири аргументи:
акумулятор, поточний елемент, індекс поточного елемента і сам масив.

```javascript
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0);

console.log(sum); // 15
```

- ***some()***: Цей ітератор перевіряє, чи хоча б один елемент масиву проходить перевірку, реалізовану наданою функцією. Він
повертає булеве значення, яке вказує, чи виконується умова хоча б для одного елемента. Функція приймає три аргументи:
поточний елемент, індекс поточного елемента і сам масив.

```javascript
function isBiggerThan10(element, index, array) {
  return element > 10;
}
[2, 5, 8, 1, 4].some(isBiggerThan10);  // false
[12, 5, 8, 1, 4].some(isBiggerThan10); // true
```

- ***every()***: Цей ітератор перевіряє, чи всі елементи масиву проходять перевірку, реалізовану у наданій функції. Він повертає
булеве значення, яке вказує, чи умова є істинною для всіх елементів. Функція отримує три аргументи: поточний елемент,
індекс поточного елемента і сам масив.

```javascript
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

Основна відмінність між цими ітераторами масивів полягає в їхньому призначенні та результатах, які вони отримують.
forEach(), map() та filter() створюють нові масиви на основі вихідного масиву, тоді як reduce() видає єдине значення.
some() та every() повертають булеве значення, яке вказує, чи виконується умова, чи ні. Крім того, наведені функції для
кожного ітератора приймають різні аргументи й виконують різні операції.

### 28.Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?

- ***Оператори присвоювання*** використовуються для присвоювання значень змінним. Базовим оператором присвоювання є знак
рівності (=), але існують також складені оператори присвоювання, які поєднують арифметичну операцію з оператором
присвоювання. Наприклад:

```javascript
let x = 5; // просте присвоєння
x += 3;    // складене присвоювання - еквівалент x = x + 3
```

- ***Оператори порівняння*** використовуються для порівняння значень. Вони повертають булеве значення (true або false) на
  основі порівняння. Деякі з найпоширеніших операторів порівняння в JavaScript включають:

```javascript
'=='       // дорівнює
'!='       // не дорівнює
'<'        // менше ніж
'>'        // більше ніж
'<='       // менше або дорівнює
'>='       // більше або дорівнює
'==='      // строга рівність (перевіряється як значення, так і тип)
'!=='      // строга нерівність (перевіряє як значення, так і тип)
```

- ***Рядкові оператори*** використовуються для маніпулювання рядками. Найпоширенішим рядковим оператором є оператор
  конкатенації (+), який використовується для об'єднання двох або більше рядків. Наприклад:

```javascript
let str1 = "Hello";
let str2 = "world!";
let str3 = str1 + " " + str2; // "Hello world!"
```

- ***Арифметичні оператори*** використовуються для виконання математичних обчислень. Деякі з найпоширеніших арифметичних
  операторів у JavaScript включають:

```javascript
'+'        // додавання
'-'        // віднімання
'*'        // множення
'/'        // ділення
'%'        // модуль (повертає залишок після ділення)
'++'       // інкремент
'--'       // декремент
```

- ***Бітові оператори*** використовуються для виконання побітових операцій над двійковими числами. Ці оператори працюють
  шляхом перетворення чисел у двійковий формат, а потім виконують операцію над кожним бітом. Деякі з найпоширеніших
  бітових операторів у JavaScript включають:

```javascript
'&'        // Встановлює кожен біт в 1, якщо обидва біти дорівнюють 1
'|'        // Встановлює кожен біт в 1, якщо один з двох бітів дорівнює 1
'^'        // Встановлює кожен біт в 1, якщо тільки один з двох бітів дорівнює 1
'~'        // Інвертує всі біти
'<<'       // Зсувається вліво, проштовхуючи нулі праворуч і дозволяючи крайнім лівим бітам відпадати
'>>'       // Зсувається вправо, проштовхуючи копії крайніх лівих бітів зліва, і залишаючи крайні праві біти падати
'>>>'      // Зсувається вправо, проштовхуючи нулі зліва, і дозволяє крайнім правим бітам відпадати
```

Важливо зазначити, що JavaScript має певний порядок пріоритету операторів, який визначає порядок їх обчислення у виразі.

### 29.Опишіть призначення і принципи роботи з колекціями Map і Set.

Колекції ***Map*** і ***Set*** в JavaScript використовуються для зберігання та маніпулювання даними у структурований спосіб. Обидві
колекції з'явилися в ES6 і надають більше функціональності, ніж традиційні масиви.

Метою використання колекції ***Map*** є зберігання пар ключ-значення, де і ключі, і значення можуть бути будь-якого типу. Map
надає можливість легко отримувати доступ до даних, додавати та видаляти їх за ключем. Деякі з принципів роботи з Map:
включають:

- Ключі можуть бути будь-якого типу: На відміну від традиційних об'єктів, де ключі перетворюються на рядки, мапи
дозволяють використовувати ключі будь-якого типу, включаючи об'єкти, функції та примітиви.

- Пошук за ключем: До значень в Map можна отримати доступ за відповідними ключами, що полегшує пошук значень за певними
ключами.

- Ітерація: Записи в Map можна перебирати або за допомогою циклу for...of, або за допомогою вбудованого методу forEach()
мапи.

Ось приклад використання Map:

```javascript
const myMap = new Map();
const key1 = { name: 'John' };
const key2 = { name: 'Jane' };
myMap.set(key1, 'value1');
myMap.set(key2, 'value2');

console.log(myMap.get(key1)); // output: "value1"

myMap.forEach((value, key) => {
  console.log(key, value); // output: { name: 'John' } "value1" 
                          //         { name: 'Jane' } "value2"
});
```

Метою використання колекції ***Set*** є зберігання колекції унікальних значень. Множина гарантує, що жодні два елементи в
колекції не є рівними один одному. Деякі з принципів роботи з колекцією Set включають:

- Унікальні значення: Set можуть містити лише унікальні значення, тобто повторювані значення автоматично видаляються.

- Без індексу: На відміну від масивів, Set не мають індексу. Натомість вони надають спосіб перевірити, чи присутнє
певне значення в колекції.

- Ітерація: Елементи в Set можна перебирати за допомогою циклу for...of або вбудованого методу forEach().

Ось приклад використання Set:

```javascript
const mySet = new Set();
mySet.add('apple');
mySet.add('banana');
mySet.add('apple'); // This value will not be added to the Set
console.log(mySet.has('banana')); // output: true

mySet.forEach(value => {
  console.log(value); // output: "apple", "banana"
});
```

### 30.Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?

У JavaScript об'єкти зберігаються та передаються за посиланням. Коли ви присвоюєте об'єкт змінній або передаєте його як
аргумент функції, ви насправді передаєте посилання на цей об'єкт, а не його копію. Іноді це може призвести до
неочікуваної поведінки, особливо коли ви працюєте зі складними об'єктами, які містять вкладені об'єкти або масиви.

Для створення копії об'єкта можна використовувати або ***поверхневу копію***, або ***глибоку копію***. Різниця між цими двома типами
копій полягає в тому, наскільки глибоко вони копіюють оригінальний об'єкт.

- ***Поверхнева (shallow) копія*** створює новий об'єкт, який посилається на ті самі вкладені об'єкти, що й оригінальний об'єкт. Іншими
словами, дублюється об'єкт верхнього рівня, але не дублюються вкладені об'єкти або масиви. Для створення неглибокої
копії в JavaScript можна використовувати оператор ***spread (...)*** або метод ***Object.assign()***. Ось приклад використання
оператора spread:

```javascript
const originalObject = {a: 1, b: {c: 2}};
const shallowCopy = {...originalObject};
```

У цьому прикладі shallowCopy - це новий об'єкт, який має ті самі властивості, що й originalObject, але на вкладений
об'єкт b все ще посилаються обидва об'єкти.

- ***Глибока (deep) копія***, з іншого боку, створює новий об'єкт з тими самими властивостями і значеннями, що й
  оригінальний об'єкт, включаючи будь-які вкладені об'єкти або масиви. Щоб створити глибоку копію в JavaScript, ви
  можете використовувати методи JSON.parse() і JSON.stringify(). Ось приклад:

```javascript
const originalObject = {a: 1, b: {c: 2}};
const deepCopy = JSON.parse(JSON.stringify(originalObject));
```

У цьому прикладі deepCopy є абсолютно новим об'єктом з тими самими властивостями й значеннями, що й originalObject,
включно з вкладеним об'єктом b.

### 31.З якою метою може бути використаний event listener події fetch self.addEventListener(’fetch’, event => {}) ?

***Event listener події fetch*** може використовуватися в ***service worker*** для перехоплення мережевих запитів, зроблених
веб-сторінкою. Коли сторінка робить запит на ресурс, наприклад, зображення або скрипт, ***service worker*** може
перехопити запит і відповісти на нього власною відповіддю або змінити запит до того, як він потрапить на сервер.

***Event listener події fetch*** також може використовуватися для реалізації стратегій кешування, наприклад, кешування ресурсів
у кеш-пам'яті браузера або отримання ресурсів з віддаленого сервера або локального кешу на основі певних критеріїв.

Крім того, ***event listener події fetch*** можна використовувати для обробки офлайн-сценаріїв, відповідаючи на запити кешованими
ресурсами, коли мережа недоступна.

Загалом, він надає потужний механізм для контролю мережевих запитів і відповідей, і може бути
використаний для реалізації широкого спектра розширених можливостей у веб-додатках, таких як автономна робота,
оптимізація продуктивності й підвищення безпеки.

### 32.Що таке Event loop і як він працює? Розкажіть про мікрозадачі та макрозадачі.

***Event loop*** - це механізм, який використовується JavaScript для обробки асинхронних операцій. Він працює шляхом
безперервної перевірки черги повідомлень на наявність нових подій і виконання їх по черзі, виходячи з їх пріоритету і
контексту виконання. Під асинхронним мається на увазі частину коду, яку ви хочете виконати пізніше. Деякі приклади
асинхронних функцій: setTimeout, callbacks, promises, обробка подій, мережеві запити тощо… JavaScript
використовує цикл подій для обробки всіх цих типів асинхронних завдань за допомогою одного потоку.

***Event loop*** включає: ***call stack***, ***мікрозадачі*** та ***макрозадачі***.

- ***Call stack*** — це стек останній прийшов, перший вийшов. Це місце, куди додається завдання з
  черги макро- або мікро-завдань. Важливо зауважити, що функції додаються до стека викликів у порядку їх виклику. Це
  означає, що функція, додана останньою, завжди виконується першою та першою видаляється зі стеку.

- ***Мікрозадачі*** виконуються одразу після завершення поточного завдання, але до того, як буде оброблено наступне
  макрозавдання. Прикладами мікрозадач є обіцянки та спостерігачі мутацій. Деякі приклади мікрозавдань: 
  - Promise
  - process.nextTick()
  - queueMicrotask()

- ***Макрозадачі*** виконуються на початку наступної ітерації циклу подій. Прикладами макрозадач є встановлення
таймауту, встановлення інтервалу та операції вводу/виводу. Деякі приклади макрозавдань: 
  - setTimeout()
  - setImmediate()
  - setInterval()
  - UI rendering

Коли спрацьовує подія, наприклад, користувач натискає кнопку або API-виклик повертає дані, вона додається до черги
повідомлень як мікрозадача або макрозадача. Після цього цикл обробки подій почне обробляти завдання з черги повідомлень,
починаючи з завдання з найвищим пріоритетом. Коли всі завдання з однаковим пріоритетом будуть завершені, цикл перейде до
наступного рівня пріоритету.

Цей механізм дозволяє JavaScript обробляти декілька завдань одночасно, не блокуючи основний потік. Він також гарантує,
що завдання виконуються в правильному порядку, виходячи з їх пріоритету і поточного контексту виконання.

### 33.Які типи даних бувають у JavaScript? Який буде результат виконання коду?

***Типи даних знаходяться вище у пункті 15 цього файлу***.

```js
let firstObj = {name: 'Hello'};

let secondObj = firstObj;

firstObj = {name: 'Bye'};

console.log(secondObj.name);
```

Результатом роботи цього коду буде ***"Hello"***.

На початку коду створюється змінна firstObj, яка ініціалізується об'єктом, що містить ім'я властивості зі значенням 
"Hello". Потім створюється змінна secondObj, яка ініціалізується значенням firstObj.

Далі створюється новий об'єкт з іменем властивості зі значенням 'Bye', і змінна firstObj перепризначається цьому новому
об'єкту. Однак змінна secondObj все ще вказує на початковий об'єкт з іменем 'Hello'.

### 34.Що таке temporal dead zone?

***Temporal dead zone*** (TDZ) - це поведінка, яка виникає при спробі отримати доступ до змінної до того, як
вона буде оголошена з let або const.

В ECMAScript 6 (ES6), коли змінна оголошується за допомогою let або const, вона стає доступною тільки після оператора її
оголошення. Змінна вважається такою, що перебуває в TDZ від початку блоку, в якому вона оголошена, до моменту досягнення
фактичного оператора оголошення. Під час TDZ будь-яка спроба отримати доступ до змінної призводить до виникнення помилки
посилання (ReferenceError).

Наприклад, розглянемо наступний фрагмент коду:

```javascript
console.log(a); // ReferenceError: a is not defined
let a = 10;
```

У цьому коді оператор console.log намагається отримати доступ до змінної ***a*** до того, як вона буде оголошена за допомогою
let. Це призводить до виникнення ***ReferenceError***, оскільки змінна ***a*** все ще знаходиться в TDZ.

### 35.Як працює boxing / unboxing у JavaScript?

### 36.У чому різниця між оператором in і методом hasOwnProperty?

### 37.Опишіть, за допомогою чого в JS реалізуються такі ООП-парадигми, як інкапсуляція, поліморфізм, абстракція?

### 38.Що таке прототип? Як працює прототипне наслідування в JS? Поясніть роботу коду.

```js
function Main() {
}

Main.prototype = {protected: true};

const obj = new Main();
Main.prototype = {protected: false};

console.log('Object protection: ', obj.protected); 
```

### 39.Яка різниця між композицією та наслідуванням?

### 40. Чому не варто використовувати конструктори типу new String?

### 41.Розкажіть про базовий пристрій і механізм роботи Event loop.

### 42. Що таке записи (records) і кортежі (tuples)? Чим вони відрізняються від звичайних об’єктів?

### 43.Які відмінності в поведінці ES5 функції-конструктора та ES2015 класу?

### 44.Як реалізувати патерн «Модуль»?

### 45. Чому typeof null повертає object?

### 46.Що таке приведення (перетворення) типів у JS?

### 47.Що таке явне і неявне приведення (перетворення) типів даних у JS? Як відбувається перетворення типів у таких прикладах:

```js
{
}
+[] + {} + [1]
!!"false" == !!"true"
    ['x'] == 'x'
```

### 48.Що таке Garbage Collector?

### 49.Опишіть основні принципи роботи «збирача сміття» у JS-рушіях (engines).

### 50.Опишіть призначення і принципи роботи з колекціями WeakMap і WeakSet? Чим вони відрізняються від колекцій Map і Set відповідно?

### 51.Чим відрізняється Observable від Promise?

### 52. Що таке Promise? Назвіть порядок виконання then і catch у ланцюжку.

```js
Promise.resolve(10)
    .then(e => console.log(e)) // ??
    .then(e => Promise.resolve(e))
    .then(console.log) // ??
    .then(e => {
        if (!e) {
            throw 'Error caught';
        }
    })
    .catch(e => {
        console.log(e); // ??
        return new Error('New error');
    })
    .then(e => {
        console.log(e.message); // ??
    })
    .catch(e => {
        console.log(e.message); // ??
    });
```

### 53.Розкажіть про послідовне і паралельне виконання асинхронних функцій. У чому різниця між Promise.all () і Promise.allSettled ()?

### 54.Що таке дескриптори властивостей об’єктів? Розкажіть про їхнє практичне застосування.

### 55.Назвіть кілька способів створення незмінного об’єкта в JavaScript.

### 56.Як створити властивість в об’єкта, яку не можна буде змінити?

### 57.Навіщо потрібен конструктор Proxy? Наведіть приклад використання.

### 58.Що таке ArrayBuffer? У чому різниця між Uint32Array і Float32Array? Який результат виконання коду?

```js
const uint32Array = new Uint32Array();
Array.isArray(uint32Array);
```

### 59.Яким буде результат порівняння?

```js
const url = "HTTPs://xyz.com/path<to>page.html";
encodeURI(url) == encodeURIComponent(url);
```

### 60.Розкажіть про генератори та ітератори.

### 61.Поясніть, що робить наведений код:

```js
function* fn(num) {
    for (let i = 0; i < num; i += 1) {
        yield console.log(i);
    }
}

const loop = fn(5);
loop.next();
loop.next();
```

### 62.Розкажіть про тип даних Symbol і його практичне застосування. Як перевести число з 10-розрядної системи в 16(2,8)-розрядну систему числення?

8.Реалізація патерну Class Free OOP (HTTPs://observablehq.com/@bratter/class-free-oop).
9.Патерн async disposer (HTTPs://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript).
10.Використання регулярних виразів. Коли прийнятно / неприйнятно? Як вони працюють? Як можна зробити читабельним код?
