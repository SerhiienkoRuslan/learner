### 1.Які методи HTTP-запитів ви знаєте?

***GET*** - запитує певний ресурс (наприклад, веб-сторінку) у сервера.
***POST*** - надсилає дані для обробки сервером.
***PUT*** - завантажує ресурс на сервер або замінює існуючий ресурс.
***DELETE*** - запитує сервер про видалення певного ресурсу.
***HEAD*** - запитує метадані про ресурс, не запитуючи сам ресурс.
***OPTIONS*** - запитує інформацію про параметри зв'язку, доступні для ресурсу.
***CONNECT*** - встановлює мережеве з'єднання з ресурсом.
***TRACE*** - відтворює отриманий запит, дозволяючи клієнту побачити, що отримав сервер.

### 2.Які версії HTTP-протоколу вам відомі?

HTTP/0.9: Це була перша версія HTTP, яка була створена в 1991 році. Це був простий протокол, який використовувався для
передачі звичайних текстових документів між веб-серверами та клієнтами.
HTTP/1.0: Ця версія HTTP була випущена в 1996 році і представила кілька поліпшень у порівнянні з попередньою версією,
включаючи можливість передачі мультимедійного контенту і підтримку файлів cookie.
HTTP/1.1: Ця версія була випущена в 1999 році і досі є найбільш широко використовуваною версією HTTP. У ній з'явилося
кілька нових функцій, зокрема підтримка постійних з'єднань, блокове кодування та покращене кешування.
HTTP/2: Ця версія була випущена в 2015 році і представила кілька нових функцій для підвищення продуктивності веб-сайтів,
включаючи мультиплексування, серверне підштовхування і стиснення заголовків.
HTTP/3: це остання версія HTTP, яка була випущена в 2020 році. Вона використовує новий протокол під назвою QUIC для
підвищення продуктивності та безпеки за рахунок зменшення затримок і мінімізації відмов з'єднання.

### 3.Які знаєте коди відповіді (стану) HTTP?

200 OK - Ця відповідь означає, що запит пройшов успішно і сервер повернув запитувані дані.
404 Не знайдено - Ця відповідь означає, що запитуваний ресурс не був знайдений на сервері.
301 Перенесено назавжди - ця відповідь означає, що запитуваний ресурс назавжди переміщено на нове місце, і це нове місце
було вказано в заголовку відповіді.
403 Заборонено - Ця відповідь вказує на те, що клієнт не має необхідних дозволів для доступу до запитуваного ресурсу.
500 Внутрішня помилка сервера - ця відповідь вказує на те, що сервер зіткнувся з помилкою при обробці запиту.
304 Not Modified - Ця відповідь вказує на те, що запитуваний ресурс не був змінений з моменту останнього звернення до
нього, і клієнт може використовувати його кешовану версію.
302 Знайдено - Ця відповідь вказує на те, що запитуваний ресурс тимчасово перемістився в нове місце, і нове місце було
вказано в заголовку відповіді.
401 Unauthorized - Ця відповідь вказує на те, що клієнт повинен пройти аутентифікацію, щоб отримати відповідь на запит.

### 4.Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?

- ***CORS*** (Cross-Origin Resource Sharing) - це функція безпеки, що реалізується веб-браузерами для запобігання
  запитам веб-сторінок до іншого домену, ніж той, який обслуговував вихідну веб-сторінку. ***CORS*** забезпечується
  веб-браузерами і не є частиною самого протоколу HTTP.
- Щоб вирішити проблеми з ***CORS***, сервер, який отримує запит, повинен бути налаштований так, щоб дозволяти запити з
  домену, з якого надходить запит. Це можна зробити, додавши відповідні CORS headers до відповіді сервера.
  Найпоширеніші заголовки, які використовуються для включення CORS, такі:
  Access-Control-Allow-Origin: вказує, якому домену дозволено робити запит
  Access-Control-Allow-Methods: вказує, які методи HTTP дозволені для запиту
  Access-Control-Allow-Headers: вказує, які HTTP-заголовки дозволені для запиту

### 5.Що таке cookie?

***Cookie*** - це невеликий текстовий файл, який веб-сайт надсилає веб-браузеру користувача і який зберігається на його
пристрої (наприклад, комп'ютері, смартфоні, планшеті).
Файли cookie використовуються веб-сайтами для різних цілей. Наприклад для управління сесіями. Файли cookie
використовуються для підтримки сеансів користувача. Коли ви входите на веб-сайт, створюється файл cookie, який містить
ідентифікатор вашого сеансу, що дозволяє веб-сайту запам'ятовувати вас і утримувати вас залогіненим під час навігації по
сайту.

### 6.Який максимальний розмір cookie?

4096 bytes (4 kilobytes)

### 7.Що означає директива use strict?

***"Use strict"*** - це директива, яка була введена в ECMAScript 5 для забезпечення більш суворих правил синтаксичного
аналізу та обробки помилок в JavaScript. Коли ця директива використовується, вона вмикає більш суворий режим виконання
JavaScript, що може допомогти відловлювати помилки та покращити якість коду.
Наприклад, коли ми оголушуємо змінну через var, таке оголошення викликає помилку у строгому режимі, оскільки для
оголошення змінної не використовується ключове слово let або const.

### 8.Чим JS відрізняється під час роботи на front-end і back-end?

Ключова відмінність між front-end і back-end JavaScript полягає в їхній сфері застосування. ***Front-end*** JavaScript
використовується для побудови користувацького інтерфейсу та обробки клієнтської функціональності, тоді як ***back-end***
JavaScript використовується для обробки логіки на стороні сервера та управління даними.

### 9.Що таке статична і динамічна типізації?

- ***Динамічна типізація*** означає, що типи даних визначаються і можуть бути змінені під час виконання коду.
- ***Статична типізація*** означає, що ви явно оголошуєте тип даних змінної або параметра функції, а компілятор
  перевіряє правильність типу. Це може допомогти виявити помилки на ранніх стадіях розробки і підвищити загальну
  надійність коду.
  JavaScript - це динамічно-типізована мова, але існують інструменти та бібліотеки, такі як TypeScript наприклад, які
  дозволяють використовувати статичну типізацію.

### 10.Як клієнт взаємодіє із сервером?

***Модель клієнт-сервер*** - це загальна архітектура, де клієнтська програма, запущена на комп'ютері або пристрої
користувача, взаємодіє з серверною програмою, запущеною на віддаленому комп'ютері або сервері.
Ось загальний огляд того, як клієнт взаємодіє з сервером:

1. Встановлення з'єднання: Клієнт ініціює з'єднання з сервером за допомогою мережевого протоколу, такого як TCP/IP або
   HTTP. Клієнт надсилає запит на сервер, який може бути простим повідомленням або більш складним запитом, що містить
   дані.
2. Обробка запиту: Сервер отримує запит і обробляє його. Це може включати доступ до бази даних, виконання певних
   обчислень або отримання інформації з інших серверів.
3. Відправлення відповіді: Після обробки запиту сервер надсилає відповідь клієнту. Відповідь може бути простим
   підтвердженням, повідомленням про помилку або даними, запитаними клієнтом.
4. Отримання відповіді: Клієнт отримує відповідь від сервера й обробляє її. Це може включати відображення інформації
   користувачеві, збереження даних локально або ініціювання подальших запитів до сервера.

### 11.Що таке REST?

REST - це конкретний тип архітектури API, який використовує HTTP-запити для отримання та маніпулювання даними (такі як
GET, POST, PUT і DELETE).

### 12.Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?

Мутабельність та іммутабельність - це поняття, пов'язані з тим, як зберігаються дані й чи можна їх змінювати після
створення.

- Примітивні типи (тип значення):

```jsx
let name = 'Maya';
console.log(name); // виведе "Maya"
let newName = name;
console.log(newName); // виведе "Maya"
name = 'Joe';
console.log(newName); // виведе "Maya"
```

- Не примітивні типи (тип посилання):

```jsx
let person = {name: 'Maya', age: 29};
console.log(person); // виведе об'єкт {name:'Maya', age:29}
let newPerson = person;
console.log(newPerson); // виведе об'єкт {name:'Maya', age:29}
person.name = 'Joe';
console.log(newPerson); // виведе об'єкт {name:'Joe', age:29}
```

Змінні дані можуть бути змінені або модифіковані після їх створення, тоді як незмінні дані не можуть бути змінені.
Іншими словами, якщо тип даних є змінюваним, це означає, що його значення може бути змінено без створення нового
екземпляра цього типу даних, тоді як якщо тип даних є незмінним, це означає, що після створення він не може бути
змінений.

З огляду на це, можна сказати, що ***тип-значення*** є іммутабельними там, де ***тип-посилання*** є мутабельнимим.

### 13.Як шукати помилки в коді? Чи використовуєте дебагер?

Є кілька загальних методів, для пошуку помилок у коді:

1. Прочитайте код: Почніть з уважного читання коду рядок за рядком. Це допоможе вам виявити синтаксичні помилки,
   друкарські помилки та інші помилки, які можуть призвести до збою в роботі коду.

2. Використовуйте console.log(): Розмістіть оператори console.log() у вашому коді, щоб відстежувати значення змінних і
   бачити, де ваш код дає збої.

3. Використовуйте лінтер: ***Лінтер*** - це інструмент, який аналізує ваш код і може допомогти виявити помилки, такі як
   синтаксичні помилки, невикористані змінні та інші поширені помилки.

4. Використовуйте дебагер: Налагоджувач - це інструмент, який дозволяє переглядати ваш код рядок за рядком і бачити стан
   змінних та інших даних під час виконання коду.

У JavaScript найпоширенішим дебагером є вбудований дебагер у браузері Google Chrome. Щоб скористатися ним, ви можете
додати ключове слово debugger до вашого коду в тому місці, де ви хочете почати налагодження. Коли ваш код досягне цієї
точки, він призупиниться, і ви зможете скористатися інструментами дебагера в Інструментах розробника Chrome, щоб
переміщатися по коду, перевіряти змінні і налагоджувати код.

### 14.Яких відомих людей зі світу JS знаєте?

- Брендан Айх - створив JavaScript. Він також є співзасновником і колишнім технічним директором Mozilla. Ця людина
  зібрала JavaScript всього за 10 днів.
- Брайан Ю - викладач комп’ютерних наук Гарвардського університету, який є викладачем курсу CS50.

### 15.Які існують типи даних у JS?

### 16.Як перевірити, чи об’єкт є масивом?

### 17.Як перевірити, чи число є скінченним?

### 18.Як перевірити, що змінна рівна NaN?

### 19.Чим відрізняється поведінка isNaN() та Number.isNaN()?

### 20.Порівняйте ключові слова var, let, const.

### 21.Що таке область видимості?

### 22.Що таке деструктуризація?

### 23.Для чого призначені методи setTimeout і setInterval?

### 24.Порівняйте підходи роботи з асинхронним кодом: сallbacks vs promises vs async/await.

### 25.Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?

### 26.Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні.

### 27.Які перебираючі методи масиву знаєте? У чому їхня відмінність?

### 28.Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?

### 29.Опишіть призначення і принципи роботи з колекціями Map і Set.

### 30.Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?

### 31.З якою метою може бути використаний event listener події fetch self.addEventListener(’fetch’, event => {}) ?

### 32.Що таке Event loop і як він працює? Розкажіть про мікрозадачі та макрозадачі.

### 33.Які типи даних бувають у JavaScript? Який буде результат виконання коду?

```js
let firstObj = {name: 'Hello'};

let secondObj = firstObj;

firstObj = {name: 'Bye'};

console.log(secondObj.name);
```

### 34.Що таке temporal dead zone?

### 35.Як працює boxing / unboxing у JavaScript?

### 36.У чому різниця між оператором in і методом hasOwnProperty?

### 37.Опишіть, за допомогою чого в JS реалізуються такі ООП-парадигми, як інкапсуляція, поліморфізм, абстракція?

### 38.Що таке прототип? Як працює прототипне наслідування в JS? Поясніть роботу коду.

```js
function Main() {
}

Main.prototype = {protected: true};

const obj = new Main();
Main.prototype = {protected: false};

console.log('Object protection: ', obj.protected); 
```

### 39.Яка різниця між композицією та наслідуванням?

### 40. Чому не варто використовувати конструктори типу new String?

### 41.Розкажіть про базовий пристрій і механізм роботи Event loop.

### 42. Що таке записи (records) і кортежі (tuples)? Чим вони відрізняються від звичайних об’єктів?

### 43.Які відмінності в поведінці ES5 функції-конструктора та ES2015 класу?

### 44.Як реалізувати патерн «Модуль»?

### 45. Чому typeof null повертає object?

### 46.Що таке приведення (перетворення) типів у JS?

### 47.Що таке явне і неявне приведення (перетворення) типів даних у JS? Як відбувається перетворення типів у таких прикладах:

```js
{
}
+[] + {} + [1]
!!"false" == !!"true"
  ['x'] == 'x'
```

### 48.Що таке Garbage Collector?

### 49.Опишіть основні принципи роботи «збирача сміття» у JS-рушіях (engines).

### 50.Опишіть призначення і принципи роботи з колекціями WeakMap і WeakSet? Чим вони відрізняються від колекцій Map і Set відповідно?

### 51.Чим відрізняється Observable від Promise?

### 52. Що таке Promise? Назвіть порядок виконання then і catch у ланцюжку.

```js
Promise.resolve(10)
  .then(e => console.log(e)) // ??
  .then(e => Promise.resolve(e))
  .then(console.log) // ??
  .then(e => {
    if (!e) {
      throw 'Error caught';
    }
  })
  .catch(e => {
    console.log(e); // ??
    return new Error('New error');
  })
  .then(e => {
    console.log(e.message); // ??
  })
  .catch(e => {
    console.log(e.message); // ??
  });
```

### 53.Розкажіть про послідовне і паралельне виконання асинхронних функцій. У чому різниця між Promise.all () і Promise.allSettled ()?

### 54.Що таке дескриптори властивостей об’єктів? Розкажіть про їхнє практичне застосування.

### 55.Назвіть кілька способів створення незмінного об’єкта в JavaScript.

### 56.Як створити властивість в об’єкта, яку не можна буде змінити?

### 57.Навіщо потрібен конструктор Proxy? Наведіть приклад використання.

### 58.Що таке ArrayBuffer? У чому різниця між Uint32Array і Float32Array? Який результат виконання коду?

```js
const uint32Array = new Uint32Array();
Array.isArray(uint32Array);
```

### 59.Яким буде результат порівняння?

```js
const url = "HTTPs://xyz.com/path<to>page.html";
encodeURI(url) == encodeURIComponent(url);
```

### 60.Розкажіть про генератори та ітератори.

### 61.Поясніть, що робить наведений код:

```js
function* fn(num) {
  for (let i = 0; i < num; i += 1) {
    yield console.log(i);
  }
}

const loop = fn(5);
loop.next();
loop.next();
```

### 62.Розкажіть про тип даних Symbol і його практичне застосування. Як перевести число з 10-розрядної системи в 16(2,8)-розрядну систему числення?

8.Реалізація патерну Class Free OOP (HTTPs://observablehq.com/@bratter/class-free-oop).
9.Патерн async disposer (HTTPs://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript).
10.Використання регулярних виразів. Коли прийнятно / неприйнятно? Як вони працюють? Як можна зробити читабельним код?
