### 1.Які методи HTTP-запитів ви знаєте?

***GET*** - запитує певний ресурс (наприклад, веб-сторінку) у сервера.
***POST*** - надсилає дані для обробки сервером.
***PUT*** - завантажує ресурс на сервер або замінює існуючий ресурс.
***DELETE*** - запитує сервер про видалення певного ресурсу.
***HEAD*** - запитує метадані про ресурс, не запитуючи сам ресурс.
***OPTIONS*** - запитує інформацію про параметри зв'язку, доступні для ресурсу.
***CONNECT*** - встановлює мережеве з'єднання з ресурсом.
***TRACE*** - відтворює отриманий запит, дозволяючи клієнту побачити, що отримав сервер.

### 2.Які версії HTTP-протоколу вам відомі?

HTTP/0.9: Це була перша версія HTTP, яка була створена в 1991 році. Це був простий протокол, який використовувався для
передачі звичайних текстових документів між веб-серверами та клієнтами.
HTTP/1.0: Ця версія HTTP була випущена в 1996 році і представила кілька поліпшень у порівнянні з попередньою версією,
включаючи можливість передачі мультимедійного контенту і підтримку файлів cookie.
HTTP/1.1: Ця версія була випущена в 1999 році і досі є найбільш широко використовуваною версією HTTP. У ній з'явилося
кілька нових функцій, зокрема підтримка постійних з'єднань, блокове кодування та покращене кешування.
HTTP/2: Ця версія була випущена в 2015 році і представила кілька нових функцій для підвищення продуктивності веб-сайтів,
включаючи мультиплексування, серверне підштовхування і стиснення заголовків.
HTTP/3: це остання версія HTTP, яка була випущена в 2020 році. Вона використовує новий протокол під назвою QUIC для
підвищення продуктивності та безпеки за рахунок зменшення затримок і мінімізації відмов з'єднання.

### 3.Які знаєте коди відповіді (стану) HTTP?

200 OK - Ця відповідь означає, що запит пройшов успішно і сервер повернув запитувані дані.
404 Не знайдено - Ця відповідь означає, що запитуваний ресурс не був знайдений на сервері.
301 Перенесено назавжди - ця відповідь означає, що запитуваний ресурс назавжди переміщено на нове місце, і це нове місце
було вказано в заголовку відповіді.
403 Заборонено - Ця відповідь вказує на те, що клієнт не має необхідних дозволів для доступу до запитуваного ресурсу.
500 Внутрішня помилка сервера - ця відповідь вказує на те, що сервер зіткнувся з помилкою при обробці запиту.
304 Not Modified - Ця відповідь вказує на те, що запитуваний ресурс не був змінений з моменту останнього звернення до
нього, і клієнт може використовувати його кешовану версію.
302 Знайдено - Ця відповідь вказує на те, що запитуваний ресурс тимчасово перемістився в нове місце, і нове місце було
вказано в заголовку відповіді.
401 Unauthorized - Ця відповідь вказує на те, що клієнт повинен пройти аутентифікацію, щоб отримати відповідь на запит.

### 4.Що таке Cross-Origin Resource Sharing? Як усунути проблеми з CORS?

- ***CORS*** (Cross-Origin Resource Sharing) - це функція безпеки, що реалізується веб-браузерами для запобігання
  запитам веб-сторінок до іншого домену, ніж той, який обслуговував вихідну веб-сторінку. ***CORS*** забезпечується
  веб-браузерами і не є частиною самого протоколу HTTP.
- Щоб вирішити проблеми з ***CORS***, сервер, який отримує запит, повинен бути налаштований так, щоб дозволяти запити з
  домену, з якого надходить запит. Це можна зробити, додавши відповідні CORS headers до відповіді сервера.
  Найпоширеніші заголовки, які використовуються для включення CORS, такі:
  Access-Control-Allow-Origin: вказує, якому домену дозволено робити запит
  Access-Control-Allow-Methods: вказує, які методи HTTP дозволені для запиту
  Access-Control-Allow-Headers: вказує, які HTTP-заголовки дозволені для запиту

### 5.Що таке cookie?

***Cookie*** - це невеликий текстовий файл, який веб-сайт надсилає веб-браузеру користувача і який зберігається на його
пристрої (наприклад, комп'ютері, смартфоні, планшеті).
Файли cookie використовуються веб-сайтами для різних цілей. Наприклад для управління сесіями. Файли cookie
використовуються для підтримки сеансів користувача. Коли ви входите на веб-сайт, створюється файл cookie, який містить
ідентифікатор вашого сеансу, що дозволяє веб-сайту запам'ятовувати вас і утримувати вас залогіненим під час навігації по
сайту.

### 6.Який максимальний розмір cookie?

4096 bytes (4 kilobytes)

### 7.Що означає директива use strict?

***"Use strict"*** - це директива, яка була введена в ECMAScript 5 для забезпечення більш суворих правил синтаксичного
аналізу та обробки помилок в JavaScript. Коли ця директива використовується, вона вмикає більш суворий режим виконання
JavaScript, що може допомогти відловлювати помилки та покращити якість коду.
Наприклад, коли ми оголушуємо змінну через var, таке оголошення викликає помилку у строгому режимі, оскільки для
оголошення змінної не використовується ключове слово let або const.

### 8.Чим JS відрізняється під час роботи на front-end і back-end?

Ключова відмінність між front-end і back-end JavaScript полягає в їхній сфері застосування. ***Front-end*** JavaScript
використовується для побудови користувацького інтерфейсу та обробки клієнтської функціональності, тоді як ***back-end***
JavaScript використовується для обробки логіки на стороні сервера та управління даними.

### 9.Що таке статична і динамічна типізації?

- ***Динамічна типізація*** означає, що типи даних визначаються і можуть бути змінені під час виконання коду.
- ***Статична типізація*** означає, що ви явно оголошуєте тип даних змінної або параметра функції, а компілятор
  перевіряє правильність типу. Це може допомогти виявити помилки на ранніх стадіях розробки і підвищити загальну
  надійність коду.
  JavaScript - це динамічно-типізована мова, але існують інструменти та бібліотеки, такі як TypeScript наприклад, які
  дозволяють використовувати статичну типізацію.

### 10.Як клієнт взаємодіє із сервером?

***Модель клієнт-сервер*** - це загальна архітектура, де клієнтська програма, запущена на комп'ютері або пристрої
користувача, взаємодіє з серверною програмою, запущеною на віддаленому комп'ютері або сервері.
Ось загальний огляд того, як клієнт взаємодіє з сервером:

1. Встановлення з'єднання: Клієнт ініціює з'єднання з сервером за допомогою мережевого протоколу, такого як TCP/IP або
   HTTP. Клієнт надсилає запит на сервер, який може бути простим повідомленням або більш складним запитом, що містить
   дані.
2. Обробка запиту: Сервер отримує запит і обробляє його. Це може включати доступ до бази даних, виконання певних
   обчислень або отримання інформації з інших серверів.
3. Відправлення відповіді: Після обробки запиту сервер надсилає відповідь клієнту. Відповідь може бути простим
   підтвердженням, повідомленням про помилку або даними, запитаними клієнтом.
4. Отримання відповіді: Клієнт отримує відповідь від сервера й обробляє її. Це може включати відображення інформації
   користувачеві, збереження даних локально або ініціювання подальших запитів до сервера.

### 11.Що таке REST?

REST - це конкретний тип архітектури API, який використовує HTTP-запити для отримання та маніпулювання даними (такі як
GET, POST, PUT і DELETE).

### 12.Поясніть поняття мутабельність / іммутабельність? Які типи є мутабельними й навпаки?

Мутабельність та іммутабельність - це поняття, пов'язані з тим, як зберігаються дані й чи можна їх змінювати після
створення.

- Примітивні типи (тип значення):

```jsx
let name = 'Maya';
console.log(name); // виведе "Maya"
let newName = name;
console.log(newName); // виведе "Maya"
name = 'Joe';
console.log(newName); // виведе "Maya"
```

- Не примітивні типи (тип посилання):

```jsx
let person = {name: 'Maya', age: 29};
console.log(person); // виведе об'єкт {name:'Maya', age:29}
let newPerson = person;
console.log(newPerson); // виведе об'єкт {name:'Maya', age:29}
person.name = 'Joe';
console.log(newPerson); // виведе об'єкт {name:'Joe', age:29}
```

Змінні дані можуть бути змінені або модифіковані після їх створення, тоді як незмінні дані не можуть бути змінені.
Іншими словами, якщо тип даних є змінюваним, це означає, що його значення може бути змінено без створення нового
екземпляра цього типу даних, тоді як якщо тип даних є незмінним, це означає, що після створення він не може бути
змінений.

З огляду на це, можна сказати, що ***тип-значення*** є іммутабельними там, де ***тип-посилання*** є мутабельнимим.

### 13.Як шукати помилки в коді? Чи використовуєте дебагер?

Є кілька загальних методів, для пошуку помилок у коді:

1. Прочитайте код: Почніть з уважного читання коду рядок за рядком. Це допоможе вам виявити синтаксичні помилки,
   друкарські помилки та інші помилки, які можуть призвести до збою в роботі коду.

2. Використовуйте console.log(): Розмістіть оператори console.log() у вашому коді, щоб відстежувати значення змінних і
   бачити, де ваш код дає збої.

3. Використовуйте лінтер: ***Лінтер*** - це інструмент, який аналізує ваш код і може допомогти виявити помилки, такі як
   синтаксичні помилки, невикористані змінні та інші поширені помилки.

4. Використовуйте дебагер: Налагоджувач - це інструмент, який дозволяє переглядати ваш код рядок за рядком і бачити стан
   змінних та інших даних під час виконання коду.

У JavaScript найпоширенішим дебагером є вбудований дебагер у браузері Google Chrome. Щоб скористатися ним, ви можете
додати ключове слово debugger до вашого коду в тому місці, де ви хочете почати налагодження. Коли ваш код досягне цієї
точки, він призупиниться, і ви зможете скористатися інструментами дебагера в Інструментах розробника Chrome, щоб
переміщатися по коду, перевіряти змінні і налагоджувати код.

### 14.Яких відомих людей зі світу JS знаєте?

- Брендан Айх - створив JavaScript. Він також є співзасновником і колишнім технічним директором Mozilla. Ця людина
  зібрала JavaScript всього за 10 днів.
- Брайан Ю - викладач комп’ютерних наук Гарвардського університету, який є викладачем курсу CS50.

### 15.Які існують типи даних у JS?

- ***String*** - представляє текстові дані. Приклад: ```'hello', 'hello world'```
- ***Number*** - ціле число або число з плаваючою комою. Приклад: ```3, 3.234, 3e-2```
- ***BigInt*** - ціле число з довільною точністю. Приклад: ```900719925124740999n, 1n```
- ***Boolean*** - будь-яке з двох значень: true або false. Приклад: ```true, false```
- ***undefined*** - тип даних, змінна якого не ініціалізована. Приклад: ```let a;```
- ***null*** - позначає null значення. Приклад: ```let a = null;```
- ***Symbol*** - тип даних, екземпляри якого є унікальними та незмінними. Приклад: ```let value = Symbol('hello');```
- ***Object*** - пари ключ-значення збору даних. Приклад: ```let student = { };```

Тип ***Object*** даних (непримітивний тип) може зберігати колекції даних, тоді як примітивний тип даних може зберігати
лише окремі дані.

### 16.Як перевірити, чи об’єкт є масивом?

Метод ***Array.isArray()*** повертає ***true***, якщо об’єкт є масивом, інакше повертає ***false***

```javascript
const someData = [1, 2, 3];
Array.isArray(someData) // return true

const someData = {
    name: 'Nick'
}
Array.isArray(someData) // return false
```

Для масиву ***typeof*** оператор повертає об’єкт.

```javascript
const arr = [1, 2, 3];
console.log(typeof arr); // object
```

### 17.Як перевірити, чи число є скінченним?

Метод ***isFinite()*** приймає значення як аргумент і повертає, ***false*** якщо значенням є +Infinity, -Infinity
або NaN; інакше він повертає ***true***.

```javascript
isFinite(1 / 0); // false (безкінечність)
isFinite(2 / 34); // true (скінченне значення)
isFinite(1 / '13'); // true (він спочатку приводить дане значення до числа, потім повертає true)
```

### 18.Як перевірити, що змінна рівна NaN?

У JavaScript немає можливості порівняти значення змінної зі значенням ***NaN*** за допомогою оператора рівності (==) або
нерівності (!=). Навіть якщо ви спробуєте порівняти змінну з ***NaN***, ви отримаєте завжди ***false***.

Існує спеціальна функція, ***isNaN()***, яка дозволяє перевірити, чи є значення змінної ***NaN***. Функція повертає
***true***, якщо переданий аргумент є ***NaN***, і ***false*** - якщо переданий аргумент є числом.

```javascript
console.log(isNaN(NaN)); // true
console.log(isNaN('hello')); // true
console.log(isNaN(42)); // false
```

### 19.Чим відрізняється поведінка isNaN() та Number.isNaN()?

***isNaN()*** метод повертає ***true***, якщо значення не є числом.
***Number.isNaN()*** повертає ***true***, якщо число не є числом.

Іншими словами:

***isNaN()*** перетворює значення на число перед його перевіркою.

```javascript
isNaN('Hello'); // true
isNaN("123"); // false

Number.isNaN('Hello'); // false
Number.isNaN("123"); // false
Number.isNaN(NaN); // true
```

Тому, якщо ви хочете перевірити, чи значення є саме ***NaN***, рекомендується використовувати ***Number.isNaN()***. Якщо
ви хочете перевірити, чи значення не є числом (включаючи нечислові рядки, об'єкти та масиви), використовуйте
***isNaN()***.

### 20.Порівняйте ключові слова var, let, const.

У JavaScript ***var***, ***let*** та ***const*** - ключові слова, що використовуються для оголошення змінних.

- ***var*** був початковим способом оголошення змінних у JavaScript, і він є функціонально-обмеженим. Це означає, що
  якщо змінна оголошена за допомогою ***var*** всередині функції, вона доступна лише в межах області видимості цієї
  функції.
  Однак, якщо змінна оголошена поза функцією, вона стає глобальною змінною і може бути доступною з будь-якого місця
  коду. Значення змінної, оголошеної за допомогою ***var***, можна переприсвоювати, і якщо вона не ініціалізована, їй
  буде присвоєно
  значення undefined.

- ***let***:
  Введений в ***ECMAScript 6***, let також використовується для оголошення змінних, але з блоковою областю видимості. Це
  означає, що якщо змінна оголошена за допомогою let всередині блоку, наприклад, інструкції if або циклу, доступ до неї
  можливий лише в межах області видимості цього блоку. Значення змінної, оголошеної за допомогою ***let***, можна
  переприсвоювати, і якщо вона не ініціалізована, їй також буде присвоєно значення undefined.

- ***const***:
  Як і ***let***, ***const*** також було введено в ***ECMAScript 6*** і має блокову область видимості. Однак змінні,
  оголошені за допомогою
  ***const***, не можна перепризначати, тобто після присвоєння значення змінній за допомогою ***const*** його не можна
  змінити. Це
  робить const корисним для оголошення констант або значень, які не повинні змінюватися під час виконання програми. Якщо
  змінну, оголошену з ***const***, не ініціалізувати, виникне синтаксична помилка.

Підсумовуючи, ***var*** має функціональну область видимості й може перепризначатися, ***let*** має блокову область
видимості й може
перепризначатися, а ***const*** має блокову область видимості, але не може перепризначатися.

### 21.Що таке область видимості?

***Область видимості*** – це політика, яка керує доступністю змінних. Змінна, визначена всередині області, доступна лише
в межах цієї області, але недоступна зовні.

У JavaScript області створюються блоками коду, функціями, модулями.

У той час як const і let змінні обмежені блоками коду, функціями або модулями, var змінні обмежені лише функціями або
модулями.

```javascript
function run() {
    var foo = "Foo";
    let bar = "Bar";

    console.log(foo, bar); // Foo Bar

    {
        var moo = "Mooo"
        let baz = "Bazz";
        console.log(moo, baz); // Mooo Bazz
    }

    console.log(moo); // Mooo
    console.log(baz); // ReferenceError
}

run();
```

Області можуть бути вкладеними. Усередині внутрішньої області ви можете отримати доступ до змінних зовнішньої області.

### 22.Що таке деструктуризація?

***Деструктуризація*** — це вираз JavaScript, який дозволяє нам витягувати дані з масивів, об’єктів і карт і
встановлювати їх
у нові, різні змінні. Деструктуризація дозволяє нам витягувати декілька властивостей або елементів із масиву одночасно.

```javascript
var employee = {    // Об'єкт, який ми хочемо деструктуризувати
    firstname: 'Jon',
    lastname: 'Snow',
    dateofbirth: '1990'
};

// Деструктуризація об'єкта на наші змінні
var {firstname, lastname, dateofbirth} = employee;
console.log(firstname, lastname, dateofbirth); // Jon Snow 1990
```

Також ми можемо присвоїти нові імена змінним:

```javascript
var employee = {
    firstname: 'Jon',
    lastname: 'Snow',
    dateofbirth: '1990'
};

// Деструктуризація об'єкта на змінні з іменами, відмінними від імен змінних об'єкту
var {firstname: fn, lastname: ln, dateofbirth: dob} = employee;
console.log(fn, ln, dob); // Jon Snow 1990
```

Крім того, можна присвоїти змінній значення за замовчуванням:

```javascript
var employee = {
    firstname: 'Jon',
    lastname: 'Snow',
    dateofbirth: '1990'
};

var {firstname, lastname, country} = employee;
console.log(firstname, lastname, country); // Jon Snow undefined

// Деструктуризація об'єкта на змінні шляхом присвоєння значень за замовчуванням
var {
    firstname = 'default firstname',
    lastname = 'default lastname',
    country = 'default country'
} = employee;
console.log(firstname, lastname, country); // Jon Snow default country
```

### 23.Для чого призначені методи setTimeout і setInterval?

У JavaScript ***setTimeout*** і ***setInterval*** - це методи, які дозволяють виконати функцію або блок коду через
певний проміжок
часу або повторно з фіксованим інтервалом відповідно.

- ***setTimeout*** використовується для того, щоб виконати функцію або блок коду один раз після того, як пройде
  вказаний проміжок часу. Він приймає два аргументи: ***функцію***, яку потрібно виконати, і ***час затримки*** в
  мілісекундах. Функція буде виконана після закінчення часу затримки.

Наприклад, наступний код встановлює таймаут у 2 секунди й виконує функцію, яка виводить повідомлення у консоль після
закінчення таймауту:

```javascript
var timerID = setTimeout(function () {
    console.log("Hello, world!");
}, 2000);
```

- ***setInterval*** використовується для повторного виконання функції або блоку коду з фіксованим інтервалом. Він
  також приймає два аргументи: ***функцію***, яку потрібно виконати, і ***час затримки*** в мілісекундах. Функція буде
  виконуватися з вказаним інтервалом до тих пір, поки не буде викликано метод clearInterval для її зупинки.

Наприклад, наступний код встановлює інтервал в 1 секунду і виконує функцію, яка щосекунди виводить повідомлення в
консоль:

```javascript
var intervalId = setInterval(function () {
    console.log("Hello, world!");
}, 1000);
```

Щоб видалити ці методи треба використати clearTimer() або clearInterval() відповідно й передати в них змінні:

```javascript
clearTimer(timerID);
clearInterval(intervalId);
```

### 24.Порівняйте підходи роботи з асинхронним кодом: callbacks vs promises vs async/await.

- ***callbacks*** - це традиційний підхід до роботи з асинхронним кодом. Функція зворотного виклику
  передається як аргумент асинхронній функції, а зворотний виклик викликається після завершення операції. Зворотні
  виклики можуть призвести до "пекла зворотних викликів", вкладеної структури з декількох зворотних викликів, що робить
  код складним для читання та обслуговування.

```javascript
function fetchData(callback) {
    setTimeout(() => {
        callback('Data fetched');
    }, 1000);
}

fetchData((result) => {
    console.log(result); // "Data fetched"
});
```

- ***Promises*** були введені для вирішення проблем з callbacks. ***Promises*** - це об'єкт, який представляє можливе
  завершення або невдачу асинхронної операції. ***Promises*** можуть перебувати в одному з трьох станів: в очікуванні,
  виконані або відхилені. ***Promises*** забезпечують більш організований і структурований спосіб роботи з асинхронним
  кодом і
  можуть обробляти декілька асинхронних операцій послідовно або паралельно.

```javascript
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 1000);
    });
}

fetchData().then((result) => {
    console.log(result); // "Data fetched"
}).catch((error) => {
    console.log(error);
});
```

- ***Async/await*** - це більш сучасний підхід до роботи з асинхронним кодом. Він побудований на основі ***promises*** і
  забезпечує
  більш синхронний спосіб роботи з ними. Ключове слово ***async*** використовується для позначення функції як
  асинхронної, а
  ключове слово ***await*** - для очікування завершення виконання обіцянки. ***Async/await*** робить асинхронний код
  більш
  читабельним і легшим в обслуговуванні, а також може обробляти декілька асинхронних операцій послідовно або паралельно.

```javascript
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 1000);
    });
}

async function fetchDataAsync() {
    const result = await fetchData();
    console.log(result); // "Data fetched"
}

fetchDataAsync();
```

***Callbacks*** є традиційним підходом, ***promises*** забезпечують більш структурований спосіб роботи з асинхронним
кодом, а
***async/await*** пропонує більш синхронний спосіб роботи з promises.

### 25.Чи можна записувати нові властивості / функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?

Так, можна. Однак, як правило, не рекомендується цього робити, оскільки це може мати непередбачувані наслідки й призвести до конфліктів з
іншим кодом, який використовує ці стандартні класи.

У деяких випадках може знадобитися розширити прототип стандартного класу, щоб додати додаткову функціональність.
Наприклад, вам може знадобитися додати до прототипу масиву Array користувацький метод, який виконує певну операцію, не
передбачену стандартними методами Array.

Щоб захистити себе при розширенні прототипу стандартного класу, слід дотримуватись наступних рекомендацій:

- Використовуйте унікальну та описову назву для вашої кастомної властивості або методу, щоб уникнути конфліктів з іншим
кодом.
- Перевірте, чи властивість або метод, який ви хочете додати, вже існує в прототипі, перш ніж додавати його, щоб уникнути
перезапису існуючої функціональності.
- Додавайте кастомну властивість або метод до нового об'єкта прототипу, а не безпосередньо до прототипу стандартного
класу. Таким чином, ви зможете легко видалити або змінити вашу кастомну функціональність, якщо це буде потрібно.
- Використовуйте метод Object.defineProperty, щоб додати вашу власну властивість або метод до прототипу. Це дозволяє
вказати додаткові атрибути для властивості або методу, наприклад, чи є вона перечислюваною або доступною для запису.

Ось приклад того, як можна розширити прототип Array за допомогою користувацького методу:

```javascript
Array.prototype.myCustomMethod = function() {
  // custom code here
};
```

А ось приклад того, як можна додати кастомну властивість до прототипу Array за допомогою Object.defineProperty:

```javascript
Object.defineProperty(Array.prototype, 'myCustomProperty', {
  value: 'my value',
  writable: true,
  enumerable: false,
  configurable: true
});
```

### 26.Назвіть методи масивів, які пам’ятаєте, і скажіть, для чого вони потрібні.

- ***filter()*** використовується для фільтрації масиву відповідно до наших умов.

```javascript
function isCheck(value) {
    return value < 10;
}

var filter = [10, 5, 16, 4, 7, 12].filter(isCheck); // Новий масив: 5,4,7
```

- ***push()*** використовується для додавання нового елемента в кінець масиву.

```javascript
var lang = ["PHP", "Python", "Java", "C"];
lang.push("JavaScript"); // Новий масив: PHP, Python, Java, C, JavaScript
```

- ***map()*** створює масив, викликаючи певну функцію для кожного елемента вихідного масиву.

```javascript
var numbers = [4, 9, 16, 25];
var x = numbers.map(Math.sqrt);
document.write(x); // 2,3,4,5
```

- ***join()*** використовується для об'єднання елементів масиву в рядок.
Іншими словами, метод join() поміщає всі елементи масиву в рядковий список. Цей метод відрізняється від методу "toString()".

```javascript
var lang = ["PHP", "Python", "Java", "C"];
lang.join(" - "); // PHP - Python - Java - C
```

- ***splice()*** використовується для додавання і видалення елементів з масиву.

**array.splice(index, howMany, item1, item2, itemN);**

***index*** − вказує, куди слід вставити новий елемент.
***howMany*** − Ціле число, що вказує на кількість старих елементів масиву, які потрібно видалити.
Якщо howMany дорівнює 0, зі списку масиву не буде видалено жодного елемента.

```javascript
var lang = ["PHP", "Python", "Java", "C"];
lang.splice(2, 0, "Javascript", "Rust"); // Новий масив: PHP, Python, Javascript, Rust, Java, C
```

- ***forEach()*** дозволяє легко викликати функцію для кожного елемента масиву.

```javascript
var num = [18, 12, 10, 15];
num.forEach(function(item) {
   document.writeln(item);
});
// поверне 18 12 10 15
```

### 27.Які перебираючі методи масиву знаєте? У чому їхня відмінність?

- ***forEach()***: Цей ітератор виконує задану функцію один раз для кожного елемента масиву. Він не повертає новий масив, а
модифікує масив, що існує. Функція отримує три аргументи: поточний елемент, індекс поточного елемента і сам масив.

```javascript
arr.forEach(function callback(currentValue, index, array) {
    //your iterator
});
```

- ***map()***: Цей ітератор створює новий масив з результатами виклику наданої функції над кожним елементом вихідного масиву.
Він повертає новий масив з тією ж кількістю елементів, що і вихідний масив. Функція отримує три аргументи: поточний
елемент, індекс поточного елемента і сам масив.

```javascript
const numbers = [1, 4, 9];
const doubles = numbers.map((num) => num * 2);
// тепер doubles дорівнює [2, 8, 18], а numbers до сих пір дорівнює [1, 4, 9]
```

***filter()***: Цей ітератор створює новий масив з усіма елементами, які пройшли перевірку, реалізовану наданою функцією. Він
повертає новий масив, що містить лише ті елементи, які задовольняють заданій умові. Наведена функція приймає три
аргументи: поточний елемент, індекс поточного елемента і сам масив.

```javascript
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter(word => word.length > 6); // ["exuberant", "destruction", "present"]
```

- ***reduce()***: Цей ітератор застосовує функцію до акумулятора і кожного елемента в масиві, щоб звести його до єдиного
значення. Він повертає єдине значення, яке є результатом приведення. Наведена функція приймає чотири аргументи:
акумулятор, поточний елемент, індекс поточного елемента і сам масив.

```javascript
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0);

console.log(sum); // 15
```

- ***some()***: Цей ітератор перевіряє, чи хоча б один елемент масиву проходить перевірку, реалізовану наданою функцією. Він
повертає булеве значення, яке вказує, чи виконується умова хоча б для одного елемента. Функція приймає три аргументи:
поточний елемент, індекс поточного елемента і сам масив.

```javascript
function isBiggerThan10(element, index, array) {
  return element > 10;
}
[2, 5, 8, 1, 4].some(isBiggerThan10);  // false
[12, 5, 8, 1, 4].some(isBiggerThan10); // true
```

- ***every()***: Цей ітератор перевіряє, чи всі елементи масиву проходять перевірку, реалізовану у наданій функції. Він повертає
булеве значення, яке вказує, чи умова є істинною для всіх елементів. Функція отримує три аргументи: поточний елемент,
індекс поточного елемента і сам масив.

```javascript
function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough);   // false
[12, 54, 18, 130, 44].every(isBigEnough); // true
```

Основна відмінність між цими ітераторами масивів полягає в їхньому призначенні та результатах, які вони отримують.
forEach(), map() та filter() створюють нові масиви на основі вихідного масиву, тоді як reduce() видає єдине значення.
some() та every() повертають булеве значення, яке вказує, чи виконується умова, чи ні. Крім того, наведені функції для
кожного ітератора приймають різні аргументи й виконують різні операції.

### 28.Як працюють оператори присвоєння / порівняння / рядкові / арифметичні / бітові тощо?

- ***Оператори присвоювання*** використовуються для присвоювання значень змінним. Базовим оператором присвоювання є знак
рівності (=), але існують також складені оператори присвоювання, які поєднують арифметичну операцію з оператором
присвоювання. Наприклад:

```javascript
let x = 5; // просте присвоєння
x += 3;    // складене присвоювання - еквівалент x = x + 3
```

- ***Оператори порівняння*** використовуються для порівняння значень. Вони повертають булеве значення (true або false) на
  основі порівняння. Деякі з найпоширеніших операторів порівняння в JavaScript включають:

```javascript
'=='       // дорівнює
'!='       // не дорівнює
'<'        // менше ніж
'>'        // більше ніж
'<='       // менше або дорівнює
'>='       // більше або дорівнює
'==='      // строга рівність (перевіряється як значення, так і тип)
'!=='      // строга нерівність (перевіряє як значення, так і тип)
```

- ***Рядкові оператори*** використовуються для маніпулювання рядками. Найпоширенішим рядковим оператором є оператор
  конкатенації (+), який використовується для об'єднання двох або більше рядків. Наприклад:

```javascript
let str1 = "Hello";
let str2 = "world!";
let str3 = str1 + " " + str2; // "Hello world!"
```

- ***Арифметичні оператори*** використовуються для виконання математичних обчислень. Деякі з найпоширеніших арифметичних
  операторів у JavaScript включають:

```javascript
'+'        // додавання
'-'        // віднімання
'*'        // множення
'/'        // ділення
'%'        // модуль (повертає залишок після ділення)
'++'       // інкремент
'--'       // декремент
```

- ***Бітові оператори*** використовуються для виконання побітових операцій над двійковими числами. Ці оператори працюють
  шляхом перетворення чисел у двійковий формат, а потім виконують операцію над кожним бітом. Деякі з найпоширеніших
  бітових операторів у JavaScript включають:

```javascript
'&'        // Встановлює кожен біт в 1, якщо обидва біти дорівнюють 1
'|'        // Встановлює кожен біт в 1, якщо один з двох бітів дорівнює 1
'^'        // Встановлює кожен біт в 1, якщо тільки один з двох бітів дорівнює 1
'~'        // Інвертує всі біти
'<<'       // Зсувається вліво, проштовхуючи нулі праворуч і дозволяючи крайнім лівим бітам відпадати
'>>'       // Зсувається вправо, проштовхуючи копії крайніх лівих бітів зліва, і залишаючи крайні праві біти падати
'>>>'      // Зсувається вправо, проштовхуючи нулі зліва, і дозволяє крайнім правим бітам відпадати
```

Важливо зазначити, що JavaScript має певний порядок пріоритету операторів, який визначає порядок їх обчислення у виразі.

### 29.Опишіть призначення і принципи роботи з колекціями Map і Set.

Колекції ***Map*** і ***Set*** в JavaScript використовуються для зберігання та маніпулювання даними у структурований спосіб. Обидві
колекції з'явилися в ES6 і надають більше функціональності, ніж традиційні масиви.

Метою використання колекції ***Map*** є зберігання пар ключ-значення, де і ключі, і значення можуть бути будь-якого типу. Map
надає можливість легко отримувати доступ до даних, додавати та видаляти їх за ключем. Деякі з принципів роботи з Map:
включають:

- Ключі можуть бути будь-якого типу: На відміну від традиційних об'єктів, де ключі перетворюються на рядки, мапи
дозволяють використовувати ключі будь-якого типу, включаючи об'єкти, функції та примітиви.

- Пошук за ключем: До значень в Map можна отримати доступ за відповідними ключами, що полегшує пошук значень за певними
ключами.

- Ітерація: Записи в Map можна перебирати або за допомогою циклу for...of, або за допомогою вбудованого методу forEach()
мапи.

Ось приклад використання Map:

```javascript
const myMap = new Map();
const key1 = { name: 'John' };
const key2 = { name: 'Jane' };
myMap.set(key1, 'value1');
myMap.set(key2, 'value2');

console.log(myMap.get(key1)); // output: "value1"

myMap.forEach((value, key) => {
  console.log(key, value); // output: { name: 'John' } "value1" 
                          //         { name: 'Jane' } "value2"
});
```

Метою використання колекції ***Set*** є зберігання колекції унікальних значень. Множина гарантує, що жодні два елементи в
колекції не є рівними один одному. Деякі з принципів роботи з колекцією Set включають:

- Унікальні значення: Set можуть містити лише унікальні значення, тобто повторювані значення автоматично видаляються.

- Без індексу: На відміну від масивів, Set не мають індексу. Натомість вони надають спосіб перевірити, чи присутнє
певне значення в колекції.

- Ітерація: Елементи в Set можна перебирати за допомогою циклу for...of або вбудованого методу forEach().

Ось приклад використання Set:

```javascript
const mySet = new Set();
mySet.add('apple');
mySet.add('banana');
mySet.add('apple'); // This value will not be added to the Set
console.log(mySet.has('banana')); // output: true

mySet.forEach(value => {
  console.log(value); // output: "apple", "banana"
});
```

### 30.Що означає глибока (deep) та поверхнева (shallow) копія об’єкта? Як зробити кожну з них?

У JavaScript об'єкти зберігаються та передаються за посиланням. Коли ви присвоюєте об'єкт змінній або передаєте його як
аргумент функції, ви насправді передаєте посилання на цей об'єкт, а не його копію. Іноді це може призвести до
неочікуваної поведінки, особливо коли ви працюєте зі складними об'єктами, які містять вкладені об'єкти або масиви.

Для створення копії об'єкта можна використовувати або ***поверхневу копію***, або ***глибоку копію***. Різниця між цими двома типами
копій полягає в тому, наскільки глибоко вони копіюють оригінальний об'єкт.

- ***Поверхнева (shallow) копія*** створює новий об'єкт, який посилається на ті самі вкладені об'єкти, що й оригінальний об'єкт. Іншими
словами, дублюється об'єкт верхнього рівня, але не дублюються вкладені об'єкти або масиви. Для створення неглибокої
копії в JavaScript можна використовувати оператор ***spread (...)*** або метод ***Object.assign()***. Ось приклад використання
оператора spread:

```javascript
const originalObject = {a: 1, b: {c: 2}};
const shallowCopy = {...originalObject};
```

У цьому прикладі shallowCopy - це новий об'єкт, який має ті самі властивості, що й originalObject, але на вкладений
об'єкт b все ще посилаються обидва об'єкти.

- ***Глибока (deep) копія***, з іншого боку, створює новий об'єкт з тими самими властивостями і значеннями, що й
  оригінальний об'єкт, включаючи будь-які вкладені об'єкти або масиви. Щоб створити глибоку копію в JavaScript, ви
  можете використовувати методи JSON.parse() і JSON.stringify(). Ось приклад:

```javascript
const originalObject = {a: 1, b: {c: 2}};
const deepCopy = JSON.parse(JSON.stringify(originalObject));
```

У цьому прикладі deepCopy є абсолютно новим об'єктом з тими самими властивостями й значеннями, що й originalObject,
включно з вкладеним об'єктом b.

### 31.З якою метою може бути використаний event listener події fetch self.addEventListener(’fetch’, event => {}) ?

***Event listener події fetch*** може використовуватися в ***service worker*** для перехоплення мережевих запитів, зроблених
веб-сторінкою. Коли сторінка робить запит на ресурс, наприклад, зображення або скрипт, ***service worker*** може
перехопити запит і відповісти на нього власною відповіддю або змінити запит до того, як він потрапить на сервер.

***Event listener події fetch*** також може використовуватися для реалізації стратегій кешування, наприклад, кешування ресурсів
у кеш-пам'яті браузера або отримання ресурсів з віддаленого сервера або локального кешу на основі певних критеріїв.

Крім того, ***event listener події fetch*** можна використовувати для обробки офлайн-сценаріїв, відповідаючи на запити кешованими
ресурсами, коли мережа недоступна.

Загалом, він надає потужний механізм для контролю мережевих запитів і відповідей, і може бути
використаний для реалізації широкого спектра розширених можливостей у веб-додатках, таких як автономна робота,
оптимізація продуктивності й підвищення безпеки.

### 32.Що таке Event loop і як він працює? Розкажіть про мікрозадачі та макрозадачі.

***Event loop*** - це механізм, який використовується JavaScript для обробки асинхронних операцій. Він працює шляхом
безперервної перевірки черги повідомлень на наявність нових подій і виконання їх по черзі, виходячи з їх пріоритету і
контексту виконання. Під асинхронним мається на увазі частину коду, яку ви хочете виконати пізніше. Деякі приклади
асинхронних функцій: setTimeout, callbacks, promises, обробка подій, мережеві запити тощо… JavaScript
використовує цикл подій для обробки всіх цих типів асинхронних завдань за допомогою одного потоку.

***Event loop*** включає: ***call stack***, ***мікрозадачі*** та ***макрозадачі***.

- ***Call stack*** — це стек останній прийшов, перший вийшов. Це місце, куди додається завдання з
  черги макро- або мікро-завдань. Важливо зауважити, що функції додаються до стека викликів у порядку їх виклику. Це
  означає, що функція, додана останньою, завжди виконується першою та першою видаляється зі стеку.

- ***Мікрозадачі*** виконуються одразу після завершення поточного завдання, але до того, як буде оброблено наступне
  макрозавдання. Прикладами мікрозадач є обіцянки та спостерігачі мутацій. Деякі приклади мікрозавдань: 
  - Promise
  - process.nextTick()
  - queueMicrotask()

- ***Макрозадачі*** виконуються на початку наступної ітерації циклу подій. Прикладами макрозадач є встановлення
таймауту, встановлення інтервалу та операції вводу/виводу. Деякі приклади макрозавдань: 
  - setTimeout()
  - setImmediate()
  - setInterval()
  - UI rendering

Коли спрацьовує подія, наприклад, користувач натискає кнопку або API-виклик повертає дані, вона додається до черги
повідомлень як мікрозадача або макрозадача. Після цього цикл обробки подій почне обробляти завдання з черги повідомлень,
починаючи з завдання з найвищим пріоритетом. Коли всі завдання з однаковим пріоритетом будуть завершені, цикл перейде до
наступного рівня пріоритету.

Цей механізм дозволяє JavaScript обробляти декілька завдань одночасно, не блокуючи основний потік. Він також гарантує,
що завдання виконуються в правильному порядку, виходячи з їх пріоритету і поточного контексту виконання.

### 33.Які типи даних бувають у JavaScript? Який буде результат виконання коду?

***Типи даних знаходяться вище у пункті 15 цього файлу***.

```js
let firstObj = {name: 'Hello'};

let secondObj = firstObj;

firstObj = {name: 'Bye'};

console.log(secondObj.name);
```

Результатом роботи цього коду буде ***"Hello"***.

На початку коду створюється змінна firstObj, яка ініціалізується об'єктом, що містить ім'я властивості зі значенням 
"Hello". Потім створюється змінна secondObj, яка ініціалізується значенням firstObj.

Далі створюється новий об'єкт з іменем властивості зі значенням 'Bye', і змінна firstObj перепризначається цьому новому
об'єкту. Однак змінна secondObj все ще вказує на початковий об'єкт з іменем 'Hello'.

### 34.Що таке temporal dead zone?

***Temporal dead zone*** (TDZ) - це поведінка, яка виникає при спробі отримати доступ до змінної до того, як
вона буде оголошена з let або const.

В ECMAScript 6 (ES6), коли змінна оголошується за допомогою let або const, вона стає доступною тільки після оператора її
оголошення. Змінна вважається такою, що перебуває в TDZ від початку блоку, в якому вона оголошена, до моменту досягнення
фактичного оператора оголошення. Під час TDZ будь-яка спроба отримати доступ до змінної призводить до виникнення помилки
посилання (ReferenceError).

Наприклад, розглянемо наступний фрагмент коду:

```javascript
console.log(a); // ReferenceError: a is not defined
let a = 10;
```

У цьому коді оператор console.log намагається отримати доступ до змінної ***a*** до того, як вона буде оголошена за допомогою
let. Це призводить до виникнення ***ReferenceError***, оскільки змінна ***a*** все ще знаходиться в TDZ.

### 35.Як працює boxing / unboxing у JavaScript?

#### - AutoBoxing

***Boxing*** - це процес, в якому примітивне значення обгортається в об'єкт. Коли примітивний тип обробляється як об'єкт,
наприклад, при виклику функції toUpperCase(), JavaScript автоматично обертає примітивний тип у відповідний об'єктний
тип. Цей новий об'єктний тип потім зв'язується з відповідним вбудованим <.prototype>, тому ви можете використовувати
методи прототипу для примітивних типів.

```javascript
//String primitive name
const name = "CODINGNINJA";
console.log(name.toLowerCase());
console.log(name.substring(1));

// Output:
// codingninja
// ODINGNINJA
```

З наведеного вище прикладу ми бачимо, що коли ми намагаємося використати метод на примітивному типі, JavaScript
автоматично виконує ***boxing***, тобто обертає цей примітивний тип в об'єктний тип. Цей autoboxing дозволяє нам використовувати
різні методи об'єкта String.

#### - Ручний Boxing

Як бачимо, autoboxing досить простий у реалізації, але він також має певні проблеми. Зазвичай не варто безпосередньо
використовувати обгортку об'єктів, оскільки іноді це призводить до зовсім неочікуваних результатів.

```javascript
// 3 прапорці, але всі "true". Незважаючи на те, що ми дали "false"
let flag1 = new Boolean(true)
if(flag1) { 
    console.log("inside flag1")
}
let flag2 = new Boolean(false)
if(!flag2) {
    console.log("inside flag2");
}
let flag3 = Object(false)
if(!flag3) {
    console.log("inside flag3");
}

// Output:
// Inside flag1
```

Отже, проблема цієї програми полягає в тому, що ми намагаємося створити обгортку об'єкта навколо хибного значення, але є
заковика: об'єкти мають істинне значення. Отже, у цьому випадку нам доведеться використовувати valueOf() для обгортки
примітивного типу даних.

```javascript
const b = Boolean(false)
if(!b.valueOf()) {
   console.log("its false");
}

// Output:
// it's false
```

Як бачимо, такий підхід є досить вигідним у наведеному вище випадку. Але краще використовувати неявний boxing, оскільки
так оптимізуються браузери. Крім того, при ручному підході код стає повільнішим.
Отже, зазвичай краще використовувати об'єктний тип даних замість примітивного.

#### - Unboxing

***Unboxing*** - це перетворення типів посилань або об'єктів у базові або примітивні типи даних. Це протилежність
boxing або packing. Одним з найпростіших способів перетворення обгортки об'єкта у відповідний примітивний тип даних є
використання методу valueOf().

```javascript
let flag1 = Object(false);
console.log(flag1 == false)
console.log(flag1 === false)
console.log(flag1.valueOf() == false)
console.log(flag1.valueOf() === false)

// Output:
// true
// false
// true
// true
```

***Boxing*** та ***Unboxing*** є важливими і регулярно використовуваними практиками. Але в різних мовах або різних
реалізаціях обгортка може споживати більше пам'яті і займати більше часу для виконання коду, ніж примітивні типи. Але,
якщо ми говоримо про високорівневі структури даних, то обгортки дуже корисні. Це також підвищує гнучкість вашого коду.
Переважно ми використовуємо boxing неявно, тому що механізми браузерів оптимізовані.

### 36.У чому різниця між оператором in і методом hasOwnProperty?

У JavaScript, оператор ***in*** і метод ***hasOwnProperty*** використовуються для перевірки наявності властивостей в
об'єктах.

- ***in***:

Цей оператор дозволяє перевірити, чи існує вказана властивість в об'єкті або в його прототипі.

Синтаксис:
```javascript
property_name in object
```
Приклад:
```javascript
const myObject = { key1: 'value1', key2: 'value2' };

console.log('key1' in myObject); // true
console.log('key3' in myObject); // false
```

Як видно з прикладу, оператор ***in*** повертає true, якщо властивість key1 знаходиться в об'єкті myObject, і false, якщо
властивість key3 не існує в об'єкті.

Важливо зазначити, що оператор ***in*** також буде повертати true, якщо властивість з таким ім'ям існує у прототипі об'єкта:
```javascript
const parentObject = { parentProp: 'value' };
const childObject = Object.create(parentObject);
childObject.childProp = 'value';

console.log('childProp' in childObject); // true
console.log('parentProp' in childObject); // true (успадкована властивість)
```

- ***hasOwnProperty:***

Цей метод перевіряє, чи існує властивість безпосередньо в даному об'єкті, і не перевіряє, чи існує властивість у його прототипі.

Синтаксис:
```javascript
object.hasOwnProperty(property_name)
```
Приклад:
```javascript
const myObject = { key1: 'value1', key2: 'value2' };

console.log(myObject.hasOwnProperty('key1')); // true
console.log(myObject.hasOwnProperty('key3')); // false
```

У прикладі метод ***hasOwnProperty*** повертає true, лише якщо властивість key1 належить самому об'єкту myObject, і false,
якщо властивість key3 відсутня.

Прототип об'єкта не має методу hasOwnProperty, тому цей метод буде доступний тільки для екземплярів об'єктів.

Отже, використання оператора ***in*** дозволяє перевірити існування властивості як в об'єкті, так і в його прототипі,
тоді як метод ***hasOwnProperty*** дозволяє перевірити тільки існування властивості безпосередньо в об'єкті.

### 37.Опишіть, за допомогою чого в JS реалізуються такі ООП-парадигми, як інкапсуляція, поліморфізм, абстракція?

- ***Інкапсуляція***:

Вона дозволяє об'єднати дані та методи, які з ними пов'язані, в один об'єкт, таким чином приховуючи деталі
реалізації від користувача. Це забезпечує захист даних і забезпечує можливість змінювати внутрішню реалізацію об'єкту
без впливу на зовнішній код.

У JavaScript для ***інкапсуляції*** можна використовувати замикання. Замикання дозволяють створювати функції, які
мають доступ до змінних з свого зовнішнього контексту, але ці змінні не доступні ззовні. Ось приклад, як можна
реалізувати інкапсуляцію в JavaScript:

```javascript
function createCounter() {
  let count = 0;

  return {
    increment: function() {
      count++;
    },

    decrement: function() {
      count--;
    },

    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment();
counter.increment();
console.log(counter.getCount()); // Виведе 2
```

У цьому прикладі, змінна count прихована від зовнішнього світу, але можна звертатись до неї через методи об'єкта, що
повертається з createCounter.

- ***Поліморфізм***:

Він дозволяє об'єднати об'єкти з різною поведінкою під одним інтерфейсом. В JavaScript поліморфізм досягається
шляхом використання поліморфних функцій та методів.

Існують два типи поліморфізму: ***статичний*** (компіляційний) та ***динамічний*** (виконавчий).

***Статичний поліморфізм*** реалізується за допомогою перевантаження функцій чи методів з різною кількістю аргументів або
типами аргументів. В JavaScript такий вид поліморфізму не є нативним.

***Динамічний поліморфізм*** в JavaScript досягається завдяки механізму виклику методів об'єктів. Коли викликається метод на
об'єкті, JavaScript автоматично визначає, який саме метод має бути викликаний на основі типу об'єкта.

```javascript
class Animal {
  speak() {
    console.log("Animal makes a sound");
  }
}

class Dog extends Animal {
  speak() {
    console.log("Dog barks");
  }
}

class Cat extends Animal {
  speak() {
    console.log("Cat meows");
  }
}

function animalSound(animal) {
  animal.speak();
}

const dog = new Dog();
const cat = new Cat();

animalSound(dog); // Виведе "Dog barks"
animalSound(cat); // Виведе "Cat meows"
```

- ***Абстракція***:

Вона дозволяє приховати непотрібні деталі реалізації, представляючи лише необхідний функціонал для взаємодії. У
JavaScript абстракцію можна досягнути за допомогою класів та інтерфейсів.

```javascript
// Абстрактний клас
class Shape {
  calculateArea() {
    throw new Error("Method 'calculateArea' must be implemented.");
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  calculateArea() {
    return Math.PI * this.radius * this.radius;
  }
}

const circle = new Circle(5);
console.log(circle.calculateArea()); // Виведе площу кола
```

В прикладі, Shape - це абстрактний клас, який має абстрактний метод calculateArea. Клас Circle успадковується від Shape
і реалізує метод calculateArea, тим самим надаючи необхідний функціонал для взаємодії.

### 38.Що таке прототип? Як працює прототипне наслідування в JS? Поясніть роботу коду.

```js
function Main() {
}

Main.prototype = {protected: true};

const obj = new Main();
Main.prototype = {protected: false};

console.log('Object protection: ', obj.protected); 
```

***Прототип*** - це ключовий механізм у JavaScript, що дозволяє об'єктам успадковувати властивості та методи від інших
об'єктів. Кожен об'єкт в JavaScript має свій прототип, який використовується для пошуку властивостей та методів, які не
знайдено безпосередньо в об'єкті.

***Прототипне наслідування*** працює наступним чином:

1. Об'єкти мають властивість prototype, яка посилається на інший об'єкт (прототип). Цей прототип виступає як "батьківський"
об'єкт, властивості та методи якого можуть успадковуватись.

2. Коли потрібно звернутись до властивості або методу об'єкта, JavaScript спочатку перевіряє сам об'єкт. Якщо властивість
не знайдена, він звертається до прототипу об'єкта та шукає там.

3. Цей процес продовжується по ланцюжку прототипів, поки не знайдеться властивість або буде досягнуто кінця ланцюжка
прототипів (зазвичай null).

#### - Робота коду вище:

1. Визначення функції Main:
```javascript
function Main() {
}
```
2. Зміна прототипу Main:
```javascript
Main.prototype = {protected: true};
```

Цей рядок коду встановлює прототип об'єкта Main на новий об'єкт *{protected: true}*. Тепер всі об'єкти, створені через
*new Main()*, успадковуватимуть властивість protected, яка має значення true.

3. Створення об'єкта obj на основі функції Main:
```javascript
const obj = new Main();
```

Тут ми створюємо новий об'єкт *obj*, викликаючи функцію *Main* через оператор *new*. Оскільки ми встановили прототип Main на
об'єкт *{protected: true}*, тепер obj успадковує властивість protected і має значення true.

4. Зміна прототипу Main після створення об'єкта obj:
```javascript
Main.prototype = {protected: false};
```

Тут ми змінюємо прототип Main на новий об'єкт *{protected: false}*. ***Однак ця зміна прототипу не впливає на вже створені
об'єкти***, такі як obj. Вона впливає лише на об'єкти, які будуть створені пізніше через new Main().

5. Виведення значення властивості protected об'єкта obj:
```javascript
console.log('Object protection: ', obj.protected);
```

Тут ми виводимо значення властивості protected об'єкта obj. Оскільки ми змінили прототип після створення об'єкта obj,
його прототип залишився *{protected: true}*, і властивість protected також має значення true. ***Зміна прототипу після
створення об'єкта не впливає на вже існуючі об'єкти***, тільки на об'єкти, які будуть створені пізніше.

***Результат***:
```javascript
// Object protection: true
```

### 39.Яка різниця між композицією та наслідуванням?

У JavaScript, ***композиція*** та ***наслідування*** - це два різні підходи до створення класів та їх взаємодії. Обидва ці підходи
використовуються для реюзу коду та створення ієрархії класів, але вони мають різні принципи та підходи.

- ***Наслідування*** в JavaScript - це процес, за допомогою якого клас отримує властивості та методи іншого класу. В класичному
наслідуванні один клас (підклас) успадковує властивості та методи батьківського класу (базового класу). Це зазвичай
реалізується за допомогою прототипного наслідування.

У прикладі, клас *Dog* успадковує властивості та метод *makeSound()* від класу *Animal*:
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  makeSound() {
    console.log("Animal makes a sound");
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name);
  }

  makeSound() {
    console.log("Dog barks");
  }
}

const dog = new Dog("Buddy");
dog.makeSound(); // Output: "Dog barks"
```

- ***Композиція*** - це процес створення об'єктів, які складаються з інших об'єктів, а не успадковують їх. В замість
  наслідування, клас складається з об'єктів інших класів (або просто об'єктів). Це означає, що в композиції об'єкт
  містить в собі інші об'єкти, які надають необхідну функціональність.

У прикладі, клас *Car* містить об'єкт *Engine*, і здатен викликати його метод *start()* в рамках свого власного методу
*start()*:
```javascript
class Engine {
  start() {
    console.log("Engine starts");
  }
}

class Car {
  constructor(name) {
    this.name = name;
    this.engine = new Engine();
  }

  start() {
    console.log(`${this.name} starts`);
    this.engine.start();
  }
}

const myCar = new Car("Toyota");
myCar.start();
// Output:
// "Toyota starts"
// "Engine starts"
```

Загалом, ***наслідування*** є механізмом створення ієрархії класів, в той час як ***композиція*** дозволяє створювати класи, які
містять в собі об'єкти інших класів, і таким чином дозволяє побудувати складніші структури та забезпечити більш гнучку
архітектуру програми. Обидва підходи мають свої переваги та недоліки, тому вибір між ними залежить від конкретних потреб
проекту.

### 40. Чому не варто використовувати конструктори типу new String?

В JavaScript, конструктор типу ***new String*** може використовуватись для створення об'єктів, що представляють рядки. Однак
його використання не рекомендується через кілька причин:

1. *Незмінність рядків*: Об'єкти, створені з використанням конструктора new String, є мутабельними (змінними). Це означає,
   що вони можуть змінюватися після створення. В JavaScript рядки є незмінними (immutable) – це означає, що вони не
   можуть бути змінені після створення. 

Наприклад:
```javascript
const str = new String("Hello");
str[0] = "h"; // Це не працюватиме, рядки незмінні
```

Використання конструктора new String може спричинити плутанину та неочікувану поведінку через різницю між мутабельними
об'єктами і незмінними рядками.

2. *Відмінність від примітивних рядків*: Коли ви створюєте рядки з конструктором new String, ви отримуєте об'єкт, а не
   примітивний рядок. Це може призвести до несподіваних результатів, коли ви намагаєтесь виконати рядкові операції. 

Наприклад:
```javascript
const str1 = "Hello";
const str2 = new String("Hello");

console.log(typeof str1); // "string"
console.log(typeof str2); // "object"
```

3. *Порівняння рядків*: При порівнянні рядків, створених з конструктором new String, виникають деякі нюанси через різницю
   між об'єктами та примітивами. Це може призвести до неочікуваних результатів порівняння. 

Наприклад:
```javascript
const str1 = "Hello";
const str2 = new String("Hello");

console.log(str1 === "Hello");   // true
console.log(str2 === "Hello");   // false
console.log(str2 == "Hello");    // true
```

Отже, використання простих рядкових літералів (наприклад, "Hello") є більш зручним та більш поширеним підходом для роботи з
рядками в JavaScript. Ці літерали автоматично створюють примітивні рядки, які підтримують звичайні рядкові операції і
мають очікувану поведінку.

### 41.Розкажіть про базовий пристрій і механізм роботи Event loop.

Цей механізм дозволяє JavaScript взаємодіяти з подіями та виконувати асинхронні операції без блокування основного потоку
виконання.

1. ***Базовий пристрій*** (event loop):
   JavaScript використовує базовий пристрій для керування потоками виконання. Він дозволяє забезпечити асинхронність і
   обробку подій у JavaScript. Цей пристрій може бути реалізований в різних середовищах виконання, таких як веб-браузер
   або Node.js, але його основний принцип роботи однаковий.

2. ***Механізм роботи*** Event loop ґрунтується на принципі асинхронності та подій. Коли JavaScript має виконати асинхронну
   операцію, таку як завантаження даних з сервера або таймаут, вона не блокує основний потік виконання. Замість цього,
   виконується реєстрація функції-зворотного виклику (callback), яка буде виконана пізніше, коли асинхронна операція
   завершиться.

Основний цикл роботи Event loop складається з кількох етапів:

- ***Очікування подій*** (Wait for events): JavaScript очікує на події або завершення асинхронних операцій, таких як таймаути,
  завантаження даних або взаємодія з користувачем.

- ***Обробка подій*** (Process events): Коли стає доступною нова подія або завершується асинхронна операція, виконується
відповідний функціонал, який був зареєстрований для цієї події.

- ***Виконання коду*** (Execute code): Якщо немає асинхронних операцій або подій для обробки, Event loop перевіряє стек викликів
і виконує наступну функцію у черзі.

- ***Повторення циклу***: Цикл роботи Event loop постійно повторюється, що дозволяє JavaScript ефективно обробляти асинхронний
код та реагувати на події.

Цей механізм дозволяє JavaScript виконувати складні операції без заблокування основного потоку, що є критичним для
створення ефективних додатків.

Приклад коду з асинхронним виконанням в JavaScript:
```javascript
console.log('Start');

// Асинхронна функція з таймаутом
setTimeout(function() {
  console.log('Async operation complete');
}, 2000);

console.log('End');
```

Результат:
```javascript
// Start
// End
// Async operation complete
```

Асинхронна операція (таймаут) була зареєстрована, а JavaScript продовжив виконувати наступний код без
очікування завершення асинхронної функції. Пізніше, коли таймер закінчився, відповідна функція-зворотний виклик
виконалась («Async operation complete»).

### 42. Що таке записи (records) і кортежі (tuples)? Чим вони відрізняються від звичайних об’єктів?

***Записи*** та ***кортежі*** — це майбутня функція для Javascript, яка може бути знайома, якщо ви користуєтеся іншими мовами. Вони
дуже схожі на *Arrays* та *Objects*, ключовою відмінністю є те, що вони незмінні, тобто їх не можна оновлювати чи змінювати.
Вони дають нам абсолютно новий примітивний тип у Javascript і дозволяють нам робити багато речей, які ми раніше не могли
робити, зокрема порівнювати об’єкти та масиви за значенням, а не за ідентичністю.

#### - Підтримка записів і кортежів

Наразі ***записи*** та ***кортежі*** є пропозицією другого етапу для Javascript. Загалом це означає, що вони відносно стабільні, але
не реалізовані як стандартні специфікації. Таким чином, основні ***браузери*** та ***серверний Javascript***, як-от Node.JS, ***не
реалізують їх***. Однак ви можете використовувати їх, якщо у вас є *Babel*.

#### - Що таке записи та кортежі в JS?

***Records*** та ***Tuples*** вводять абсолютно новий примітивний тип у Javascript, але в кінцевому підсумку дотримуються того
самого синтаксису, що й *Objects* та *Arrays*. Коли ми хочемо визначити нове Record або Tuple, ми використовуємо синтаксис
#{} або #[]. Таким чином, ми можемо визначити обидва, як показано в коді нижче:

```javascript
let myRecord = #{
    name: "New Record",
    tags: #['some', 'tags', 'go', 'here']
}

let myTuple = #['some', 'other', 'set', 'of', 'array', 'items'];
```

Синтаксис ідентичний до об’єктів і масивів, за винятком хеша (#) на початку. Ми також можемо
поставити a Tuple у наш Record, як показано в першому прикладі.

#### - Записи та кортежі незмінні

***Записи*** та ***кортежі*** в Javascript глибоко незмінні. Їх неможливо змінити на жодному рівні. Якщо ви
спробуєте їх змінити, ви отримаєте повідомлення про помилку:

```javascript
let myRecord = #{
    name: "New Record",
    tags: #['some', 'tags', 'go', 'here']
}
        
myRecord.name = 'Another Record'; // This will throw an error
```

Ви не можете вставити в них щось нове. Таким чином, вони діють як джерело правди, що підводить нас
до їх основного варіанту використання. І ***Tuples***, і ***Records*** ***дозволяють нам порівнювати об’єкти та масиви на основі їх
значення, а не їх ідентичності***.

#### - Записи та кортежі порівнюють значення, а не ідентичність

Це може заплутати, але це тому, що рівність об’єктів і масивів працює на основі ідентичності. Коли ми визначаємо новий
об’єкт або масив, йому надається унікальна ідентичність. Таким чином, при порівнянні ідентичності двох різних об’єктів
результатом є *false*:

```javascript
console.log({ a: 1 } === { a: 1 }) // returns false
console.log([1, 2, 3] === [1, 2, 3]) // returns false
```

Записи та кортежі порушують цю умову та дозволяють порівнювати за значенням. Deep comparisons об’єктів було чимось досить
складним у Javascript протягом тривалого часу, але з кортежами та записами ми нарешті можемо це зробити. Таким чином,
наступний код повертає true:

```javascript
console.log(#{ a: { b : 3 }} === #{ a: { b : 3 }}) // return true
console.log(#[1, 2, 3] === #[1, 2, 3]) // returns true
```

#### - Перетворення масивів на кортежі та об’єктів на записи в Javascript

Оскільки ***записи*** та ***кортежі*** порівнюються за значенням, ви можете перетворити звичайні об’єкти та масиви в них, щоб ви
могли зробити таке порівняння. Ми можемо перетворити будь-який об’єкт або масив у запис або кортеж за
допомогою ***Record()*** та ***Tuple()***:

```javascript
let newRecord = Record({ a: 1, b: 2 });
let newTuple = Tuple(...[1, 2, 3, 4, 5]);
let anotherTuple = Tuple.from([1, 2, 3, 4, 5]);
```

Обидва наведені вище рядки створять версії ***Record*** і ***Tuple*** кожного. Майбутні пропозиції також включають
JSON.parseImmutable функцію, яка дозволить нам перетворювати рядки масивів або об’єктів безпосередньо у форму кортежу чи
запису. Наразі це не реалізовано.

#### - Додавання до кортежу або запису

Ви не можете додати або змінити кортеж/запис, але ви можете створити новий кортеж або
запис на основі старого. Це буде зовсім інший кортеж/запис, але він використовуватиме старі дані та додаватиме щось
нове. Ми можемо зробити це, як показано нижче:

```javascript
let myTuple = #[1, 2, 3, 4, 5];
let myRecord = #{ a: 1, b: 1 };

// Produce a new record using original myRecord:
let newRecord = #{ ...myRecord, c: 1 } // #{ a: 1, b: 1, c: 1}
// Produce a new tuple using myTuple:
let newTuple = #[ ...myTuple, 6, 7];
// Or you can use Tuple.with():
let anotherTuple = myTuple.with(6, 7);
```

#### - Взаємодія з кортежами та записами в Javascript

***Кортежі*** та ***записи*** працюють так само як об’єкти та масиви, за винятком того, що їх неможливо змінити. Таким чином, ви
можете перебирати їх або взаємодіяти з ними за допомогою тих самих методів, які доступні для об’єктів і масивів.

Наприклад, ми можемо отримати всі ключі певного запису:
```javascript
let myRecord = #{ a: 1, b: 2, c: 2};
let recordKeys = Object.keys(myRecord); // Returns ['a', 'b', 'c'];
```

Виконати ітерацію по масиву за допомогою циклу for:
```javascript
let myTuple = #[1, 2, 3, 4, 5];
for(const i of myTuple) {
    console.log(i);
}

// Console logs 1, 2, 3, 4, 5 on after each other
```

### 43.Які відмінності в поведінці ES5 функції-конструктора та ES2015 класу?

***ES5 функція-конструктор*** та ***ES2015*** (також відомий як ES6) ***клас*** є двома різними способами визначення об'єктів і поведінки
в JavaScript. 

Відмінності між ними:

1. Синтаксис:

- ***ES5: Функція-конструктор*** визначається звичайною функцією, і об'єкти створюються за допомогою ключового слова new.
- ***ES2015: Клас*** оголошується за допомогою ключового слова class. Це новий синтаксис для визначення класів в JavaScript, що робить код більш зрозумілим та чистим.

2. Конструктор:

- ***ES5: У функції-конструкторі***, спеціальна властивість this використовується для створення властивостей об'єкту.
- ***ES2015: Класи*** мають спеціальний метод під назвою constructor, який викликається при створенні нового об'єкту. Властивості об'єкту також визначаються в тілі класу, а не у конструкторі.

3. Методи:

- ***ES5: Методи об'єкту*** визначаються як окремі функції за межами функції-конструктора, і їм передається доступ до this.
- ***ES2015: Методи класу*** просто визначаються як функції всередині тіла класу, і вони також отримують доступ до this.

4. Наслідування:

- ***У ES5*** створення спадкоємців вимагає використання прототипного наслідування. Можна використовувати функцію Object.create() або модифікувати прототипи.
- ***У ES2015*** надано синтаксис класів для спадкування за допомогою ключового слова extends. Для спадкування класу необхідно вказати батьківський клас за допомогою extends, а потім викликати конструктор батьківського класу з допомогою super().

5. Статичні методи:

- ***ES5***: Функціональний підхід у ES5 не має прямої підтримки статичних методів (методів класу, а не екземпляра).
- ***ES2015***: У класах ES2015 можна визначати статичні методи за допомогою ключового слова static.

Нижче приклади ***ES5 функції-конструктора*** і ***ES2015 класу*** для створення об'єкту:

#### - ES5 функція-конструктор:

```javascript
function PersonES5(name, age) {
  this.name = name;
  this.age = age;
}

PersonES5.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

var person1 = new PersonES5('John', 30);
person1.sayHello();
```

#### - ES2015 клас:

```javascript
class PersonES2015 {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
}

const person2 = new PersonES2015('Alice', 25);
person2.sayHello();
```

***Обидва підходи роблять практично те саме, просто мають різний синтаксис***. Використання класів спрощує створення об'єктів
і зробить ваш код більш читабельним та легким для розуміння.

### 44.Як реалізувати патерн «Модуль»?

***Патерн «Модуль»*** у JavaScript дозволяє створювати ізольовані області видимості для змінних та функцій, щоб уникнути
конфліктів імен і забезпечити кращий контроль над простором імен. Це допомагає організувати код в логічні блоки і
зробити його більш підтримуваним та повторно використовуваним.

Є декілька способів реалізації ***патерна «Модуль»*** у JavaScript. Одним із найпоширеніших є використання замикань:

```javascript
// Модульний патерн з використанням замикань
const myModule = (function () {
  // Приватні змінні і функції
  let privateVariable = 'Я приватна змінна';

  function privateFunction() {
    console.log('Я приватна функція');
  }

  // Публічний інтерфейс (об'єкт, який містить публічні методи та властивості)
  return {
    publicVariable: 'Я публічна змінна',
    publicFunction: function () {
      console.log('Я публічна функція');
    },
  };
})();

// Використання модуля:
console.log(myModule.publicVariable); // Виведе: "Я публічна змінна"
myModule.publicFunction(); // Виведе: "Я публічна функція"

// Помилка, так як приватні змінні і функції недоступні ззовні модуля:
console.log(myModule.privateVariable); // Виведе: "undefined"
myModule.privateFunction(); // Виведе помилку: "myModule.privateFunction is not a function"
```

У цьому прикладі замикання допомагають створити замкнуту область видимості, що дозволяє зберігати приватні змінні і
функції, які не доступні ззовні модуля. Всі публічні методи та властивості повертаються в об'єкті, який і стає публічним
інтерфейсом модуля.

### 45. Чому typeof null повертає object?

Історично виникло так, що в JavaScript оператор *typeof* повертає *"object"* для значення *null*. Причина цього знаходиться у
самій ранній версії JavaScript і викликана проблемами з якістю реалізації мови.

У початковому варіанті JavaScript, наприклад, який виник у 1995 році, дане значення відповідало 4 бітам, які містили
інформацію про те, що перед нами об'єкт, число, рядок, булевий тип, або щось інше. На жаль, з цієї реалізації вийшла
певна помилка.

Коли виникла помилка, розробники JavaScript уже не могли змінити значення для null, тому що це могло б вплинути на
наявний код. Натомість було вирішено залишити цю помилку у стандарті, щоб забезпечити зворотну сумісність.

Таким чином, *typeof null* повертає *"object"* і досі, хоча це може здатися дещо дивним. ***Якщо вам потрібно перевірити, чи
змінна містить саме null, рекомендується замість typeof використовувати строгу перевірку ===:***

```javascript
let value = null;
if (value === null) {
  // Виконати щось, якщо value дійсно містить null
}
```

### 46.Що таке приведення (перетворення) типів у JS?

У JavaScript ***приведення типів*** (також відоме як перетворення типів або типізація) ***використовується для зміни типу даних з
одного типу на інший***. У JavaScript, змінні можуть містити дані різних типів, таких як числа, рядки, об'єкти, булеві
значення і т.д. Під час операцій або порівнянь, якщо типи даних різняться, JavaScript автоматично перетворює один тип на
інший, щоб виконати операцію.

***Існує два типи приведення типів*** у JavaScript:

1. ***Явне приведення типів (явна типізація)***: Ви самостійно змінюєте тип даних, використовуючи певний метод або функцію.

Приклад явного приведення типів:
```javascript
let numString = "42";
let num = Number(numString); // Явне перетворення рядка на число
console.log(num); // Виведе 42 (число), а не "42" (рядок)
```

2. ***Неявне приведення типів (неявна типізація)***: JavaScript автоматично перетворює типи даних в процесі виконання
   операцій.
   
Приклад неявного приведення типів:
```javascript
let x = 5; // x є числовим значенням (number)
let y = "10"; // y є рядковим значенням (string)
let result = x + y; // JavaScript неявно перетворить x у рядок і здійснить конкатенацію рядків
console.log(result); // Виведе "510" (рядок), а не 15 (число)
```

Неявне приведення типів може бути корисним, але деякі ситуації можуть стати джерелом помилок, якщо не розуміти, які типи
даних будуть автоматично перетворені, тому вам потрібон писати більш чіткий і прозорий код, щоб уникати небажаних помилок і
керувати поведінкою програми.

### 47.Що таке явне і неявне приведення (перетворення) типів даних у JS? Як відбувається перетворення типів у таких прикладах:

```js
{
}
+[] + {} + [1]
!!"false" == !!"true"
    ['x'] == 'x'
```

1. ***Явне приведення типів (явна типізація)***: Ви самостійно змінюєте тип даних, використовуючи певний метод або функцію.

Приклад явного приведення типів:
```javascript
let numString = "42";
let num = Number(numString); // Явне перетворення рядка на число
console.log(num); // Виведе 42 (число), а не "42" (рядок)
```

2. ***Неявне приведення типів (неявна типізація)***: JavaScript автоматично перетворює типи даних в процесі виконання
   операцій.

Приклад неявного приведення типів:
```javascript
let x = 5; // x є числовим значенням (number)
let y = "10"; // y є рядковим значенням (string)
let result = x + y; // JavaScript неявно перетворить x у рядок і здійснить конкатенацію рядків
console.log(result); // Виведе "510" (рядок), а не 15 (число)
```

Неявне приведення типів може бути корисним, але деякі ситуації можуть стати джерелом помилок, якщо не розуміти, які типи
даних будуть автоматично перетворені, тому вам потрібно писати більш чіткий і прозорий код, щоб уникати небажаних помилок і
керувати поведінкою програми.

```javascript
{} + [] + {} + [1]
```

В цьому прикладі є послідовність додавань різних даних. Пам'ятайте, що оператор додавання + має різне поведінка в
залежності від операндів. Зазвичай він виконує арифметичне додавання, але якщо один із операндів є рядком, JavaScript
вважає його конкатенацією рядків.

- 1.1. ***{} + []*** - Вираз {} трактується як блок коду, а [] - порожній масив. У цьому випадку JavaScript вирішує застосувати
арифметичне додавання, але порожній масив конвертується в пустий рядок. Таким чином, вираз виконається
як ***"[object Object]" + ""***, і результат буде ***"[object Object]"***.

- 1.2. ***{} + {}*** - Обидва вирази {} трактуються як блоки коду, і JavaScript не буде виконувати арифметичне додавання через
відсутність числових значень. Таким чином, це буде трактуватися як звичайна конкатенація рядків, і результат
буде ***"[object Object][object Object]"***.

- 1.3. ***{} + [1]*** - Аналогічно, {} трактується як блок коду, а [1] - масив із числовим значенням 1. Як і раніше, арифметичне
додавання не відбудеться, і буде виконано конкатенація рядків. Результатом буде ***"[object Object][object Object]1"***.

Отже, весь вираз "{} + [] + {} + [1]" перетвориться в ***"[object Object][object Object]1"***.

```javascript
!!"false" == !!"true"
```

- 2.1. ***!!"false"*** - Тут подвійний оператор заперечення (!!) використовується для перетворення рядка "false" на булеве
значення false. Значення потім знову заперечується, і результатом буде true.

- 2.2. ***!!"true"*** - Так само, рядок "true" перетворюється на булеве значення true за допомогою подвійного оператора
заперечення.

- 2.3. ***Порівняння ==*** - Обидва булеві значення порівнюються. У JavaScript порівняння за допомогою == перетворює операнди на
спільний тип, якщо вони мають різні типи даних. У даному випадку обидва операнди вже є булевими, тому жодне додаткове
приведення типів не відбувається. Порівняння true == true буде правдивим.

```javascript
['x'] == 'x'
```

- 3.1. ***['x']*** - Це масив із одним елементом, рядком "x".

- 3.2. ***'x'*** - Це рядок "x".

При виконанні порівнянь у JavaScript, масив буде автоматично перетворений у рядок за допомогою приведення типів.
Тому, ['x'] перетвориться у рядок "x", і порівняння "x" == "x" буде правдивим. Результат true.


Результати всіх прикладів:
```javascript
{} + [] + {} + [1] - "[object Object][object Object]1";
!!"false" == !!"true" - true;
['x'] == 'x' - true;
```

### 48.Що таке Garbage Collector?

Управління пам'яттю в JavaScript виконується автоматично і непомітно для нас. Ми створюємо примітиви, об’єкти, функції…
Усе це потребує пам’яті.

Коли щось більше не потрібне в пам’яті - існує механізм ***Garbage Collector (вивіз сміття)*** JavaScript, який виявляє це та очищає.

Основною концепцією керування пам’яттю в JavaScript є ***доступність***.

***«Досяжні» значення*** — це ті, які доступні або якимось чином можна використовувати. Вони гарантовано
зберігаються в пам'яті.

1. Існує базовий набір природно досяжних значень, які неможливо видалити зі зрозумілих причин.

Наприклад:

- Функція, що виконується в даний момент, її локальні змінні та параметри.
- Інші функції в поточному ланцюжку вкладених викликів, їх локальні змінні та параметри.
- Глобальні змінні.
- (є й інші, внутрішні)
Ці величини називаються коренями.

2. Будь-яке інше значення вважається досяжним, якщо воно доступне з кореня за посиланням або ланцюжком посилань.

Наприклад, якщо в глобальній змінній є об’єкт, і цей об’єкт має властивість, що посилається на інший об’єкт, цей об’єкт
вважається доступним. І ті, на які він посилається, також доступні. Докладні приклади для наслідування.

#### - У механізмі JavaScript існує фоновий процес, який називається ***збирачем сміття***.
Він стежить за всіма об'єктами і видаляє ті, які стали недоступними.

***Головне, що потрібно знати:***

- Вивіз сміття здійснюється автоматично. Ми не можемо цього змусити чи запобігти.
- Об'єкти зберігаються в пам'яті, поки вони доступні.

Приклад:
```javascript
let user = {
  name: "John"
};
```

Глобальна змінна *"user"* посилається на об’єкт *{name: "John"}*. Властивість *"name"* 
Джона зберігає примітив, тому він намальований всередині об'єкта.

Якщо значення user перезаписано, посилання втрачається:
```javascript
user = null;
```

Тепер Джон стає недоступним. Немає жодного способу доступу до нього, жодних посилань на нього. ***Збирач сміття*** видалить
дані та звільнить пам’ять.

Приклад:
```javascript
let user = {
  name: "John"
};

let admin = user;
```

Тепер, якщо ми зробимо те саме:
```javascript
user = null;
```

Тоді об’єкт все ще доступний через *admin* глобальну змінну, тому він повинен залишатися в пам’яті. Якщо ми *admin* теж
перезапишемо, його можна буде видалити.

### 49.Опишіть основні принципи роботи «збирача сміття» у JS-рушіях (engines).

У JavaScript існує процес ***збирання сміття (garbage collection)***, який ***відповідає за автоматичне визначення та видалення
непотрібних об'єктів з пам'яті***. Це допомагає уникнути витоків пам'яті та забезпечити ефективне використання ресурсів.
Основним принципом роботи ***збирача сміття*** у JavaScript-рушіях є використання механізму автоматичного визначення
об'єктів, які вже не використовуються і видалення їх з пам'яті.

***Основні принципи роботи збирача сміття:***

1. ***Автоматичне визначення недосяжних об'єктів***: "Збирач сміття" визначає, які об'єкти в програмі є недосяжними, тобто
неможливо досягти з поточного контексту виконання. Якщо об'єкт недосяжний (не має посилань на нього), він вважається
підлягаючим видаленню.

2. ***Маркування та детектор об'єктів***: Існує кілька алгоритмів "збирання сміття", але найпоширеніший - це алгоритм маркування
та детектор об'єктів. Процес маркування починається з кореневих об'єктів, які можна досягти безпосередньо з коду (
наприклад, глобальні змінні, стек викликів та замикання). Після маркування всі досяжні об'єкти помічаються. Потім
проходить фаза збирання, під час якої "збирач сміття" видаляє недосяжні об'єкти.

3. ***Цикличні посилання***: Під час роботи "збирача сміття" можуть виникати проблеми з циклічними посиланнями, коли об'єкти
посилаються один на одного взаємно, але ні один із них не може бути досягнутий з кореневих об'єктів. Для розв'язання
цієї проблеми використовуються різні методи, такі як алгоритм Strong Reference Counting.

4. ***Асинхронність***: В деяких реалізаціях "збирач сміття" може працювати асинхронно. Збірка сміття може запускатися на іншому
потоці або у фоновому режимі для зменшення впливу на продуктивність основного процесу.

### 50.Опишіть призначення і принципи роботи з колекціями WeakMap і WeakSet? Чим вони відрізняються від колекцій Map і Set відповідно?

***Колекції WeakMap і WeakSet*** є частинами стандарту *ECMAScript 6 (ES6)* і представляють особливі типи колекцій в мові
JavaScript. ***Основна відмінність*** між WeakMap/WeakSet і Map/Set полягає в тому, ***як вони використовують пам'ять та
управляють посиланнями на об'єкти***.

#### 1. WeakMap:
Призначення: WeakMap дозволяє зберігати пари "ключ-значення", де ключем може бути тільки об'єкт, а значенням — будь-що.
Відмінність від Map полягає в тому, що якщо ключем є об'єкт, який більше не має активних посилань на нього з іншого
коду, то він автоматично видаляється з WeakMap, звільняючи тим самим пам'ять.

***Принцип роботи:***

- Колекція WeakMap може містити тільки об'єкти як ключі.
- Ключі WeakMap зберігаються як "слабкі" посилання. Це означає, що коли немає активного посилання на ключ (тобто ключ
більше не використовується в іншому коді), Garbage Collector (збирач сміття) автоматично видаляє цей ключ і пов'язане з
ним значення з WeakMap, якщо в іншому місці в коді вже немає посилань на це значення.
- Оскільки колекція WeakMap оптимізована для роботи з об'єктами, вона не підтримує ітерацію (наприклад, методи keys(),
values(), entries()), і, отже, не має розміру (властивість size).

#### 2. WeakSet:

Призначення: WeakSet є колекцією унікальних об'єктів, де кожний об'єкт може бути доданий тільки один раз. Знову ж таки,
якщо жоден інший код не містить активних посилань на об'єкт, він автоматично видаляється з WeakSet і звільняється
пам'ять.

***Принцип роботи:***

- Колекція WeakSet приймає тільки об'єкти як значення.
- Об'єкти, додані до WeakSet, також зберігаються як "слабкі" посилання. Якщо немає активних посилань на об'єкт з іншого
коду, то Garbage Collector видаляє цей об'єкт з колекції.
- WeakSet також не має ітераторів і розміру.

Основна відмінність між Map і WeakMap, а також між Set і WeakSet, полягає в управлінні пам'яттю. Колекції WeakMap і
WeakSet дозволяють автоматично звільняти пам'ять, коли вони більше не використовуються, забезпечуючи автоматичне
видалення об'єктів, які вже не мають активних посилань. Це зручно для ситуацій, де необхідно уникнути витоків пам'яті і
автоматично очищувати колекції, коли об'єкти в них більше не потрібні. Однак, через цю особливість, вони також мають
деякі обмеження у функціональності порівняно з Map і Set.

### 51.Чим відрізняється Observable від Promise?

#### - Promise

***Promise*** обробляє одну подію, коли асинхронна операція завершується або не вдається.

Примітка: Існують ***Promise*** бібліотеки, які підтримують скасування, але ES6 ***Promise*** на цей час не підтримує цю
функцію.

#### - Observable

***Observable*** (Спостереження) схоже на потік (stream) (у багатьох мовах програмування) і дозволяє передавати нуль або
більше подій, де зворотний виклик (callback) викликається для кожної події.

Часто ***Observable*** вважається більш привабливим порівняно з ***Promise***, оскільки воно надає
функціональні можливості ***Promise-ів*** і навіть більше. За допомогою ***Observable*** не має значення, чи потрібно
обробити 0, 1 чи декілька подій. Ви можете використовувати одне й те ж API в кожному випадку.

Також ***Observable*** має перевагу над ***Promise***, оскільки його можна *скасувати*. Якщо результат
запиту *HTTP* до сервера або іншої дорогоцінної асинхронної операції більше не потрібен, можна скасувати підписку на 
***Observable***, тоді як ***Promise*** все одно викличе зворотний виклик успіху або невдачі, навіть коли
вам вже не потрібне повідомлення або результат, який воно надає.

Поки ***Promise*** починається відразу, ***Observable*** починається тільки після підписки на нього. Тому
***Observable*** називають ***лінивими*** (lazy).

***Observable*** забезпечує оператори, такі як map, forEach, reduce, ... схожі на масив.

Також є потужні оператори, такі як retry(), or replay(), ... які часто дуже зручні.

***Promise є простішим та більш підходящим для простих асинхронних операцій, тоді як Observable дозволяє більшу
гнучкість для роботи з потоками даних та послідовностями подій.***

### 52. Що таке Promise? Назвіть порядок виконання then і catch у ланцюжку.

```js
Promise.resolve(10)
    .then(e => console.log(e)) // ??
    .then(e => Promise.resolve(e))
    .then(console.log) // ??
    .then(e => {
        if (!e) {
            throw 'Error caught';
        }
    })
    .catch(e => {
        console.log(e); // ??
        return new Error('New error');
    })
    .then(e => {
        console.log(e.message); // ??
    })
    .catch(e => {
        console.log(e.message); // ??
    });
```

У JavaScript, ***Promise*** є об'єктом, що представляє результат асинхронної операції. Використання ***Promise***
дозволяє зручно працювати з асинхронними операціями, такими як завантаження файлів, зчитування даних з
бази даних, тощо.

- Основна ідея ***Promise*** полягає в тому, що вона може перебувати у трьох станах:

1. ***Pending*** (очікування): Початковий стан, коли обіцянка ще не виконалась і результат ще не отриманий.

2. ***Fulfilled*** (виконано): Обіцянка виконалась успішно, і містить результат операції.

3. ***Rejected*** (відхилено): Обіцянка не виконалась через якусь помилку, і містить інформацію про відхилення.

Синтаксис створення нової Promise:
```javascript
const myPromise = new Promise((resolve, reject) => {
  // Виконання асинхронної операції
  // Якщо операція успішна, викликаємо resolve з результатом
  // Якщо операція не вдалась, викликаємо reject з помилкою
});
```

Для обробки результатів асинхронних операцій, використовуються методи ***.then()*** та ***.catch()***, які дозволяють визначити, що
робити після успішного виконання або в разі відхилення:
```javascript
myPromise
  .then((result) => {
    // Робимо щось з результатом, якщо Promise виконався успішно
  })
  .catch((error) => {
    // Обробляємо помилку, якщо Promise був відхилений
  });
```

Багатоасинхронні операції можна поєднувати разом, використовуючи метод ***.then()*** для послідовного виконання, або метод
***Promise.all()*** для паралельного виконання декількох ***Promise***.

#### Порядок виконання then і catch у ланцюжку:

- Promise.resolve(10) створює Promise, який негайно вирішується зі значенням 10. Потім перший отримує це значення і
записує його в консоль (console.log(e)). Таким чином, він виводить 10.

- Другий then отримує значення з попереднього then (яке дорівнює 10), але повертає новий Promise, створений
Promise.resolve(e), де *e* дорівнює 10. Однак у цьому then немає console.log, тому він виводить на консоль невизначене
значення.

- Третій then отримує значення з попереднього then (який є невизначеним) і виводить його у консоль. Таким чином, він
виводить невизначене.

- Четвертий then має умовний оператор if (!e), але оскільки він отримує значення undefined, то умова виконується, і він
виводить рядок 'Error caught'.

- Елемент управління перенаправляється на блок catch, який виводить у консоль повідомлення "Виникла помилка".

- У блоці catch ми повертаємо новий ***Promise*** new Error('New error'), яка буде відхилена з об'єктом помилки, що містить
повідомлення 'New error'.

- Наступний блок отримає об'єкт помилки, але замість того, щоб записати весь об'єкт, він запише лише властивість
повідомлення помилки, а саме 'New error'.

- Останній блок перехоплення також отримує об'єкт помилки і записує його властивість повідомлення, а саме 'New error'.

Результат:
```javascript
// 10
// undefined
// Error caught
// New error
```

### 53.Розкажіть про послідовне і паралельне виконання асинхронних функцій. У чому різниця між Promise.all () і Promise.allSettled ()?

В JavaScript асинхронні функції можуть бути виконані послідовно або паралельно, залежно від того, як ви реалізуєте їх в
коді.

1. При ***послідовному виконанні асинхронних функцій*** кожна наступна функція починає своє виконання лише після того, як
попередня завершила свою роботу. Це може бути досягнуто, наприклад, за допомогою async/await або через ланцюжок .then()
у виразі Promise.

Приклад послідовного виконання асинхронних функцій з використанням async/await:
```javascript
async function sequentialExecution() {
  try {
    const result1 = await asyncFunction1();
    const result2 = await asyncFunction2();
    const result3 = await asyncFunction3();

    // Використовуйте результати відповідних функцій тут
  } catch (error) {
    console.error("An error occurred:", error);
  }
}
```

2. При ***паралельному виконанні асинхронних функцій*** декілька функцій можуть почати своє виконання одночасно, і ви чекаєте,
поки всі вони завершаться. Для паралельного виконання можна використовувати *Promise.all()*, який приймає масив промісів і
повертає новий проміс, який вирішиться, коли всі проміси з масиву будуть виконані, або якщо будь-який з них відхилиться.

Приклад паралельного виконання асинхронних функцій з використанням Promise.all():
```javascript
async function parallelExecution() {
  try {
    const [result1, result2, result3] = await Promise.all([
      asyncFunction1(),
      asyncFunction2(),
      asyncFunction3(),
    ]);

    // Використовуйте результати відповідних функцій тут
  } catch (error) {
    console.error("An error occurred:", error);
  }
}
```

Тепер щодо ***різниці між Promise.all() і Promise.allSettled()***:

- ***Promise.all()*** очікує на виконання всіх переданих промісів, і як тільки всі вони вирішаться (або якщо хоча б один з них
відхилиться), повертає проміс, який вирішиться або відхилиться відповідно. Якщо хоча б один з переданих промісів
відхиляється, повернений проміс також відхиляється з помилкою.

- ***Promise.allSettled()*** також очікує на виконання всіх переданих промісів, але повертає проміс, який вирішиться тільки
після того, як всі передані проміси завершаться, незалежно від того, чи вони виконались успішно чи відхилились.
Результатом буде масив об'єктів, де кожен об'єкт представляє результат промісу і містить властивості "status" (успішне
виконання або відхилення) і "value" (значення виконання або причина відхилення).

Приклад використання ***Promise.allSettled()***:
```javascript
async function allSettledExample() {
  try {
    const results = await Promise.allSettled([
      asyncFunction1(),
      asyncFunction2(),
      asyncFunction3(),
    ]);

    // results міститиме масив об'єктів зі статусами і значеннями
    results.forEach((result) => {
      if (result.status === "fulfilled") {
        console.log("Resolved:", result.value);
      } else {
        console.log("Rejected:", result.reason);
      }
    });
  } catch (error) {
    console.error("An error occurred:", error);
  }
}
```

Отже, ***Promise.all() буде відхилятись при
першій помилці, тоді як Promise.allSettled() дозволить вам обробити всі результати, навіть якщо деякі проміси відхилені.***

### 54.Що таке дескриптори властивостей об’єктів? Розкажіть про їхнє практичне застосування.

### 55.Назвіть кілька способів створення незмінного об’єкта в JavaScript.

### 56.Як створити властивість в об’єкта, яку не можна буде змінити?

### 57.Навіщо потрібен конструктор Proxy? Наведіть приклад використання.

### 58.Що таке ArrayBuffer? У чому різниця між Uint32Array і Float32Array? Який результат виконання коду?

```js
const uint32Array = new Uint32Array();
Array.isArray(uint32Array);
```

### 59.Яким буде результат порівняння?

```js
const url = "HTTPs://xyz.com/path<to>page.html";
encodeURI(url) == encodeURIComponent(url);
```

### 60.Розкажіть про генератори та ітератори.

### 61.Поясніть, що робить наведений код:

```js
function* fn(num) {
    for (let i = 0; i < num; i += 1) {
        yield console.log(i);
    }
}

const loop = fn(5);
loop.next();
loop.next();
```

### 62.Розкажіть про тип даних Symbol і його практичне застосування. Як перевести число з 10-розрядної системи в 16(2,8)-розрядну систему числення?

8.Реалізація патерну Class Free OOP (HTTPs://observablehq.com/@bratter/class-free-oop).
9.Патерн async disposer (HTTPs://advancedweb.hu/what-is-the-async-disposer-pattern-in-javascript).
10.Використання регулярних виразів. Коли прийнятно / неприйнятно? Як вони працюють? Як можна зробити читабельним код?
