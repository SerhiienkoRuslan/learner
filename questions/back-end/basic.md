<details>
<summary>1. Що таке REPL?</summary>

**REPL** - це скорочення від **"Read-Eval-Print Loop"**, що означає "Цикл читання-оцінки-виведення". Це інтерактивне середовище програмування, яке дозволяє вам вводити команди (чи код) на мові програмування, виконувати їх, отримувати результат і повторювати процес знову і знову.

У REPL немає необхідності компілювати програму перед запуском, тому що він відразу виконує код після кожної команди, що дозволяє швидко експериментувати з кодом і тестувати різні ідеї.

Більшість сучасних мов програмування мають REPL, такі як Python, Ruby, JavaScript, Lisp, і багато інших. Використання REPL є корисним для швидкого тестування і налагодження коду, вивчення мов програмування, та для виконання швидких обчислень або операцій.
</details>

<details>
<summary>2. Що таке streams в Node.js?</summary>

**Streams** в Node.js - це інтерфейс, який дозволяє читати або записувати дані з джерела чи призначення по частинам (chunks), а не повністю.

Це особливо корисно для обробки великих файлів, які не можуть бути завантажені в пам'ять одночасно. Замість цього, дані читаються або записуються частинами, що дозволяє обробляти їх швидко та ефективно.

У Node.js існує декілька типів стрімів, таких як Readable, Writable, Duplex та Transform. Кожен з них виконує свою функцію, наприклад, Readable стрім може бути використаний для читання даних, тоді як Writable стрім може бути використаний для запису даних.

Стріми можуть бути підключені до інших стрімів, що дозволяє забезпечувати обробку даних з джерела до призначення в найбільш оптимальний спосіб. Наприклад, читання даних з одного стріму та запис даних до іншого стріму можуть бути об'єднані в один конвеєр, який оброблює дані при пересиланні їх від одного стріму до іншого.
</details>
<details>
<summary>3. Що таке middleware?</summary>

**Middleware** - це програмне забезпечення, яке функціонує як проміжний шар між різними компонентами програмного забезпечення, такими як веб-додатки, фреймворки або сервери.

У контексті веб-розробки, middleware - це функція, яка виконується перед тим, як запит буде переданий до кінцевого обробника (handler) запиту. Ці функції можуть бути використані для різних задач, таких як перевірка авторизації, обробка запитів форм, логування тощо.

Middleware можна ланцюгувати, тобто виконувати послідовність middleware-функцій перед передачею запиту до кінцевого обробника. Під час виконання ланцюга middleware-функцій, кожна функція може змінювати об'єкт запиту та відповіді перед їх передачею до наступної middleware-функції в ланцюгу.

**Middleware** - це потужний інструмент, який дозволяє додавати різноманітну логіку до вашого веб-додатку або фреймворку, розбивати її на частини і повторно використовувати. Вона дозволяє розширювати функціональність вашого програмного забезпечення та збільшувати його стійкість та надійність.
</details>

<details>

<summary>4. Для чого використовують функцію setImmediate?</summary>

Функція `setImmediate` використовується в Node.js для запуску функції, коли цикл подій (event loop) вільний для виконання нових завдань.

Коли функція передається в `setImmediate`, вона виконується в наступному циклі подій, після того, як поточний цикл подій буде завершений, і будь-які інші функції, які зареєстровані на цей час, будуть виконані.

Це може бути корисно для виконання функцій, які мають великий обсяг розрахунків або інтенсивні операції введення/виведення (I/O), тому що виконання їх безпосередньо в циклі подій може призвести до блокування циклу подій і зменшення продуктивності вашого додатку.

Крім того, використання `setImmediate` дозволяє вам створювати "м'які" таймери, які виконуються як тільки цикл подій стає вільним. Це дозволяє вам керувати часом виконання вашого коду, зменшуючи затримки, які можуть виникнути при використанні інших методів таймерів.

Отже, setImmediate є потужним інструментом для керування часом виконання функцій в Node.js, що дозволяє підвищити продуктивність вашого додатку та зменшити затримки.

</details>

<details>
<summary>5. Навіщо потрібен app.param() в express?</summary>

`app.param()` в Express - це метод, який дозволяє обробляти спільні параметри запитів (common request parameters) на рівні додатку. Використання `app.param()` дозволяє спростити код, зменшити дублювання та зберегти час на обробці параметрів у кожному маршруті окремо.

Коли параметр вказується в маршруті з використанням двокрапки `:` (наприклад, `/users/:userId`), його значення можна отримати в функції-обробнику (handler function) через об'єкт запиту (`req.params.userId`). Якщо потрібно здійснити певну обробку з параметром перед тим, як він буде переданий функції-обробнику, то можна використовувати `app.param()`.

`app.param()` дозволяє зареєструвати функцію-обробник, яка буде виконуватися для певного параметра у всіх маршрутах, які використовують цей параметр. Функція-обробник приймає три параметри: назву параметра, функцію-обробник та наступну функцію (next), яку потрібно викликати для продовження обробки запиту. Функція-обробник може змінювати значення параметра, валідувати його або взагалі його відкидати.

Наприклад, якщо в додатку використовується `:userId` як параметр в багатьох маршрутах, можна використати `app.param()` для збереження коду та зменшення дублювання.

```jsx
app.param('userId', (req, res, next, userId) => {
  User.findById(userId, (err, user) => {
    if (err) return next(err);
    if (!user) return next(new Error('User not found'));
    req.user = user;
    next();
  });
});

app.get('/users/:userId', (req, res) => {
  res.send(`User ${req.user.name} found`);
});

app.put('/users/:userId', (req, res) => {
  req.user.name = req.body.name;
  req.user.save((err) => {
    if (err) return next(err);
    res.send(`User ${req.user.name} updated`);
  });
});
```

В цьому прикладі `app.param()` використовується для отримання об'єкта користувача (`req.user`) за його ідентифікатором (`userId`) і додавання його до об'єкту запиту. Це дозволяє забезпечити наявність об'єкта користувача в об'єкті запиту для всіх маршрутів, які використовують цей параметр.

У цьому прикладі `app.get()` та `app.put()` маршрути отримують доступ до об'єкта користувача через `req.user`, який був доданий в функції-обробнику `app.param()`.

Отже, `app.param()` дозволяє забезпечити єдину обробку параметрів запитів на рівні додатку, що дозволяє зменшити дублювання коду, полегшити обробку помилок та збільшити ефективність додатку.

</details>

<details>
<summary>6. Що таке token based authentication?</summary>

**Token-based authentication** - це метод аутентифікації, що базується на використанні токенів для підтвердження ідентифікації користувача.

Зазвичай, при вході користувача до системи йому видається токен (token), який зберігається на його стороні (наприклад, у вигляді cookie або local storage в браузері) та надсилається з кожним запитом до сервера. Сервер може перевірити токен, щоб переконатися, що запит відправляється від користувача, який має дійсний токен, і авторизувати запит.

Токен зазвичай містить інформацію про користувача та додаткові дані, такі як термін дії, обмеження прав доступу тощо. Якщо токен знайдено не дійсним або він має прострочений термін дії, сервер може відхилити запит.

Існують різні методи створення токенів, наприклад, JWT (JSON Web Tokens) та OAuth (Open Authorization). JWT є одним з найпопулярніших методів, що використовуються в багатьох веб-додатках для створення токенів.

</details>

<details>
    <summary>7. Чому Node.js однопотоковий, а не багатопотоковий?</summary>

Node.js є однопотоковою платформою з подієвим циклом обробки подій (event-driven), а не багатопотоковою платформою, як багато інших серверних технологій, таких як Apache або Nginx.

Це пов'язано з тим, що Node.js зосереджений на високопродуктивному введенні/виведенні (I/O) та операціях мережі, які часто є блокуючими для інших мов програмування. Замість створення багатьох потоків, які займають багато пам'яті та збільшують складність кодування та відлагодження, Node.js використовує один потік з циклом подій, щоб ефективно обробляти запити та реагувати на події, коли вони виникають.

Це дає можливість Node.js досягати високої продуктивності та ефективно використовувати ресурси сервера, що особливо важливо в інтенсивних мережевих додатках з великою кількістю паралельних підключень. В той же час, Node.js дозволяє розширювати можливості за допомогою модулів, таких як `cluster`, що дозволяють запускати декілька процесів Node.js на різних ядрах процесора, тим самим забезпечуючи паралельне виконання коду та збільшуючи потужність обчислень.

</details>

<details>
<summary>8. Що таке event driven development?</summary>

**Event-driven development** (EDD) - це методологія розробки програмного забезпечення, в якій функціонування додатку базується на подіях, що відбуваються в системі або взаємодії з користувачем.

У традиційному процесі розробки програмного забезпечення, програма виконує послідовне виконання кожної операції і чекає на завершення кожної дії, перш ніж переходити до наступної. У EDD, програма реагує на події, що відбуваються в системі, тобто вона не чекає на завершення дій, а відразу реагує на подію, що її викликала.

Для реалізації EDD використовуються подійні архітектури, які забезпечують взаємодію між об'єктами програми через відправку та отримання подій. Коли стається якась подія, система відправляє повідомлення про цю подію всім підписаним на неї об'єктам, що дозволяє вони реагувати на неї, виконуючи потрібну дію.

Event-driven development є популярним підходом в розробці веб-додатків та інших додатків, які взаємодіють з користувачем. Цей підхід дозволяє забезпечувати швидку відповідь на дії користувача та реагувати на зміни в системі в реальному часі. Node.js - це приклад технології, яка базується на EDD, тому що вона використовує подійну модель для обробки подій та відповіді на запити.

</details>

<details>
<summary>9. Порівняйте fork() та spawn() методи.</summary>

`fork()` та `spawn()` - це методи Node.js, які дозволяють запускати дочірні процеси в Node.js.

`fork()` використовується для створення нового процесу Node.js, який запускається як дочірній процес. Цей метод зазвичай використовується для створення багатопроцесових програм, де кожен процес може працювати зі своїми власними ресурсами, такими як пам'ять та файлова система. Кожен процес має свій власний об'єкт процесу, який забезпечує комунікацію між дочірнім та батьківським процесами.

`spawn()` використовується для запуску зовнішніх процесів, які можуть бути написані на будь-якій мові програмування. Цей метод дозволяє використовувати стандартні потоки введення-виведення (stdin, stdout, stderr) для взаємодії зі сторонніми процесами. За допомогою методу `spawn()` можна передавати аргументи виконання, налаштування та середовище виконання стороннього процесу.

Основна відмінність між `fork()` та `spawn()` полягає в тому, що `fork()` створює новий процес Node.js, тоді як `spawn()` запускає зовнішні процеси. Крім того, `spawn()` дозволяє передавати більше конфігураційних параметрів та аргументів, тоді як `fork()` дозволяє створювати нові процеси Node.js з максимальною зручністю для комунікації з батьківським процесом.

Отже, вибір методу залежить від конкретного випадку використання. Якщо вам потрібно запустити зовнішній процес, то ви можете використовувати метод `spawn()`, а якщо вам потрібно створити багатопоточну програму, то `fork()` може бути кращим варіантом.

</details>

<details>
<summary>10. Розкажіть про Node.js фреймворки, які використовували. Яка між ними різниця?</summary>

Node.js - це платформа для розробки серверних додатків на JavaScript. Одним з переваг Node.js є те, що він має велику кількість фреймворків для розробки веб-додатків. В цьому відповіді я розкажу про деякі фреймворки, які я використовував і про їх відмінності.

1. Express.js - це найбільш популярний фреймворк для розробки веб-додатків на Node.js. Він має велику кількість розширень, що дозволяє легко розширювати його функціональність. Один з його недоліків полягає в тому, що він не має вбудованої підтримки для виконання деяких операцій, таких як автентифікація та авторизація.

2. Koa.js - це фреймворк, який створений на базі Express.js, але має більш простий та зручний синтаксис. Він дозволяє легко створювати middleware та дозволяє підключати розширення.

3. Hapi.js - це фреймворк, який має вбудовану підтримку для автентифікації та авторизації, а також забезпечує зручний інтерфейс для роботи зі статичними файлами. Hapi.js є готовим до використання фреймворком, що дозволяє зосередитися на бізнес-логіці веб-додатка, а не на технічних деталях.

4. Nest.js - це фреймворк, який створений на базі TypeScript і має вбудовану підтримку для Dependency Injection (DI). Він дозволяє легко розширювати функціональність та робити код більш читабельним.

Ці фреймворки мають різні особливості та підходи до розробки веб-додатків на Node.js. Вибір фреймворку залежить від ва

</details>

<details>
<summary>11. Опишіть словами код ендпоїнта, який повинен зберегти з клієнта файл розміром 4 гігабайти і покласти його на S3 або інший CDN.</summary>

</details>

<details>
<summary>12. Що таке мікросервіси, навіщо їх використовують?</summary>

</details>

<details>
<summary>13. У яких випадках ви б обрали моноліт, а в яких — мікросервіси?</summary>

</details>

<details>
<summary>14. Як зрозуміти, що застосунок у певний момент працює справно?</summary>

</details>

<details>
<summary>15. Як зрозуміти, що застосунок за останні три дні працював справно?</summary>

</details>

<details>
<summary>16. Як відбувається перевірка правильності паролю при використанні bcrypt?</summary>

</details>

<details>
<summary>17. Що таке JWT?</summary>

</details>

<details>
<summary>18. Джуніор надіслав код на рев’ю. Що тут не так? Як виправити?</summary>

```js
router.post ( '/ users', async (req, res, next) => {
    const user = await db.createUser (req);
    
    if (user) {
      return res.json (users);
    }
    
    res.json ({error: "can not create user"})
})
```


</details>

<details>
<summary>19. Порівняйте Common.js з AMD Modules та ES6 Imports.</summary>

</details>

<details>
<summary>20. Який фреймворк вибрали б для бекенду, чому?</summary>

</details>

<details>
<summary>21. Опишіть своїми словами, як працює OAuth v2.</summary>

</details>

<details>
<summary>22. Є проєкт з джерелами витоку пам’яті, як їх виявити, усунути та запобігти цьому в майбутньому?</summary>

</details>

<details>
<summary>23. Є проєкт з performance issues, як їх виявити, усунути та запобігти в майбутньому?</summary>

</details>

