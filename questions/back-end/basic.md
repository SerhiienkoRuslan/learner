<details>
<summary>1. Що таке REPL?</summary>

**REPL** - це скорочення від **"Read-Eval-Print Loop"**, що означає "Цикл читання-оцінки-виведення". Це інтерактивне середовище програмування, яке дозволяє вам вводити команди (чи код) на мові програмування, виконувати їх, отримувати результат і повторювати процес знову і знову.

У REPL немає необхідності компілювати програму перед запуском, тому що він відразу виконує код після кожної команди, що дозволяє швидко експериментувати з кодом і тестувати різні ідеї.

Більшість сучасних мов програмування мають REPL, такі як Python, Ruby, JavaScript, Lisp, і багато інших. Використання REPL є корисним для швидкого тестування і налагодження коду, вивчення мов програмування, та для виконання швидких обчислень або операцій.
</details>

<details>
<summary>2. Що таке streams в Node.js?</summary>

**Streams** в Node.js - це інтерфейс, який дозволяє читати або записувати дані з джерела чи призначення по частинам (chunks), а не повністю.

Це особливо корисно для обробки великих файлів, які не можуть бути завантажені в пам'ять одночасно. Замість цього, дані читаються або записуються частинами, що дозволяє обробляти їх швидко та ефективно.

У Node.js існує декілька типів стрімів, таких як Readable, Writable, Duplex та Transform. Кожен з них виконує свою функцію, наприклад, Readable стрім може бути використаний для читання даних, тоді як Writable стрім може бути використаний для запису даних.

Стріми можуть бути підключені до інших стрімів, що дозволяє забезпечувати обробку даних з джерела до призначення в найбільш оптимальний спосіб. Наприклад, читання даних з одного стріму та запис даних до іншого стріму можуть бути об'єднані в один конвеєр, який оброблює дані при пересиланні їх від одного стріму до іншого.
</details>
<details>
<summary>3. Що таке middleware?</summary>

**Middleware** - це програмне забезпечення, яке функціонує як проміжний шар між різними компонентами програмного забезпечення, такими як веб-додатки, фреймворки або сервери.

У контексті веб-розробки, middleware - це функція, яка виконується перед тим, як запит буде переданий до кінцевого обробника (handler) запиту. Ці функції можуть бути використані для різних задач, таких як перевірка авторизації, обробка запитів форм, логування тощо.

Middleware можна ланцюгувати, тобто виконувати послідовність middleware-функцій перед передачею запиту до кінцевого обробника. Під час виконання ланцюга middleware-функцій, кожна функція може змінювати об'єкт запиту та відповіді перед їх передачею до наступної middleware-функції в ланцюгу.

**Middleware** - це потужний інструмент, який дозволяє додавати різноманітну логіку до вашого веб-додатку або фреймворку, розбивати її на частини і повторно використовувати. Вона дозволяє розширювати функціональність вашого програмного забезпечення та збільшувати його стійкість та надійність.
</details>

<details>

<summary>4. Для чого використовують функцію setImmediate?</summary>

Функція `setImmediate` використовується в Node.js для запуску функції, коли цикл подій (event loop) вільний для виконання нових завдань.

Коли функція передається в `setImmediate`, вона виконується в наступному циклі подій, після того, як поточний цикл подій буде завершений, і будь-які інші функції, які зареєстровані на цей час, будуть виконані.

Це може бути корисно для виконання функцій, які мають великий обсяг розрахунків або інтенсивні операції введення/виведення (I/O), тому що виконання їх безпосередньо в циклі подій може призвести до блокування циклу подій і зменшення продуктивності вашого додатку.

Крім того, використання `setImmediate` дозволяє вам створювати "м'які" таймери, які виконуються як тільки цикл подій стає вільним. Це дозволяє вам керувати часом виконання вашого коду, зменшуючи затримки, які можуть виникнути при використанні інших методів таймерів.

Отже, setImmediate є потужним інструментом для керування часом виконання функцій в Node.js, що дозволяє підвищити продуктивність вашого додатку та зменшити затримки.

</details>

<details>
<summary>5. Навіщо потрібен app.param() в express?</summary>

`app.param()` в Express - це метод, який дозволяє обробляти спільні параметри запитів (common request parameters) на рівні додатку. Використання `app.param()` дозволяє спростити код, зменшити дублювання та зберегти час на обробці параметрів у кожному маршруті окремо.

Коли параметр вказується в маршруті з використанням двокрапки `:` (наприклад, `/users/:userId`), його значення можна отримати в функції-обробнику (handler function) через об'єкт запиту (`req.params.userId`). Якщо потрібно здійснити певну обробку з параметром перед тим, як він буде переданий функції-обробнику, то можна використовувати `app.param()`.

`app.param()` дозволяє зареєструвати функцію-обробник, яка буде виконуватися для певного параметра у всіх маршрутах, які використовують цей параметр. Функція-обробник приймає три параметри: назву параметра, функцію-обробник та наступну функцію (next), яку потрібно викликати для продовження обробки запиту. Функція-обробник може змінювати значення параметра, валідувати його або взагалі його відкидати.

Наприклад, якщо в додатку використовується `:userId` як параметр в багатьох маршрутах, можна використати `app.param()` для збереження коду та зменшення дублювання.

```jsx
app.param('userId', (req, res, next, userId) => {
  User.findById(userId, (err, user) => {
    if (err) return next(err);
    if (!user) return next(new Error('User not found'));
    req.user = user;
    next();
  });
});

app.get('/users/:userId', (req, res) => {
  res.send(`User ${req.user.name} found`);
});

app.put('/users/:userId', (req, res) => {
  req.user.name = req.body.name;
  req.user.save((err) => {
    if (err) return next(err);
    res.send(`User ${req.user.name} updated`);
  });
});
```

В цьому прикладі `app.param()` використовується для отримання об'єкта користувача (`req.user`) за його ідентифікатором (`userId`) і додавання його до об'єкту запиту. Це дозволяє забезпечити наявність об'єкта користувача в об'єкті запиту для всіх маршрутів, які використовують цей параметр.

У цьому прикладі `app.get()` та `app.put()` маршрути отримують доступ до об'єкта користувача через `req.user`, який був доданий в функції-обробнику `app.param()`.

Отже, `app.param()` дозволяє забезпечити єдину обробку параметрів запитів на рівні додатку, що дозволяє зменшити дублювання коду, полегшити обробку помилок та збільшити ефективність додатку.

</details>

<details>
<summary>6. Що таке token based authentication?</summary>

**Token-based authentication** - це метод аутентифікації, що базується на використанні токенів для підтвердження ідентифікації користувача.

Зазвичай, при вході користувача до системи йому видається токен (token), який зберігається на його стороні (наприклад, у вигляді cookie або local storage в браузері) та надсилається з кожним запитом до сервера. Сервер може перевірити токен, щоб переконатися, що запит відправляється від користувача, який має дійсний токен, і авторизувати запит.

Токен зазвичай містить інформацію про користувача та додаткові дані, такі як термін дії, обмеження прав доступу тощо. Якщо токен знайдено не дійсним або він має прострочений термін дії, сервер може відхилити запит.

Існують різні методи створення токенів, наприклад, JWT (JSON Web Tokens) та OAuth (Open Authorization). JWT є одним з найпопулярніших методів, що використовуються в багатьох веб-додатках для створення токенів.

</details>

<details>
    <summary>7. Чому Node.js однопотоковий, а не багатопотоковий?</summary>

Node.js є однопотоковою платформою з подієвим циклом обробки подій (event-driven), а не багатопотоковою платформою, як багато інших серверних технологій, таких як Apache або Nginx.

Це пов'язано з тим, що Node.js зосереджений на високопродуктивному введенні/виведенні (I/O) та операціях мережі, які часто є блокуючими для інших мов програмування. Замість створення багатьох потоків, які займають багато пам'яті та збільшують складність кодування та відлагодження, Node.js використовує один потік з циклом подій, щоб ефективно обробляти запити та реагувати на події, коли вони виникають.

Це дає можливість Node.js досягати високої продуктивності та ефективно використовувати ресурси сервера, що особливо важливо в інтенсивних мережевих додатках з великою кількістю паралельних підключень. В той же час, Node.js дозволяє розширювати можливості за допомогою модулів, таких як `cluster`, що дозволяють запускати декілька процесів Node.js на різних ядрах процесора, тим самим забезпечуючи паралельне виконання коду та збільшуючи потужність обчислень.

</details>

<details>
<summary>8. Що таке event driven development?</summary>

**Event-driven development** (EDD) - це методологія розробки програмного забезпечення, в якій функціонування додатку базується на подіях, що відбуваються в системі або взаємодії з користувачем.

У традиційному процесі розробки програмного забезпечення, програма виконує послідовне виконання кожної операції і чекає на завершення кожної дії, перш ніж переходити до наступної. У EDD, програма реагує на події, що відбуваються в системі, тобто вона не чекає на завершення дій, а відразу реагує на подію, що її викликала.

Для реалізації EDD використовуються подійні архітектури, які забезпечують взаємодію між об'єктами програми через відправку та отримання подій. Коли стається якась подія, система відправляє повідомлення про цю подію всім підписаним на неї об'єктам, що дозволяє вони реагувати на неї, виконуючи потрібну дію.

Event-driven development є популярним підходом в розробці веб-додатків та інших додатків, які взаємодіють з користувачем. Цей підхід дозволяє забезпечувати швидку відповідь на дії користувача та реагувати на зміни в системі в реальному часі. Node.js - це приклад технології, яка базується на EDD, тому що вона використовує подійну модель для обробки подій та відповіді на запити.

</details>

<details>
<summary>9. Порівняйте fork() та spawn() методи.</summary>

`fork()` та `spawn()` - це методи Node.js, які дозволяють запускати дочірні процеси в Node.js.

`fork()` використовується для створення нового процесу Node.js, який запускається як дочірній процес. Цей метод зазвичай використовується для створення багатопроцесових програм, де кожен процес може працювати зі своїми власними ресурсами, такими як пам'ять та файлова система. Кожен процес має свій власний об'єкт процесу, який забезпечує комунікацію між дочірнім та батьківським процесами.

`spawn()` використовується для запуску зовнішніх процесів, які можуть бути написані на будь-якій мові програмування. Цей метод дозволяє використовувати стандартні потоки введення-виведення (stdin, stdout, stderr) для взаємодії зі сторонніми процесами. За допомогою методу `spawn()` можна передавати аргументи виконання, налаштування та середовище виконання стороннього процесу.

Основна відмінність між `fork()` та `spawn()` полягає в тому, що `fork()` створює новий процес Node.js, тоді як `spawn()` запускає зовнішні процеси. Крім того, `spawn()` дозволяє передавати більше конфігураційних параметрів та аргументів, тоді як `fork()` дозволяє створювати нові процеси Node.js з максимальною зручністю для комунікації з батьківським процесом.

Отже, вибір методу залежить від конкретного випадку використання. Якщо вам потрібно запустити зовнішній процес, то ви можете використовувати метод `spawn()`, а якщо вам потрібно створити багатопоточну програму, то `fork()` може бути кращим варіантом.

</details>

<details>
<summary>10. Розкажіть про Node.js фреймворки, які використовували. Яка між ними різниця?</summary>

Node.js - це платформа для розробки серверних додатків на JavaScript. Одним з переваг Node.js є те, що він має велику кількість фреймворків для розробки веб-додатків. В цьому відповіді я розкажу про деякі фреймворки, які я використовував і про їх відмінності.

1. Express.js - це найбільш популярний фреймворк для розробки веб-додатків на Node.js. Він має велику кількість розширень, що дозволяє легко розширювати його функціональність. Один з його недоліків полягає в тому, що він не має вбудованої підтримки для виконання деяких операцій, таких як автентифікація та авторизація.

2. Koa.js - це фреймворк, який створений на базі Express.js, але має більш простий та зручний синтаксис. Він дозволяє легко створювати middleware та дозволяє підключати розширення.

3. Hapi.js - це фреймворк, який має вбудовану підтримку для автентифікації та авторизації, а також забезпечує зручний інтерфейс для роботи зі статичними файлами. Hapi.js є готовим до використання фреймворком, що дозволяє зосередитися на бізнес-логіці веб-додатка, а не на технічних деталях.

4. Nest.js - це фреймворк, який створений на базі TypeScript і має вбудовану підтримку для Dependency Injection (DI). Він дозволяє легко розширювати функціональність та робити код більш читабельним.

Ці фреймворки мають різні особливості та підходи до розробки веб-додатків на Node.js. Вибір фреймворку залежить від вас.

</details>

<details>
<summary>11. Опишіть словами код ендпоїнта, який повинен зберегти з клієнта файл розміром 4 гігабайти і покласти його на S3 або інший CDN.</summary>

Щоб зберегти файл розміром 4 гігабайти з клієнта та завантажити його на S3 або інший CDN, необхідно використати стандартний API JavaScript для роботи з мережевими запитами - XMLHttpRequest (або скорочено xhr). Для розміру файлів, які перевищують 2 гігабайти, може бути використаний канал Stream.

Ось код, який показує, як це можна зробити:

```jsx
const xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/large/file', true);
xhr.responseType = 'arraybuffer';

xhr.onload = function (e) {
  if (xhr.status === 200) {
    const arrayBuffer = xhr.response;

    // Створюємо blob з arrayBuffer
    const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });

    // Створюємо новий об'єкт XMLHttpRequest для завантаження файлу на сервер
    const xhr2 = new XMLHttpRequest();
    xhr2.open('PUT', 'https://s3.amazonaws.com/my-bucket/my-file', true);

    // Встановлюємо заголовок змісту файлу
    xhr2.setRequestHeader('Content-Type', 'application/octet-stream');

    // Встановлюємо заголовок для передачі файлу як байтового потоку (Stream)
    xhr2.setRequestHeader('Transfer-Encoding', 'chunked');

    // Надсилаємо запит на завантаження файлу
    xhr2.send(blob);
  }
};

xhr.send();
```

Цей код створює XMLHttpRequest запит для отримання файлу з сервера, а потім створює другий XMLHttpRequest запит, щоб завантажити отриманий файл на S3 або інший CDN. Після отримання файлу з сервера, ми створюємо blob об'єкт з arrayBuffer, який отримали, і передаємо його в другий XMLHttpRequest запит.

У другому XMLHttpRequest запиті встановлюються заголовки для передачі файлу як байтового потоку (Stream) та встановлюється заголовок змісту файлу. Потім відбувається відправка blob об'єкту на сервер за допомогою методу `send()`.

Цей код можна додатково налаштувати, наприклад, для обробки помилок, збільшення швидкості завантаження, встановлення розміру частини файлу для потокової передачі (chunk size) і т.д.

</details>

<details>
<summary>12. Що таке мікросервіси, навіщо їх використовують?</summary>

Мікросервіси - це підхід до розробки програмного забезпечення, при якому додаток розбивається на невеликі, незалежні та взаємодіючі між собою сервіси. Кожен мікросервіс відповідає за виконання окремої функції або бізнес-процесу, має власну базу даних та комунікує з іншими сервісами за допомогою мережевих інтерфейсів, наприклад, HTTP, AMQP або MQTT.

Основна мета мікросервісної архітектури полягає в забезпеченні гнучкості та масштабованості додатку. Розбивши додаток на мікросервіси, можна швидко змінювати, додавати або вилучати функціональність без впливу на інші сервіси. Крім того, мікросервіси можна масштабувати окремо, що дозволяє збільшувати потужність певних частин додатку за потреби без збільшення ресурсів для всього додатку в цілому.

Іншою перевагою мікросервісної архітектури є забезпечення резервування сервісів. Якщо один сервіс відмовляє, інші можуть продовжувати свою роботу, і додаток продовжить працювати. Крім того, це дозволяє зменшити ризики для безпеки, оскільки можна застосовувати різні політики безпеки для різних сервісів.

</details>

<details>
<summary>13. У яких випадках ви б обрали моноліт, а в яких — мікросервіси?</summary>

Вибір між монолітом та мікросервісною архітектурою залежить від конкретної ситуації та потреб проекту.

Моноліт може бути кращим вибором, якщо:

- проект є невеликим та не передбачає значної зростаючої складності;
- технічний стек однорідний і не потребує значної спеціалізації;
- інфраструктура проекту досить проста, тому немає необхідності використовувати різні технології;
- потрібно швидко створити MVP (Minimum Viable Product).

Мікросервісна архітектура може бути кращим вибором, якщо:

- проект має складну функціональність, і розбиття його на невеликі модулі забезпечить кращу розширюваність та підтримку;
- розробка різних компонентів проекту ведеться різними командами або на різних мовах програмування;
- проект має потребу в високій масштабованості і гнучкості;
- розробка і випуск нових функцій ведеться незалежно для кожного сервісу;
- проект повинен бути більш стійким до відмов сервісів.

Потрібно мати на увазі, що мікросервісна архітектура приносить більше складнощів у керуванні та координації роботи між сервісами, а також може збільшити час розробки та впровадження. Однак, у відповідних випадках мікросервіси можуть допомогти створити більш масштабовану, гнучку та стійку архітектуру.

</details>

<details>
<summary>14. Як зрозуміти, що застосунок у певний момент працює справно?</summary>

Щоб зрозуміти, що застосунок у певний момент працює справно, можна використовувати різні методики та інструменти моніторингу та аналізу даних. Ось декілька з них:

1. Моніторинг стану застосунку: Використання інструментів моніторингу стану застосунку, таких як New Relic або Datadog, може допомогти відслідковувати різні метрики, такі як час відповіді на запити, кількість запитів на одиницю часу та кількість помилок. Ці метрики можна порівняти зі стандартами проекту або попередніми результатами, щоб зрозуміти, чи працює застосунок належним чином.

2. Тестування: Застосунок можна тестувати з використанням автоматичних тестів для перевірки того, чи працює він належним чином при виконанні різних функцій. Ці тести можна запустити автоматично кожну годину або кожні кілька годин, щоб перевірити, чи не з'явилися нові помилки в застосунку.

3. Журнали подій: Рівень записування в журналах подій може бути змінений для відслідковування того, як часто виникають помилки в застосунку, які запити були зроблені та які операції виконувались. Використання цих журналів може допомогти відстежувати помилки та їх причини, щоб зрозуміти, чи працює застосунок належним чином.

4. Аналіз даних: Використання інструментів аналізу даних, таких як Elasticsearch або Splunk, може допомогти відстежувати різні метрики, такі як кількість запитів на одиницю часу та кількість помилок. Ці метрики можна порівняти з попередніми результатами, щоб зрозуміти, чи працює застосунок належним чином. Такі інструменти можуть допомогти знайти тенденції та патерни, які можуть бути корисні для виявлення проблем в застосунку.

5. Перевірка зв'язку з іншими системами: Якщо застосунок взаємодіє з іншими системами, такими як бази даних або інші сервіси, то можна перевірити, чи працюють ці системи належним чином. Це можна зробити за допомогою інструментів моніторингу, що дозволять відстежувати різні метрики, пов'язані з цими системами.

6. Відгуки користувачів: Отримання відгуків користувачів може допомогти зрозуміти, чи працює застосунок належним чином. Якщо користувачі зауважують проблеми, такі як повільність, помилки або відсутність функцій, то це може свідчити про проблеми в застосунку.

Загалом, щоб зрозуміти, чи працює застосунок належним чином, потрібно використовувати різні методики та інструменти моніторингу та аналізу даних, які дозволять відстежувати різні метрики та показники.

</details>

<details>
<summary>15. Як зрозуміти, що застосунок за останні три дні працював справно?</summary>

</details>

<details>
<summary>16. Як відбувається перевірка правильності паролю при використанні bcrypt?</summary>

</details>

<details>
<summary>17. Що таке JWT?</summary>

</details>

<details>
<summary>18. Джуніор надіслав код на рев’ю. Що тут не так? Як виправити?</summary>

```js
router.post ( '/ users', async (req, res, next) => {
    const user = await db.createUser (req);
    
    if (user) {
      return res.json (users);
    }
    
    res.json ({error: "can not create user"})
})
```


</details>

<details>
<summary>19. Порівняйте Common.js з AMD Modules та ES6 Imports.</summary>

</details>

<details>
<summary>20. Який фреймворк вибрали б для бекенду, чому?</summary>

</details>

<details>
<summary>21. Опишіть своїми словами, як працює OAuth v2.</summary>

</details>

<details>
<summary>22. Є проєкт з джерелами витоку пам’яті, як їх виявити, усунути та запобігти цьому в майбутньому?</summary>

</details>

<details>
<summary>23. Є проєкт з performance issues, як їх виявити, усунути та запобігти в майбутньому?</summary>

</details>

