## 1. Що таке DOM?

**DOM** або **Document Object Model** (об'єктна модель документа) – це прикладний програмний інтерфейс (API) для роботи з HTML та XML документами. Коли браузер вперше читає (парсить) HTML документ, він формує великий об'єкт, дійсно великий об'єкт, заснований на документі - DOM.

DOM є деревоподібною структурою (дерево документа). DOM використовується для взаємодії та зміни самої структури DOM або його окремих елементів та вузлів.

## 2. Порівняйте атрибути підключення скрипту async і defer в HTML-документі.

Атрибути async і defer в HTML-документах використовуються для того, щоб вказати браузеру, як слід підключати зовнішні скрипти, що містяться у теґу `<script>`. 

**Вони відрізняються**

1. Часом виконання: async виконує скрипт одразу після завантаження, а defer - після завантаження всього DOM;
2. Порядком виконання: async виконує скрипти безпосередньо після завантаження, порядок виконання може випадково змінюватись, тоді як defer виконує скрипти в порядку їх підключення до сторінки;
3. Взаємодією з DOM: async може вплинути на DOM під час виконання, тоді як defer не впливає на DOM, оскільки виконується лише після завантаження всього DOM.

## 3. Яка різниця між властивостями HTML-елементів innerHTML і innerText?
І `innerHTML`, і `innerText` є властивостями елементів HTML. Ми можемо змінити вміст елемента HTML за допомогою цих властивостей.

Ми можемо призначити рядок HTML властивості `innerHTML`, яка відображається як звичайний HTML. Перевірте наведений нижче приклад.

```jsx
const titleEl = document.getElementById("title");
titleEl.innerHTML = '<span style="color:orange;">techukraine.net</span>';
```
Додайте один елемент із заголовком id до свого HTML і додайте наведений вище сценарій до файлу JavaScript. Запустіть код і подивіться результат. Ви будете techukraine.net в оранжевому кольорі. І якщо ви перевірите елемент, він буде всередині тегу span. Отже, `innerHTML` візьме рядок HTML і відтворить його як звичайний HTML.
`InnerText` з іншого боку візьме звичайний рядок і відобразить його таким, яким він є. Він не відображатиме жодного HTML, як `innerHTML`. Змініть `innerHTML` на `innerText` у наведеному вище коді та перевірте результат.

```jsx
const titleEl = document.getElementById("title");
titleEl.innerText='<span style="color:orange;">techukraine.net</span>';
```

Тепер ви побачите точний рядок, який ми надали на веб-сторінці.

## 4. Опишіть процес спливання (bubbling) подій у DOM.
Коли подія відбувається в елементі DOM, вона стосується не тільки цього елемента. Подія «спливає» (подібно до бульбашки повітря у воді), переходить від елемента, що викликав подію (event.target), до його батька, потім піднімається ще вище, до батька з батька елемента, поки не досягає об'єкта Window.

Візьмемо:

```jsx
<div class="grandparent">
    <div class="parent">
        <div class="child">1</div>
    </div>
</div>
```

І такий JS код:

```jsx
function addEvent(el, event, callback, isCapture = false) {
    if (!el || !event || !callback || typeof callback !== 'function') return

    if (typeof el === 'string') {
        el = document.querySelector(el)
    }
    el.addEventListener(event, callback, isCapture)
}

addEvent(document, 'DOMContentLoaded', () => {
    const child = document.querySelector('.child')
    const parent = document.querySelector('.parent')
    const grandparent = document.querySelector('.grandparent')

    addEvent(child, 'click', function(e) {
        console.log('child')
    })

    addEvent(parent, 'click', function(e) {
        console.log('parent')
    })

    addEvent(grandparent, 'click', function(e) {
        console.log('grandparent')
    })

    addEvent('html', 'click', function(e) {
        console.log('html')
    })

    addEvent(document, 'click', function(e) {
        console.log('document')
    })

    addEvent(window, 'click', function(e) {
        console.log('window')
    })
})
```

Метод addEventListener має третій необов'язковий параметр — useCapture. Коли його значення дорівнює false (за замовчуванням), подія починається з фази спливання. Коли його значення дорівнює true, подія починається з фази занурення (для «прослуховувачів» подій, прикріплених до мети події, подія знаходиться в цільовій фазі, а не у фазах занурення або спливання. Події в цільовій фазі ініціюють всі прослуховувачі на елементі в тому порядку, в якому вони були зареєстровані незалежно від параметра useCapture. Якщо ми клацнемо по елементу child, в консоль буде виведено: child, parent, grandparent, html, document, window. Ось що таке сплив події.

## 5. Як зупинити спливання (bubbling) події?

**Спливання (bubbling)** події - це процес, коли подія, спочатку оброблена на найвнутрішньому елементі, поширюється до батьківських елементів вгору по DOM-дереву.

Щоб зупинити спливання події, можна використовувати метод `stopPropagation()` на об'єкті події. Цей метод перешкоджає подальшому поширенню події до вище розташованих елементів.

Наприклад, якщо ви маєте на сторінці кнопку у блоку та ви хочете заборонити спливання події на блок, ви можете використовувати такий код:

const block = document.querySelector('.block');
const button = document.querySelector('.button');

```jsx
button.addEventListener('click', function(event) {
    console.log('Button clicked!');
    event.stopPropagation(); // зупинка спливання події
});

block.addEventListener('click', function(event) {
    console.log('Block clicked!');  
});
```

У цьому прикладі, коли ви клікаєте на кнопку, буде викликано обробник події кнопки, який виведе повідомлення у консолі. Обробник події блоку не буде викликаний через зупинку спливання події на кнопці. Якщо ви вилучите рядок `event.stopPropagation()`;, то обробник події блоку буде викликаний також.

## 6. Як зупинити дефолтну обробку події?

Для цього необхідно викликати метод `preventDefault()` на об'єкті події (event object), що передається у функцію обробника подій.

Наприклад дію, пов'язану з кліком на посиланні, можна зупинити так:

```jsx
document.querySelector('a').addEventListener('click', function(event) {
    event.preventDefault(); // відміна стандартної дії по переходу за посиланням
    // ваші власні дії, що повинні відбутися при кліку на посиланні
});
```

## 7. Чому дорівнює this в обробнику подій (event handler)?

Значення `this` в обробнику подій залежить від того, як ви оголошуєте і прив'язуєте функцію-обробник подій.

Якщо ви використовуєте звичайну функцію, то значення `this` буде встановлено на об'єкт, що викликав обробник подій. Наприклад:

```jsx
var button = document.querySelector('button');
button.addEventListener('click', function() {
    console.log(this); // button
});
```
Якщо ж ви використовуєте стрілкову функцію, то значення `this` буде встановлено на значення this контексту, у якому оголошена функція. Наприклад:

```jsx
    var obj = {
        name: 'John',
        handleClick: function() {
            var button = document.querySelector('button');
            button.addEventListener('click', () => {
                console.log(this.name); // John
            });
        }
    };
    
    obj.handleClick();
```
Якщо ви використовуєте метод об'єкта, то значення `this` буде встановлено на цей об'єкт. Наприклад:

```jsx
var obj = {
    name: 'John',
    handleClick: function() {
        var button = document.querySelector('button');
        button.addEventListener('click', function() {
            console.log(this.name); // John
        }.bind(this));
    }
};

obj.handleClick();
```
У цьому прикладі ми використали метод `bind()` для прив'язки значення `this` контексту метода `handleClick()` до функції-обробника подій. Таким чином, коли обробник подій викликається, значення `this` буде встановлено на об'єкт obj.

## 8. Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?

`localStorage` та `sessionStorage` - це механізми для збереження даних в браузері, які дозволяють зберігати ключ-значення пари. Вони використовуються для зберігання даних між сесіями браузера, тобто дані залишаються на протязі кількох відкритих вкладок/вікон.

Основна відмінність між `localStorage` та `sessionStorage` полягає в тому, що дані, збережені в `localStorage`, не мають терміну дії та зберігаються до того часу, поки їх не буде видалено вручну або до того часу, поки не буде скинутий кеш браузера. Дані, збережені в `sessionStorage`, зберігаються лише під час поточної сесії браузера, тобто після закриття вкладки або вікна вони будуть втрачені.

Максимальний розмір `localStorage` залежить від браузера, який ви використовуєте. Зазвичай цей розмір складає 5-10 МБ, проте в різних браузерах цей розмір може бути більшим або меншим. Наприклад, в Firefox максимальний розмір `localStorage` становить 10 МБ, в Google Chrome - 5 МБ, а в Internet Explorer - 10 МБ для версій 8-10 та 250 МБ для версії 11. Для `sessionStorage` максимальний розмір зазвичай також складає 5-10 МБ, але цей розмір залежить від браузера та може відрізнятися.

## 9. Як отримати висоту блоку? Його положення щодо меж документа?

Щоб отримати висоту блоку та його положення щодо меж документа, можна використовувати властивості `offsetHeight` та `offsetTop`.

`offsetHeight` - це властивість, яка повертає висоту блоку, включаючи висоту границь (border), полей (padding) та вмісту (content), але без висоти верхнього і нижнього відступів (margin).

`offsetTop` - це властивість, яка повертає відстань від верхнього краю елемента до верхнього краю батьківського елемента.

Наприклад, якщо у вас є HTML-код такого блоку:

```jsx
<div id="myBlock" style="height: 200px; border: 1px solid black; padding: 10px; margin: 20px;">
  Some content here
</div>
```

То ви можете отримати його висоту та положення щодо меж документа таким JavaScript кодом:

```jsx
const myBlock = document.getElementById('myBlock');

// отримуємо висоту блоку
const blockHeight = myBlock.offsetHeight;
console.log(blockHeight); // 222 (200 + 1 + 20 + 1)

// отримуємо положення блоку щодо меж документа
const blockTop = myBlock.offsetTop;
console.log(blockTop); // 20
```

У прикладі вище, висота блоку myBlock дорівнює 222 пікселям, а його положення щодо меж документа - 20 пікселів. Обов'язково зверніть увагу, що для правильного отримання висоти та положення, елемент має бути вміщений в розмітці HTML.

## 10. Що таке webpack?

**Webpack** - це модульний збірник для JavaScript-програм, що дозволяє створювати багатофайлові програми для веб-браузерів.

**Webpack** дозволяє об'єднувати ваші JavaScript-файли та їх залежності в один або кілька бандлів (bundle), які можуть бути завантажені браузером. Крім того, він дозволяє застосовувати різноманітні трансформації (наприклад, компілювання TypeScript в JavaScript або зведення ECMAScript модулів в один файл) та плагіни (наприклад, оптимізація коду чи додаткова обробка ресурсів, таких як CSS та зображення).

**Webpack** забезпечує також можливість розробки за допомогою інших мов програмування, таких як TypeScript, CoffeeScript чи ES6.

В цілому, Webpack дозволяє управляти та оптимізувати завантаження ресурсів браузером, що робить його популярним інструментом для розробки веб-додатків.

## 11. Чим відрізняється dev-збірка від prod?

Dev-збірка та prod-збірка - це дві різні версії програмного продукту, які використовуються на різних етапах життєвого циклу продукту.

Dev-збірка - це версія програмного продукту, яка використовується на етапі розробки та тестування. Вона може містити додатковий функціонал, що допомагає розробникам відлагоджувати код та виявляти помилки. Dev-збірка може бути менш стабільною та більш експериментальною, тому її не рекомендується використовувати в живому середовищі.

Prod-збірка - це версія програмного продукту, яка використовується в продакшні (живому) середовищі. Вона зазвичай містить тільки функціонал, необхідний для роботи продукту, та є стабільною та перевіреною. Prod-збірка має на меті забезпечити високу якість та надійність програмного продукту для кінцевих користувачів.

Отже, основна відмінність між dev-збіркою та prod-збіркою полягає у їх призначенні: dev-збірка використовується для розробки та тестування, а prod-збірка - для продуктивної експлуатації продукту в живому середовищі.

## 12. Як заборонити браузеру віддавати кеш на HTTP-запит?

Щоб заборонити браузеру використовувати кеш на HTTP-запит, можна додати спеціальні HTTP-заголовки до запиту.

Залежно від того, який веб-сервер ви використовуєте, заголовки можуть відрізнятися, але загалом можна використовувати наступні заголовки:

**Cache-Control: no-cache** - цей заголовок вказує браузеру, що не потрібно використовувати кеш для запиту, і що сервер повинен завжди повертати нові дані.

**Pragma: no-cache** - цей заголовок діє так само, як Cache-Control: no-cache, але був створений для сумісності зі старішими версіями протоколу HTTP.

**Expires: 0** - цей заголовок вказує браузеру, що дані, отримані з сервера, завжди застарілі, і що потрібно повертати нові дані.

Наприклад:

```jsx
fetch('http://example.com/data', {
  method: 'GET',
  headers: {
    'Cache-Control': 'no-cache',
    'Pragma': 'no-cache',
    'Expires': '0'
  }
}).then(response => {
  // обробляємо відповідь сервера
}).catch(error => {
  // обробляємо помилку запиту
});

```

## 13. Що таке XSS (Cross-Site Scripting)?

**XSS (Cross-Site Scripting)** - це тип атаки на веб-додатки, який полягає у вставці зловмисного скрипту на сторінку, яку потім відображає браузер іншого користувача.

Злоумисник може використовувати XSS-атаку, щоб виконати різні злочинні дії, такі як крадіжка сесій, перенаправлення на інші сайти або керування поведінкою відвідувачів сайту.

Існують два типи XSS-атак: збережені (stored) та відображені (reflected). У збережених XSS-атаках зловмисник вставляє зловмисний код на сторінку, яку потім переглядають інші користувачі. У відображених XSS-атаках зловмисник використовує уразливість веб-додатку для відображення зловмисного коду у відповіді на запит від потенційної жертви.

Щоб запобігти XSS-атакам, рекомендується використовувати спеціальні фільтри для очищення вхідних даних перед відображенням їх на сторінці. Крім того, можна використовувати Content Security Policy (CSP), який дозволяє встановлювати правила для джерел, з яких може завантажуватися контент на сторінці, що дозволяє зменшити ризик XSS-атак.

## 14. Розкажіть про патерни Observer, Pub / Sub. Яка між ними різниця? Наведіть приклади реалізації цих патернів у відомих фреймворках / бібліотеках / браузерних API.
Observer та Pub / Sub є патернами проектування, які використовуються для реалізації взаємодії між об'єктами у програмі. Ці патерни дозволяють одному об'єкту повідомляти інші про зміни в своєму стані.

Різниця між Observer та Pub / Sub полягає в тому, що Observer передбачає пряму взаємодію між спостерігачем та спостережуваним об'єктом, тоді як Pub / Sub підписників може бути багато, і вони не повинні бути свідомі про існування один одного.

У патерні Observer спостережуваний об'єкт має список спостерігачів, які підписалися на його зміни, та повідомляє їх про будь-які зміни в своєму стані. У патерні Pub / Sub є посередник, який дозволяє підписникам підписуватися на повідомлення про події, які виникають у видавці. Видавець надсилає повідомлення про події посереднику, який передає їх усім підписникам.

Деякі з відомих фреймворків та бібліотек, які використовують Observer або Pub / Sub:

- AngularJS використовує патерн Observer у своїй реалізації директив. Кожна директива може мати об'єкт $scope, який є спостерігачем за змінами моделі. Якщо модель змінюється, $scope повідомляє про це інші спостерігачі, такі як інші директиви або контролери.
- jQuery має вбудовану функцію $(element).trigger() для генерації подій та $(element).on() для підписки на події, що дозволяє використовувати патерн Pub / Sub.
- Node.js має вбудований модуль events, який дозволяє реалізувати патерн Pub / Sub у власному додатку. В цьому модулі є клас EventEmitter, який дозволяє викликати події та підписуватися на них.
- React має свою внутрішню систему подій, яка базується на паттерні Observer. Кожен React-компонент має внутрішній стан, і коли стан компонента змінюється, React автоматично оновлює відображення компонента у відповідь на зміну стану.
- Vue.js також використовує патерн Observer у своїй реалізації реактивного програмування. Кожен екземпляр Vue.js має внутрішній об'єкт $data, який зберігає стан компонента. Коли стан змінюється, Vue.js автоматично оновлює відображення компонента.

## 15. У чому принципова різниця між подіями mouseleave і mouseout?
Обидві події `mouseleave` і `mouseout` відбуваються, коли курсор миші покидає область елемента, але принципова різниця між ними полягає в тому, як вони визначають цю область.

Подія `mouseleave` спрацьовує, коли курсор миші покидає границі області елемента, на якому була зареєстрована подія. Це означає, що якщо курсор миші знаходиться в межах дочірнього елемента, він все ще буде вважатися належним до елемента, і подія `mouseleave` не буде спрацьовувати.

Подія `mouseout` спрацьовує, коли курсор миші покидає границі області елемента, на якому була зареєстрована подія, або будь-якого з його дочірніх елементів. Це означає, що якщо курсор миші знаходиться в межах дочірнього елемента, він все ще буде вважатися належним до елемента, але подія `mouseout` буде спрацьовувати.

Отже, різниця між цими подіями полягає у тому, як вони визначають границі області елемента. Якщо вам потрібно відслідковувати, коли курсор миші точно покидає границі елемента, використовуйте подію `mouseleave`. Якщо вам потрібно відслідковувати, коли курсор миші покидає границі елемента або будь-якого з його дочірніх елементів, використовуйте подію `mouseout`.

## 16. У якому порядку обробляються призначені для користувача події в DOM (click, mouseover тощо)? FIFO чи LIFO?

Події в DOM оброблюються у порядку FIFO (First In, First Out), тобто в тому порядку, в якому вони були зареєстровані. Це означає, що якщо користувач спочатку клікнув на елементі, а потім навів на нього курсор, то спочатку буде спрацьовувати подія `click`, а потім подія `mouseover`.

Однак, якщо є багато обробників для однієї події, вони будуть виконуватися в порядку, залежному від методу, який використовується для додавання обробника. Якщо використовується метод `addEventListener()`, то обробники виконуються у порядку, в якому вони були додані. Якщо ж використовується метод .`on()`, то обробники виконуються в зворотньому порядку, тобто останній обробник, який був доданий, буде виконаний першим.

Отже, порядок обробки подій в DOM зазвичай є FIFO, але може змінюватися залежно від методу додавання обробників.

## 17. Що таке Event bubbling та Event capturing?

Event bubbling та Event capturing - це два методи, за допомогою яких визначається порядок обробки подій в DOM.

Event capturing - це механізм обробки подій, в якому події спочатку сприймаються на найбільш зовнішньому елементі (наприклад, на `window`), а потім поступово передаються на більш внутрішні елементи, поки не досягнуть цільового елементу. Тобто, зверху вниз.

Event bubbling - це механізм, при якому події спочатку сприймаються на найменшому елементі, а потім поступово передаються на більш зовнішні елементи, поки не досягнуть цільового елементу. Тобто, знизу вгору.

За замовчуванням, більшість подій використовують механізм event bubbling. Це означає, що при спрацьовуванні події на дочірньому елементі, вона також спрацьовуватиме на всіх його батьківських елементах. Однак, цю поведінку можна змінити, використовуючи метод `addEventListener()` з параметром useCapture, в якому можна вказати, чи використовувати event capturing (значення true) або event bubbling (значення false).

Наприклад, для захоплення події на фазі event capturing можна використати наступний код:

```jsx
element.addEventListener('click', function(event) {
  // обробник події
}, true);
```

Де true - використовуємо event capturing.

Щодо використання цих механізмів у відомих фреймворках / бібліотеках, то, наприклад, у jQuery за замовчуванням використовується event bubbling, але можна використовувати event capturing за допомогою методу $(selector).on(event, childSelector, data, function, useCapture). У React також використовується event bubbling, але можна використовувати event capturing за допомогою параметра capture у компоненті.

## 18. Порівняйте методи об’єкта event stopPropagation та stopImmediateProparation.
Методи `stopPropagation()` та `stopImmediatePropagation()` в об'єкті події (Event) дозволяють припинити подальшу передачу події до інших обробників.

Метод `stopPropagation() `зупиняє подальшу передачу події до батьківських елементів, тобто використовуючи цей метод можна забезпечити те, що подія не буде передана до інших обробників на вищому рівні в DOM-дереві. При цьому, обробники на поточному елементі все ще будуть викликані.

Наприклад:

```jsx
element.addEventListener('click', function(event) {
    event.stopPropagation();
    // обробник події
});
```

Метод `stopImmediatePropagation()` зупиняє подальшу передачу події до інших обробників на поточному елементі, тобто використовуючи цей метод можна забезпечити те, що жоден інший обробник на поточному елементі не буде викликаний. Таким чином, якщо є декілька обробників на поточному елементі, вони не будуть викликані після використання цього методу.

Наприклад:

```jsx
element.addEventListener('click', function(event) {
    event.stopImmediatePropagation();
    // обробник події
});
```
Отже, різниця між методами полягає в тому, що `stopPropagation()` зупиняє подальшу передачу події до батьківських елементів, а `stopImmediatePropagation()` зупиняє передачу події до інших обробників на поточному елементі. Якщо потрібно забезпечити те, що жоден інший обробник на поточному елементі не буде викликаний, варто використовувати `stopImmediatePropagation()`, якщо ж потрібно зупинити подальшу передачу події до батьківських елементів, можна використовувати `stopPropagation()`.

## 19. Які є підходи оптимізації продуктивності вебсторінки?

Оптимізація продуктивності вебсторінки є важливим аспектом веб-розробки. Нижче перераховані деякі підходи до оптимізації продуктивності вебсторінки:
1. Зменшення кількості запитів до сервера - зменшення кількості запитів до сервера може покращити продуктивність вебсторінки. Наприклад, замість декількох запитів до сервера можна зібрати всю необхідну інформацію в один запит.
2. Кешування - кешування може покращити продуктивність вебсторінки, зменшивши кількість запитів до сервера та час відповіді.
3. Мінімізація та злиття файлів - мінімізація та злиття файлів CSS та JavaScript може зменшити кількість запитів до сервера та зменшити час завантаження сторінки.
4. Використання CDN - використання CDN може зменшити час завантаження статичних файлів, таких як зображення та CSS-файли.
5. Оптимізація зображень - оптимізація зображень може зменшити їх розмір та час завантаження, зокрема, можна використовувати формати зображень з високою стисненістю, наприклад, WebP або JPEG2000.
6. Використання асинхронного завантаження ресурсів - використання асинхронного завантаження ресурсів може зменшити час завантаження сторінки, оскільки деякі ресурси, такі як зображення або скрипти, можуть завантажуватись паралельно.
7. Використання кешування на клієнті - використання кешування на клієнті може зменшити кількість запитів до сервера та зменшити час відповіді. Наприклад, використання localStorage для збереження деякої інформації на клієнтському пристрою.
8. Оптимізація коду - оптимізація коду може покращити продуктивність вебсторінки. Наприклад, можна видалити непотрібний код, оптимізувати цикли та уникнути використання складних операцій. 
9. Використання lazy loading - використання lazy loading може зменшити час завантаження сторінки, оскільки зображення та інші ресурси завантажуватимуться тільки при необхідності, наприклад, при прокручуванні сторінки. 
10. Використання інструментів для аналізу продуктивності - використання інструментів для аналізу продуктивності може допомогти знайти проблемні місця та зробити покращення. Наприклад, можна використовувати Google PageSpeed Insights або Lighthouse.

Приклади фреймворків/бібліотек, які використовують підходи до оптимізації продуктивності:

- React - використовує віртуальний DOM та можливість оптимізувати виклики setState для покращення продуктивності.
- Angular - має вбудовану можливість lazy loading та оптимізацію шляхів.
- Vue.js - має вбудовану можливість оптимізації зображень та компонентів.
- jQuery - має можливість злиття та мінімізації файлів та використання CDN.

Приклади браузерних API для оптимізації продуктивності:

- Intersection Observer API - може використовуватись для lazy loading зображень та інших ресурсів.

- Web Workers API - може використовуватись для виконання фонових завдань, що може зменшити вплив на продуктивність основного потоку.

- Service Worker API - може використовуватись для кешування та офлайн-режиму веб-додатків.

- Cache API - може використовуватись для кешування статичних ресурсів
## 20. Як реалізований механізм same-origin policy в браузері? На які браузерні API він поширюється?
Same-origin policy - це механізм безпеки, який використовується в браузерах для обмеження можливостей скриптів, запущених на одному домені, від доступу до даних на іншому домені.

Згідно з принципами same-origin policy, скрипт на веб-сторінці може отримувати доступ до ресурсів (наприклад, даних з HTTP запитів), тільки якщо ці ресурси належать до того ж домену, що й сторінка, на якій запущений скрипт.

Same-origin policy застосовується до таких браузерних API, як XMLHttpRequest, fetch, Cookies, localStorage, IndexedDB, WebSockets, а також до взаємодії між фреймами і вікнами браузера.

Same-origin policy реалізований в браузерах за допомогою перевірки трьох складових URL - схеми, домену і порту. Якщо всі три складові збігаються, запит вважається в межах одного походження, і браузер дозволяє доступ до ресурсів.

Наприклад, якщо скрипт на сторінці https://example.com/js/script.js намагається отримати доступ до ресурсу на https://example.com/data.json, запит буде успішним, оскільки обидві URL мають однаковий протокол (https), домен (example.com) і порт (якщо не зазначений в URL, то використовується стандартний порт для протоколу, наприклад, 80 для HTTP і 443 для HTTPS).

Однак, якщо скрипт на сторінці https://example.com/js/script.js намагається отримати доступ до ресурсу на https://example.org/data.json, запит буде заблокований, оскільки домени не збігаються.

Same-origin policy є важливим механізмом безпеки в браузерах, що дозволяє запобігти зловживанням з боку зловмисників.

## 21. Назвіть способи зберігання даних у браузері. Порівняйте їх.
Існує декілька способів зберігання даних у браузері, основні з них:

- Cookies - невеликі рядки даних, які зберігаються на бік-енді сервера і відправляються до клієнта через заголовок відповіді HTTP. Cookies мають обмежений розмір до 4 Кб та мають термін дії встановлений сервером. Cookies зазвичай використовуються для зберігання даних, які не є конфіденційними, такі як інформація про користувача, інформація про замовлення, налаштування веб-сайту і т.д. Важливо враховувати, що cookies можуть бути доступні для зловмисників, тому не рекомендується зберігати в них конфіденційну інформацію.

- localStorage - це механізм зберігання даних в браузері, який дозволяє зберігати до 5-10 Мб даних. Локальне сховище доступне лише для домену, що створив його. Дані зберігаються у форматі ключ-значення, які можуть бути зчитані з будь-якої сторінки на домені. Дані у localStorage зберігаються безстроково, тому потрібно вручну очищати непотрібні дані. Цей механізм часто використовується для зберігання налаштувань, тем, налаштувань мови і т.д.

- sessionStorage - це механізм зберігання даних в браузері, який працює на подібному принципі, що і localStorage, але дані зберігаються до закриття вікна або вкладки. Цей механізм зазвичай використовується для тимчасових даних, таких як збереження форми на сторінці інтернет-магазину.

- IndexedDB - це більш потужний механізм зберігання даних, який дозволяє зберігати структуровані дані, такі як об'єкти та масиви, та працювати з ними, виконуючи операції читання, запису та видалення даних. Також IndexedDB надає можливість працювати з даними асинхронно, що забезпечує кращу продуктивність та ефективність у порівнянні з іншими механізмами зберігання даних, такими як localStorage. Однак, використання IndexedDB вимагає від програміста певних навичок та знань, що може бути складним для початківців.

Інший спосіб зберігання даних у браузері - Web SQL. Web SQL - це SQL база даних, яка доступна в браузері. Web SQL була популярна в минулому, але тепер вважається застарілим і не рекомендується для використання. Вона підтримується тільки у деяких браузерах, наприклад, у Safari і Chrome. Однак, Web SQL має дуже добру продуктивність і може бути корисною для додатків, які потребують роботи зі складними структурами даних.

В загальному, вибір методу зберігання даних у браузері залежить від вимог проекту, їх масштабу та складності. LocalStorage та Cookies можуть бути корисними для простих додатків, які не потребують великої кількості даних. IndexedDB та Web SQL підходять для більш складних додатків, які потребують роботи зі структурованими даними та великою кількістю даних.

## 22. Web worker’и. Опишіть особливості передачі даних між worker’ами та основним потоком, між розділеними worker’ами.
Web worker - це механізм, який дозволяє виконувати JavaScript-код в окремих потоках, відокремлених від основного потока веб-сторінки. Основною метою використання web worker'ів є підвищення продуктивності веб-додатків, зменшення навантаження на основний потік та забезпечення кращої взаємодії з користувачем.

Особливості передачі даних між worker'ами та основним потоком:

- Передача даних від основного потоку до worker'а здійснюється за допомогою методу postMessage. Цей метод передає серіалізований об'єкт з даними для обробки у worker'і.

- Передача даних від worker'а до основного потоку здійснюється за допомогою методу postMessage так само. Worker може повернути оброблені дані, які будуть передані до обробки основним потоком.

Особливості передачі даних між розділеними worker'ами:

- Дані можуть бути передані між розділеними worker'ами за допомогою методу postMessage, який передає серіалізований об'єкт.

- Якщо один з worker'ів використовує SharedArrayBuffer або SharedWorker, то інші worker'и можуть отримати доступ до цих об'єктів і повернути змінені дані.

- Оскільки кожен worker працює в окремому потоці, то змінні не можуть бути передані між різними worker'ами безпосередньо. Це означає, що для передачі даних між різними worker'ами необхідно використовувати спільні об'єкти, такі як SharedArrayBuffer або SharedWorker.

## 23. Що таке Transferable-об’єкти?

Transferable-об'єкти - це спеціальний механізм передачі даних між потоками у веб-додатках, який дозволяє передати власність об'єкта з одного потоку до іншого, без необхідності його копіювання або клонування.

Зазвичай передача даних між потоками виконується методом `postMessage()`. Якщо передати об'єкт через цей метод, то він буде клонований, що може призвести до зайвих витрат пам'яті та часу.

Щоб уникнути цього, можна використовувати Transferable-об'єкти, передаючи їх через метод `postMessage()`, але з додатковим параметром transferList, що містить список об'єктів, власність яких перейде до потоку отримувача. При цьому переданий об'єкт буде знищений в потоці відправника, але стане доступним в потоці отримувача без додаткових витрат пам'яті та часу на копіювання.

Transferable-об'єкти можна використовувати з Web Worker’ами, Shared Worker’ами та в інших місцях, де передача даних між потоками є необхідною.

## 24. Розкажіть про способи оптимізації виконання ресурсомістких операцій JS для поліпшення продуктивності рендерингу контенту на сторінці.

Є декілька способів оптимізації виконання ресурсомістких операцій JavaScript для поліпшення продуктивності рендерингу контенту на сторінці:

- Асинхронні запити: Якщо виконується довгий процес, такий як завантаження даних або велика обробка даних, можна використовувати асинхронні запити. Це дозволяє браузеру продовжувати відображення сторінки, поки операція не завершиться. Для цього можна використовувати функції, такі як setTimeout, setInterval або requestAnimationFrame.

- Використання Web Workers: Web Workers дозволяють виконувати обчислення в окремому потоці, що зменшує навантаження на головний потік і дозволяє виконувати довгі операції без блокування відображення сторінки. Для передачі даних між потоками можна використовувати postMessage.

- Приховане відображення: Якщо є декілька складних елементів, які не відображаються відразу при завантаженні сторінки, можна відкласти їх обробку до того моменту, коли вони стануть видимими. Для цього можна використовувати обробники подій, такі як IntersectionObserver.

- Оптимізація роботи з DOM: Виконання операцій з DOM є досить ресурсомісткою операцією, тому важливо мінімізувати кількість операцій з DOM. Це можна зробити, наприклад, шляхом кешування результатів операцій з DOM або застосування методу documentFragment, що дозволяє працювати з елементами DOM в пам'яті, а не в DOM.

- Мінімізація роботи з пам'яттю: Виконання операцій, що вимагають багато пам'яті, таких як створення багатьох об'єктів, може привести до зниження продуктивності веб-сторінки. Для зменшення використання пам'яті можна використовувати техніки, такі як рециклінг об'єктів, використання даних в бінарному форматі, уникання використання зайвих змінних і т.д.

## 25. Чому ResizeObserver викликає події зміни розміру до відтворення елемента, а не після?

ResizeObserver - це API, яке дозволяє відслідковувати зміни розміру елементів на веб-сторінці. Його особливістю є те, що він викликає події зміни розміру до відтворення елемента, а не після. Це зроблено для того, щоб уникнути проблем зі відображенням контенту при зміні розміру елемента.

Коли елемент змінює свій розмір, браузер повинен перерахувати його геометрію та перевірити, чи не потрібно оновити його місцеположення в DOM. Цей процес може зайняти певний час, а якщо ResizeObserver викликає подію після цього, то можуть виникнути проблеми зі затримкою відображення змін. Тому ResizeObserver викликає події до відтворення елемента, щоб гарантувати, що зміни розміру будуть відображені якомога швидше та без затримок.

Ця особливість ResizeObserver є досить потужним інструментом для веб-розробників, який дозволяє ефективно відслідковувати зміни розміру елементів та уникнути проблем зі затримкою відображення змін.

## 26. Розкажіть, як ви розумієте Web Accessibility?
Web Accessibility (веб-доступність) - це забезпечення доступності та використання веб-ресурсів людьми з різними видами обмежень, такими як вади зору, слуху, моторики та інші. Це означає, що веб-сторінки та додатки повинні бути розроблені та налаштовані таким чином, щоб користувачі з різними обмеженнями могли отримувати доступ до контенту та функціональності без перешкод.

Для забезпечення веб-доступності необхідно виконувати ряд рекомендацій та стандартів, таких як WCAG (Web Content Accessibility Guidelines). Ці стандарти визначають набір правил та рекомендацій щодо розробки веб-ресурсів, які забезпечують їх доступність для людей з обмеженнями.

Наприклад, для забезпечення доступності для людей з вадами зору можуть використовуватись такі техніки, як використання достатньої контрастності між фоном та текстом, використання альтернативних текстових описів для зображень, використання відносних розмірів шрифту та інше.

Забезпечення веб-доступності не тільки покращує досвід користувачів з обмеженнями, але також сприяє підвищенню SEO, зростанню аудиторії та поліпшенню загального враження про веб-ресурс.

## 27. Опишіть алгоритм створення функціоналу, що забезпечує читання вмісту .txt-файлу при перетягуванні його з файлової системи у вікно браузера.

Створення функціоналу для читання вмісту .txt-файлу при перетягуванні його у вікно браузера може бути реалізовано наступним чином:

- Створити HTML-елемент для обробки події перетягування файлу (наприклад, div елемент з встановленим атрибутом draggable).

- Обробити подію dragover для відміни дії за замовчуванням (щоб заборонити перетворення файлу на посилання), наприклад:


```jsx
element.addEventListener('dragover', function(event) {
event.preventDefault();
});
```
- Обробити подію drop для зчитування файлу та відображення його вмісту. Оскільки зчитування файлу може зайняти певний час, найкраще виконати це в асинхронній функції:

```jsx
element.addEventListener('drop', async function(event) {
event.preventDefault();

// Отримати файл з перетягування
const file = event.dataTransfer.files[0];

// Перевірити, що це текстовий файл
if (file.type !== 'text/plain') {
console.log('Непідтримуваний тип файлу');
return;
}

// Зчитати вміст файлу
const text = await readFile(file);

// Відобразити вміст на сторінці
console.log(text);
});
```

- Створити функцію readFile для зчитування вмісту файлу. Можна використовувати об'єкт FileReader, що дозволяє асинхронно читати файли з файлової системи користувача:

```jsx
function readFile(file) {
  return new Promise((resolve, reject) => {
	const reader = new FileReader();

	reader.onload = () => {
      resolve(reader.result);
	};

    reader.onerror = () => {
      reject(reader.error);
    };

    reader.readAsText(file);
  });
}
```

У цій функції створюється об'єкт FileReader, додаються обробники подій onload і onerror, і викликається метод readAsText для зчитування вмісту файлу як текстового рядка. Функція повертає обіцянку, що дозволяє асинхронно отримати результат зчитування.

## 28. Що таке Virtual DOM?

Virtual DOM - це техніка, яка використовується в бібліотеках та фреймворках JavaScript для покращення продуктивності рендерингу веб-сторінок.

Коли веб-сторінка відображається в браузері, браузер створює структуру DOM (Document Object Model) - ієрархію об'єктів, які представляють відображений вміст сторінки. Кожен раз, коли відбувається зміна вмісту сторінки, браузер повинен оновлювати DOM, що може бути досить ресурсозатратним, особливо при великій кількості даних та складних маніпуляціях.

У Virtual DOM замість безпосередньої маніпуляції з реальним DOM, створюється віртуальний екземпляр DOM, який зберігається в пам'яті браузера. Коли відбувається зміна стану сторінки, бібліотека або фреймворк порівнює старий та новий віртуальні DOM, і тільки необхідні зміни застосовуються до реального DOM. Це дозволяє зменшити кількість змін, які потрібно виконати на реальному DOM та підвищити продуктивність рендерингу сторінки.

Однією з переваг Virtual DOM є також те, що це дозволяє розробникам писати код безпосередньо з фокусом на функціональності, а не на маніпуляціях з DOM.

## 29. Розкажіть про функціональне програмування.
Функціональне програмування - це підхід до програмування, де головною будівельною одиницею є функції. Функції в цьому підході використовуються як змінні, які можна передавати як параметри і повертати як результат. Функції також не залежать від стану, тобто результат виконання функції залежить тільки від її вхідних параметрів, а не від змінних з оточення.

У JavaScript функціональне програмування здебільшого базується на використанні вбудованих методів масивів, таких як map, filter і reduce, які дозволяють операції з масивами без необхідності використовувати цикли. Також, у функціональному програмуванні використовуються замикання, які дозволяють зберігати стан, не використовуючи глобальні змінні.

Функціональне програмування дає змогу створювати більш зрозумілий та підтримуваний код, оскільки функції зазвичай коротші та більш узагальнені, що дозволяє їх легше перевикористовувати. Також, використання функцій як змінних та їх передача як параметрів може допомогти в забезпеченні більш гнучкого та розширюваного коду.

## 30. Що таке TDD (Test Driven Development) / BDD (Behavior Driven Development)?

TDD (Test Driven Development) і BDD (Behavior Driven Development) - це методології розробки програмного забезпечення, які базуються на написанні тестів для перевірки функціональності програмного забезпечення перед написанням коду.

У TDD, спочатку створюються тести, які перевіряють очікуваний результат виконання програми для конкретного набору вхідних даних. Потім написаний код протестовується на виконання цих тестів. Якщо тест проходить успішно, то це означає, що програма поводить себе правильно для даного набору вхідних даних. Якщо тест не пройдений, розробник повинен внести зміни в код, щоб програма проходила тест.

У BDD, замість тестування окремих функцій або методів, пишуться тести, що перевіряють поведінку програми для конкретної сценаріїв. Тестові сценарії описуються у форматі "Якщо...То..." (Given...When...Then...), що сприяє збільшенню зрозумілості для всіх учасників розробки. При написанні коду, розробник спочатку пише код, що задовольняє тестові сценарії, і тільки потім переходить до інших вимог.

## 31. Розкажіть детально про роботу HTTPS.

HTTPS - це протокол, що забезпечує захищену передачу даних між веб-сайтами та клієнтами. Робота HTTPS складається з наступних етапів:

Клієнт надсилає запит на сервер захищеної сторінки.
Сервер відповідає з власним сертифікатом, що містить публічний ключ.
Клієнт перевіряє, чи валідний сертифікат був виписаний довіреною організацією і пов'язаний з доменом, який він відвідує.
Якщо сертифікат валідний, клієнт генерує сеансовий ключ шифрування, який він надсилає серверу, зашифрований з його публічним ключем.
Сервер розшифровує сеансовий ключ за допомогою свого приватного ключа.
Клієнт та сервер використовують цей ключ для шифрування та розшифрування даних, які вони обмінюються протягом цього сеансу.
HTTPS також забезпечує ідентифікацію сервера та забезпечує захист від атак, які можуть виникнути під час передачі даних, таких як MITM-атаки. Крім того, HTTPS дозволяє використовувати додаткові протоколи, такі як HTTP/2 та WebSocket, які можуть покращити продуктивність та швидкість передачі даних.

## 32. Який стек технологій можна обрати для реалізації клону якогось відомого проєкту і чому?

Вибір стеку технологій для клонування відомого проєкту залежить від різних факторів, таких як функціональні вимоги, екосистема, навички команди розробників, масштабованість і доступність ресурсів. Тому, немає однозначної відповіді на це запитання.

Але якщо взяти до уваги популярність та поширеність відомого проєкту, то для його клонування можна розглянути такі стеки технологій:

MERN стек (MongoDB, Express.js, React, Node.js) - цей стек є досить популярним для розробки веб-додатків, зокрема для створення клонів відомих проєктів. MongoDB використовується як база даних, Express.js - як фреймворк для створення серверної частини додатка, React - як бібліотека для створення користувацького інтерфейсу, Node.js - як середовище виконання JavaScript на стороні сервера.

MEAN стек (MongoDB, Express.js, Angular, Node.js) - це стек технологій, що також включає MongoDB як базу даних, Express.js - як фреймворк для створення серверної частини додатка, Angular - як бібліотека для створення користувацького інтерфейсу, Node.js - як середовище виконання JavaScript на стороні сервера. Цей стек є популярним для розробки веб-додатків.

LAMP стек (Linux, Apache, MySQL, PHP) - цей стек використовується для розробки веб-додатків на основі PHP, який є досить популярним для створення сайтів і веб-додатків. Linux - як операційна система, Apache - як веб-сервер, MySQL - як база даних.

Вибір стеку технологій залежить від потреб клонованого проєкту, вмінь розробників, доступності ресурсів та інших факторів.

## 33. Є проєкт на старих технологіях, необхідно в нього вносити зміни. Як це зробити найкраще?

Якщо проєкт на старих технологіях і він продовжує підтримуватися, то його можна поступово модернізувати, додавати нові функції та оновлювати існуючі.

Однак, перш ніж вносити будь-які зміни в проєкт, слід провести огляд коду та архітектури, щоб визначити, які частини проєкту потребують найбільшого оновлення. Також слід оцінити, які ризики можуть виникнути при внесенні змін та як їх уникнути.

У таких випадках може бути корисно використовувати поступову модернізацію, коли нові функції додаються з використанням новіших технологій, а старі функції поступово переносяться на нову технологію. Також можна використовувати техніки рефакторингу для покращення якості коду та спрощення архітектури.

Іншим варіантом є повна переробка проєкту на нових технологіях, що може бути більш складним та вимагати значних зусиль, але в кінцевому підсумку дозволить створити більш масштабовний, швидкий та підтримуваний проєкт. Однак, така реалізація вимагає значних витрат часу та ресурсів.

Найкращий підхід залежить від конкретних потреб проєкту, обмежень часу та ресурсів, а також експертизи розробника.

## 34. Якщо у кандидата є досвід роботи з кількома фреймворками: який будете використовувати для наступного проєкту? Які фактори будуть впливати на вибір?

При виборі фреймворку для наступного проєкту я буду враховувати такі фактори:

* відповідність фреймворку вимогам проєкту
* досвід кандидата у роботі з фреймворками
* стан та підтримка фреймворку
* розмір та продуктивність фреймворку
* наявність та якість документації та підтримки спільноти
* можливості тестування та розгортання проєкту з використанням фреймворку
* Залежно від вимог та потреб проєкту, можу вибрати один з відомих фреймворків, таких як React, Vue або Angular, або обрати менш популярний фреймворк, що краще відповідає потребам проєкту.

## 35. Що таке V8 Engine?

**V8 Engine** - це відкритий двигун JavaScript, розроблений компанією Google. Цей двигун використовується в браузері Google Chrome і в середовищі виконання Node.js. V8 Engine відповідає за компіляцію та виконання JavaScript-коду. Його ключовою особливістю є швидке виконання JavaScript-коду завдяки використанню двох видів компіляції: проміжної (just-in-time, JIT) та передкомпіляції (ahead-of-time, AOT). Це дозволяє прискорити роботу браузера або сервера, що використовує Node.js. Крім того, V8 Engine має вбудований механізм оптимізації пам'яті, що дозволяє ефективно використовувати ресурси системи.

## 36. Як браузер визначає, чи ми можемо спілкуватися між вкладками?
Безпека веб-додатків має велике значення для браузера, тому браузери забезпечують обмеження взаємодії між вкладками. Кожна вкладка має свій процес відображення і виконання JavaScript, який відповідає за ізоляцію вкладок одна від одної. Одним з головних механізмів, які використовують браузери для контролю над цими обмеженнями, є політика безпеки між джерелами (Same-origin policy).

Same-origin policy вимагає, щоб JavaScript, що виконується в одній вкладці, міг отримувати доступ до даних в інших вкладках тільки в тому випадку, якщо ці вкладки відкриті в тому ж джерелі (origin), тобто протокол, домен та порт повинні бути однаковими. Наприклад, скрипт на сторінці http://example.com не може отримати доступ до даних на сторінці https://example.com, навіть якщо це той самий сайт.

Використовуючи дану політику, браузер забезпечує безпеку, запобігає несанкціонованому доступу до даних між вкладками та між різними веб-сайтами. Однак, для певних випадків взаємодії між вкладками, браузери надають можливість використовувати спеціальні механізми, такі як Broadcast Channel API, які дозволяють передавати повідомлення між вкладками з одного джерела.

## 37. Що таке Content Security Policy?

Content Security Policy (CSP) - це механізм безпеки веб-сайту, який дозволяє контролювати та обмежувати ресурси, які можуть бути завантажені на сторінку, тим самим зменшуючи ризик XSS (Cross-Site Scripting) атак.

CSP дозволяє визначити джерела ресурсів, які можна завантажувати на сторінку, такі як скрипти, стилі, зображення, фрейми та інші. Він працює на основі списку правил, які вказують, які джерела можуть бути використані для конкретного типу ресурсів.

Це дозволяє захистити сторінку від XSS-атак, які можуть бути виконані шляхом включення шкідливого коду в вміст сторінки. Наприклад, якщо сторінка містить скрипт, який завантажується зі стороннього джерела, XSS-атакувач може змінити цей скрипт на свій зловмисний код.

За допомогою CSP можна встановити політику, яка забороняє виконання скриптів, які не були дозволені в політиці, і встановити джерела, з яких можна завантажувати вміст сторінки. Це зменшує ризик XSS-атак і дозволяє забезпечити більшу безпеку веб-сайту.

## 38. Як уникнути завантаження кешованих файлів скриптів і стилів?
Завантаження кешованих файлів скриптів і стилів може призвести до проблем з актуальністю даних на веб-сторінці, оскільки старі версії файлів можуть бути використані замість оновлених. Існують декілька способів уникнути завантаження кешованих файлів:

1. Змінити назву файлів скриптів і стилів після кожного оновлення. Таким чином, браузер перестане кешувати старі версії файлів і завантажуватиме нові.
2. Використовуйте версію файлів у URL-адресах. Додайте параметр версії до URL-адреси файлу, наприклад, "?v=2.0". Кожного разу, коли ви оновлюєте файл, змінюйте версію в URL-адресі. Це переконує браузер завантажувати нову версію файлу.
3. Встановлюйте HTTP-заголовок Cache-Control на no-cache або no-store. Це змушує браузер завжди завантажувати нові версії файлів і не кешувати їх.
4. Використовуйте query-параметри в URL-адресі для включення часової мітки. Наприклад, додайте "?t=текущий_час" до URL-адреси файлу. Кожного разу, коли файл оновлюється, часова мітка змінюється, і браузер завантажує нову версію файлу.
5. Встановлюйте HTTP-заголовок Last-Modified на час останнього оновлення файлу. Це дозволяє браузеру перевірити, чи змінювався файл з останнього разу, і завантажити нову версію файлу, якщо він був змінений.

## 39. Що таке requestAnimationFrame?
`requestAnimationFrame` - це метод JavaScript, який дозволяє планувати анімацію і інші візуальні ефекти на сторінці у відповідності з частотою оновлення браузера.

Коли викликається метод `requestAnimationFrame`, браузер заплановує виконання функції анімації на наступному кадрі анімації. Це означає, що браузер виконує анімацію з оптимальною швидкістю, а також уникає проблем з синхронізацією таймера.

Коли викликана функція анімації, вона може оновити стан візуальних елементів на сторінці, наприклад, змінити їх розмір, позицію або колір. Після цього браузер виконує наступну функцію анімації на наступному кадрі.

Цей метод дозволяє оптимізувати виконання анімації і зменшити навантаження на процесор. Він також забезпечує плавність анімації і запобігає пропусканню кадрів.

## 40. Розкажіть про мікросервісну архітектуру Front-end App.
Мікросервісна архітектура Front-end App полягає у використанні набору окремих сервісів для розробки функціоналу веб-додатку. Кожен сервіс відповідає за свою функцію і може працювати самостійно або взаємодіяти з іншими сервісами за допомогою API. Ця архітектура дозволяє зменшити залежність між функціями додатку та спростити розробку та розгортання.

Зазвичай в мікросервісній архітектурі Front-end App можна виділити декілька типів сервісів:

Front-end сервіси: відповідають за створення інтерфейсу користувача, включаючи розміщення компонентів та взаємодію з ними.

API сервіси: відповідають за обробку запитів та відповідей між фронтендом та бекендом, дозволяючи спілкуватися з базою даних та іншими зовнішніми джерелами.

Utility сервіси: відповідають за певні функції, такі як аналітика, логування, автентифікація та авторизація.

Testing сервіси: відповідають за автоматизацію тестування та контроль якості додатку.

Мікросервісна архітектура Front-end App має декілька переваг, зокрема зменшення залежності між функціями додатку, спрощення розгортання та розвитку додатку, забезпечення масштабованості та покращення безпеки. Однак, ця архітектура може бути складною в розумінні та управлінні, тому важливо правильно розробляти та документувати кожен сервіс.

## 41. Що таке Shadow DOM?
Shadow DOM - це технологія, що дозволяє створювати і використовувати компоненти веб-інтерфейсу зі своїм внутрішнім деревом DOM та стилями, які ізольовані від зовнішнього документа. Завдяки цьому забезпечується відокремленість внутрішніх компонентів від зовнішнього коду, що дозволяє уникнути конфліктів іменування та забезпечити більш просту та ефективну розробку.

У Shadow DOM кожен компонент може мати своє внутрішнє дерево DOM, яке складається з елементів, ізольованих від зовнішнього документа. Крім того, компонент може мати свої внутрішні стилі, які не застосовуються до інших елементів на сторінці. Це дозволяє зберігати стилі та розміщувати елементи в компонентах, які можуть бути перевикористані в різних місцях документа.

Shadow DOM забезпечується за допомогою елемента `<template>` та методів API. Елемент `<template>` дозволяє створювати шаблон компонента, який можна використовувати в документі без його відображення. За допомогою методів API, таких як `attachShadow()`, можна динамічно додавати компоненти зі своїм внутрішнім DOM та стилями в документ.

Shadow DOM є важливою технологією для створення складних веб-інтерфейсів, які складаються з багатьох компонентів. Використання цієї технології дозволяє створювати зручні, ефективні та легко супроводжувані компоненти, які можна перевикористовувати в різних місцях документа.

## 42. Порівняйте nextElementSibling та nextSibling.

nextSibling є свойством, яке повертає наступний вузол на одному рівні вкладеності з поточним вузлом (може бути текстовий вузол, коментар або елемент), тоді як nextElementSibling повертає наступний елемент у списку дочірніх елементів на тому ж рівні вкладеності.

Таким чином, nextElementSibling ігнорує текстові вузли та коментарі, які можуть знаходитися між елементами. Він повертає лише наступний елемент-брат, якщо такий існує, або null, якщо поточний елемент є останнім на своєму рівні вкладеності.

Отже, якщо ми хочемо отримати наступний елемент в DOM, який є елементом, то бажано використовувати nextElementSibling. Якщо ж нас цікавить будь-який наступний вузол на одному рівні вкладеності, включаючи текст та коментарі, можна використовувати nextSibling.

## 43. Які знаєте метрики вебсайту?

Існує багато метрик вебсайту, які використовуються для вимірювання його продуктивності, ефективності та користувальницького досвіду. Ось деякі з найбільш популярних метрик:

Швидкість завантаження сторінки - час, потрібний для завантаження сторінки на пристрій користувача.

First Contentful Paint (FCP) - час, який потрібен браузеру, щоб відобразити перший зміст на сторінці.

Time to Interactive (TTI) - час, який потрібен для повної взаємодії з користувачем, такої як відповідь на кліки та інші дії.

Кількість запитів - кількість запитів, які виконується браузером для завантаження сторінки.

Розмір сторінки - загальний розмір сторінки, включаючи всі ресурси, такі як зображення та скрипти.

Bounce rate - відсоток відвідувачів, які покидають сайт після першої сторінки.

Conversion rate - відсоток відвідувачів, які виконують бажану дію, наприклад, покупку товару.

Engagement rate - відсоток відвідувачів, які взаємодіють з контентом на сторінці, наприклад, коментують або діляться публікацією в соціальних мережах.

Exit rate - відсоток відвідувачів, які покидають сайт після перегляду певної сторінки.

Ці метрики дозволяють оцінювати ефективність та продуктивність веб-сайту, а також забезпечують корисну інформацію для поліпшення користувальницького досвіду та збільшення конверсій.
