## 1. Що таке DOM?

**DOM** або **Document Object Model** (об'єктна модель документа) – це прикладний програмний інтерфейс (API) для роботи з HTML та XML документами. Коли браузер вперше читає (парсить) HTML документ, він формує великий об'єкт, дійсно великий об'єкт, заснований на документі - DOM.

DOM є деревоподібною структурою (дерево документа). DOM використовується для взаємодії та зміни самої структури DOM або його окремих елементів та вузлів.

## 2. Порівняйте атрибути підключення скрипту async і defer в HTML-документі.

Атрибути async і defer в HTML-документах використовуються для того, щоб вказати браузеру, як слід підключати зовнішні скрипти, що містяться у теґу `<script>`. 

**Вони відрізняються**

1. Часом виконання: async виконує скрипт одразу після завантаження, а defer - після завантаження всього DOM;
2. Порядком виконання: async виконує скрипти безпосередньо після завантаження, порядок виконання може випадково змінюватись, тоді як defer виконує скрипти в порядку їх підключення до сторінки;
3. Взаємодією з DOM: async може вплинути на DOM під час виконання, тоді як defer не впливає на DOM, оскільки виконується лише після завантаження всього DOM.

## 3. Яка різниця між властивостями HTML-елементів innerHTML і innerText?
І `innerHTML`, і `innerText` є властивостями елементів HTML. Ми можемо змінити вміст елемента HTML за допомогою цих властивостей.

Ми можемо призначити рядок HTML властивості `innerHTML`, яка відображається як звичайний HTML. Перевірте наведений нижче приклад.

```jsx
const titleEl = document.getElementById("title");
titleEl.innerHTML = '<span style="color:orange;">techukraine.net</span>';
```
Додайте один елемент із заголовком id до свого HTML і додайте наведений вище сценарій до файлу JavaScript. Запустіть код і подивіться результат. Ви будете techukraine.net в оранжевому кольорі. І якщо ви перевірите елемент, він буде всередині тегу span. Отже, `innerHTML` візьме рядок HTML і відтворить його як звичайний HTML.
`InnerText` з іншого боку візьме звичайний рядок і відобразить його таким, яким він є. Він не відображатиме жодного HTML, як `innerHTML`. Змініть `innerHTML` на `innerText` у наведеному вище коді та перевірте результат.

```jsx
const titleEl = document.getElementById("title");
titleEl.innerText='<span style="color:orange;">techukraine.net</span>';
```

Тепер ви побачите точний рядок, який ми надали на веб-сторінці.

## 4. Опишіть процес спливання (bubbling) подій у DOM.
Коли подія відбувається в елементі DOM, вона стосується не тільки цього елемента. Подія «спливає» (подібно до бульбашки повітря у воді), переходить від елемента, що викликав подію (event.target), до його батька, потім піднімається ще вище, до батька з батька елемента, поки не досягає об'єкта Window.

Візьмемо:

```jsx
<div class="grandparent">
    <div class="parent">
        <div class="child">1</div>
    </div>
</div>
```

І такий JS код:

```jsx
function addEvent(el, event, callback, isCapture = false) {
    if (!el || !event || !callback || typeof callback !== 'function') return

    if (typeof el === 'string') {
        el = document.querySelector(el)
    }
    el.addEventListener(event, callback, isCapture)
}

addEvent(document, 'DOMContentLoaded', () => {
    const child = document.querySelector('.child')
    const parent = document.querySelector('.parent')
    const grandparent = document.querySelector('.grandparent')

    addEvent(child, 'click', function(e) {
        console.log('child')
    })

    addEvent(parent, 'click', function(e) {
        console.log('parent')
    })

    addEvent(grandparent, 'click', function(e) {
        console.log('grandparent')
    })

    addEvent('html', 'click', function(e) {
        console.log('html')
    })

    addEvent(document, 'click', function(e) {
        console.log('document')
    })

    addEvent(window, 'click', function(e) {
        console.log('window')
    })
})
```

Метод addEventListener має третій необов'язковий параметр — useCapture. Коли його значення дорівнює false (за замовчуванням), подія починається з фази спливання. Коли його значення дорівнює true, подія починається з фази занурення (для «прослуховувачів» подій, прикріплених до мети події, подія знаходиться в цільовій фазі, а не у фазах занурення або спливання. Події в цільовій фазі ініціюють всі прослуховувачі на елементі в тому порядку, в якому вони були зареєстровані незалежно від параметра useCapture. Якщо ми клацнемо по елементу child, в консоль буде виведено: child, parent, grandparent, html, document, window. Ось що таке сплив події.

## 5. Як зупинити спливання (bubbling) події?

**Спливання (bubbling)** події - це процес, коли подія, спочатку оброблена на найвнутрішньому елементі, поширюється до батьківських елементів вгору по DOM-дереву.

Щоб зупинити спливання події, можна використовувати метод `stopPropagation()` на об'єкті події. Цей метод перешкоджає подальшому поширенню події до вище розташованих елементів.

Наприклад, якщо ви маєте на сторінці кнопку у блоку та ви хочете заборонити спливання події на блок, ви можете використовувати такий код:

const block = document.querySelector('.block');
const button = document.querySelector('.button');

```jsx
button.addEventListener('click', function(event) {
    console.log('Button clicked!');
    event.stopPropagation(); // зупинка спливання події
});

block.addEventListener('click', function(event) {
    console.log('Block clicked!');  
});
```

У цьому прикладі, коли ви клікаєте на кнопку, буде викликано обробник події кнопки, який виведе повідомлення у консолі. Обробник події блоку не буде викликаний через зупинку спливання події на кнопці. Якщо ви вилучите рядок `event.stopPropagation()`;, то обробник події блоку буде викликаний також.

## 6. Як зупинити дефолтну обробку події?

Для цього необхідно викликати метод `preventDefault()` на об'єкті події (event object), що передається у функцію обробника подій.

Наприклад дію, пов'язану з кліком на посиланні, можна зупинити так:

```jsx
document.querySelector('a').addEventListener('click', function(event) {
    event.preventDefault(); // відміна стандартної дії по переходу за посиланням
    // ваші власні дії, що повинні відбутися при кліку на посиланні
});
```

## 7. Чому дорівнює this в обробнику подій (event handler)?

Значення `this` в обробнику подій залежить від того, як ви оголошуєте і прив'язуєте функцію-обробник подій.

Якщо ви використовуєте звичайну функцію, то значення `this` буде встановлено на об'єкт, що викликав обробник подій. Наприклад:

```jsx
var button = document.querySelector('button');
button.addEventListener('click', function() {
    console.log(this); // button
});
```
Якщо ж ви використовуєте стрілкову функцію, то значення `this` буде встановлено на значення this контексту, у якому оголошена функція. Наприклад:

```jsx
    var obj = {
        name: 'John',
        handleClick: function() {
            var button = document.querySelector('button');
            button.addEventListener('click', () => {
                console.log(this.name); // John
            });
        }
    };
    
    obj.handleClick();
```
Якщо ви використовуєте метод об'єкта, то значення `this` буде встановлено на цей об'єкт. Наприклад:

```jsx
var obj = {
    name: 'John',
    handleClick: function() {
        var button = document.querySelector('button');
        button.addEventListener('click', function() {
            console.log(this.name); // John
        }.bind(this));
    }
};

obj.handleClick();
```
У цьому прикладі ми використали метод `bind()` для прив'язки значення `this` контексту метода `handleClick()` до функції-обробника подій. Таким чином, коли обробник подій викликається, значення `this` буде встановлено на об'єкт obj.

## 8. Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?

`localStorage` та `sessionStorage` - це механізми для збереження даних в браузері, які дозволяють зберігати ключ-значення пари. Вони використовуються для зберігання даних між сесіями браузера, тобто дані залишаються на протязі кількох відкритих вкладок/вікон.

Основна відмінність між `localStorage` та `sessionStorage` полягає в тому, що дані, збережені в `localStorage`, не мають терміну дії та зберігаються до того часу, поки їх не буде видалено вручну або до того часу, поки не буде скинутий кеш браузера. Дані, збережені в `sessionStorage`, зберігаються лише під час поточної сесії браузера, тобто після закриття вкладки або вікна вони будуть втрачені.

Максимальний розмір `localStorage` залежить від браузера, який ви використовуєте. Зазвичай цей розмір складає 5-10 МБ, проте в різних браузерах цей розмір може бути більшим або меншим. Наприклад, в Firefox максимальний розмір `localStorage` становить 10 МБ, в Google Chrome - 5 МБ, а в Internet Explorer - 10 МБ для версій 8-10 та 250 МБ для версії 11. Для `sessionStorage` максимальний розмір зазвичай також складає 5-10 МБ, але цей розмір залежить від браузера та може відрізнятися.

## 9. Як отримати висоту блоку? Його положення щодо меж документа?

Щоб отримати висоту блоку та його положення щодо меж документа, можна використовувати властивості `offsetHeight` та `offsetTop`.

`offsetHeight` - це властивість, яка повертає висоту блоку, включаючи висоту границь (border), полей (padding) та вмісту (content), але без висоти верхнього і нижнього відступів (margin).

`offsetTop` - це властивість, яка повертає відстань від верхнього краю елемента до верхнього краю батьківського елемента.

Наприклад, якщо у вас є HTML-код такого блоку:

```jsx
<div id="myBlock" style="height: 200px; border: 1px solid black; padding: 10px; margin: 20px;">
  Some content here
</div>
```

То ви можете отримати його висоту та положення щодо меж документа таким JavaScript кодом:

```jsx
const myBlock = document.getElementById('myBlock');

// отримуємо висоту блоку
const blockHeight = myBlock.offsetHeight;
console.log(blockHeight); // 222 (200 + 1 + 20 + 1)

// отримуємо положення блоку щодо меж документа
const blockTop = myBlock.offsetTop;
console.log(blockTop); // 20
```

У прикладі вище, висота блоку myBlock дорівнює 222 пікселям, а його положення щодо меж документа - 20 пікселів. Обов'язково зверніть увагу, що для правильного отримання висоти та положення, елемент має бути вміщений в розмітці HTML.

## 10. Що таке webpack?

**Webpack** - це модульний збірник для JavaScript-програм, що дозволяє створювати багатофайлові програми для веб-браузерів.

**Webpack** дозволяє об'єднувати ваші JavaScript-файли та їх залежності в один або кілька бандлів (bundle), які можуть бути завантажені браузером. Крім того, він дозволяє застосовувати різноманітні трансформації (наприклад, компілювання TypeScript в JavaScript або зведення ECMAScript модулів в один файл) та плагіни (наприклад, оптимізація коду чи додаткова обробка ресурсів, таких як CSS та зображення).

**Webpack** забезпечує також можливість розробки за допомогою інших мов програмування, таких як TypeScript, CoffeeScript чи ES6.

В цілому, Webpack дозволяє управляти та оптимізувати завантаження ресурсів браузером, що робить його популярним інструментом для розробки веб-додатків.

## 11. Чим відрізняється dev-збірка від prod?

Dev-збірка та prod-збірка - це дві різні версії програмного продукту, які використовуються на різних етапах життєвого циклу продукту.

Dev-збірка - це версія програмного продукту, яка використовується на етапі розробки та тестування. Вона може містити додатковий функціонал, що допомагає розробникам відлагоджувати код та виявляти помилки. Dev-збірка може бути менш стабільною та більш експериментальною, тому її не рекомендується використовувати в живому середовищі.

Prod-збірка - це версія програмного продукту, яка використовується в продакшні (живому) середовищі. Вона зазвичай містить тільки функціонал, необхідний для роботи продукту, та є стабільною та перевіреною. Prod-збірка має на меті забезпечити високу якість та надійність програмного продукту для кінцевих користувачів.

Отже, основна відмінність між dev-збіркою та prod-збіркою полягає у їх призначенні: dev-збірка використовується для розробки та тестування, а prod-збірка - для продуктивної експлуатації продукту в живому середовищі.

## 12. Як заборонити браузеру віддавати кеш на HTTP-запит?

Щоб заборонити браузеру використовувати кеш на HTTP-запит, можна додати спеціальні HTTP-заголовки до запиту.

Залежно від того, який веб-сервер ви використовуєте, заголовки можуть відрізнятися, але загалом можна використовувати наступні заголовки:

**Cache-Control: no-cache** - цей заголовок вказує браузеру, що не потрібно використовувати кеш для запиту, і що сервер повинен завжди повертати нові дані.

**Pragma: no-cache** - цей заголовок діє так само, як Cache-Control: no-cache, але був створений для сумісності зі старішими версіями протоколу HTTP.

**Expires: 0** - цей заголовок вказує браузеру, що дані, отримані з сервера, завжди застарілі, і що потрібно повертати нові дані.

Наприклад:

```jsx
fetch('http://example.com/data', {
  method: 'GET',
  headers: {
    'Cache-Control': 'no-cache',
    'Pragma': 'no-cache',
    'Expires': '0'
  }
}).then(response => {
  // обробляємо відповідь сервера
}).catch(error => {
  // обробляємо помилку запиту
});

```

## 13. Що таке XSS (Cross-Site Scripting)?

**XSS (Cross-Site Scripting)** - це тип атаки на веб-додатки, який полягає у вставці зловмисного скрипту на сторінку, яку потім відображає браузер іншого користувача.

Злоумисник може використовувати XSS-атаку, щоб виконати різні злочинні дії, такі як крадіжка сесій, перенаправлення на інші сайти або керування поведінкою відвідувачів сайту.

Існують два типи XSS-атак: збережені (stored) та відображені (reflected). У збережених XSS-атаках зловмисник вставляє зловмисний код на сторінку, яку потім переглядають інші користувачі. У відображених XSS-атаках зловмисник використовує уразливість веб-додатку для відображення зловмисного коду у відповіді на запит від потенційної жертви.

Щоб запобігти XSS-атакам, рекомендується використовувати спеціальні фільтри для очищення вхідних даних перед відображенням їх на сторінці. Крім того, можна використовувати Content Security Policy (CSP), який дозволяє встановлювати правила для джерел, з яких може завантажуватися контент на сторінці, що дозволяє зменшити ризик XSS-атак.

## 14. Розкажіть про патерни Observer, Pub / Sub. Яка між ними різниця? Наведіть приклади реалізації цих патернів у відомих фреймворках / бібліотеках / браузерних API.
Observer та Pub / Sub є патернами проектування, які використовуються для реалізації взаємодії між об'єктами у програмі. Ці патерни дозволяють одному об'єкту повідомляти інші про зміни в своєму стані.

Різниця між Observer та Pub / Sub полягає в тому, що Observer передбачає пряму взаємодію між спостерігачем та спостережуваним об'єктом, тоді як Pub / Sub підписників може бути багато, і вони не повинні бути свідомі про існування один одного.

У патерні Observer спостережуваний об'єкт має список спостерігачів, які підписалися на його зміни, та повідомляє їх про будь-які зміни в своєму стані. У патерні Pub / Sub є посередник, який дозволяє підписникам підписуватися на повідомлення про події, які виникають у видавці. Видавець надсилає повідомлення про події посереднику, який передає їх усім підписникам.

Деякі з відомих фреймворків та бібліотек, які використовують Observer або Pub / Sub:

- AngularJS використовує патерн Observer у своїй реалізації директив. Кожна директива може мати об'єкт $scope, який є спостерігачем за змінами моделі. Якщо модель змінюється, $scope повідомляє про це інші спостерігачі, такі як інші директиви або контролери.
- jQuery має вбудовану функцію $(element).trigger() для генерації подій та $(element).on() для підписки на події, що дозволяє використовувати патерн Pub / Sub.
- Node.js має вбудований модуль events, який дозволяє реалізувати патерн Pub / Sub у власному додатку. В цьому модулі є клас EventEmitter, який дозволяє викликати події та підписуватися на них.
- React має свою внутрішню систему подій, яка базується на паттерні Observer. Кожен React-компонент має внутрішній стан, і коли стан компонента змінюється, React автоматично оновлює відображення компонента у відповідь на зміну стану.
- Vue.js також використовує патерн Observer у своїй реалізації реактивного програмування. Кожен екземпляр Vue.js має внутрішній об'єкт $data, який зберігає стан компонента. Коли стан змінюється, Vue.js автоматично оновлює відображення компонента.

## 15. У чому принципова різниця між подіями mouseleave і mouseout?
Обидві події `mouseleave` і `mouseout` відбуваються, коли курсор миші покидає область елемента, але принципова різниця між ними полягає в тому, як вони визначають цю область.

Подія `mouseleave` спрацьовує, коли курсор миші покидає границі області елемента, на якому була зареєстрована подія. Це означає, що якщо курсор миші знаходиться в межах дочірнього елемента, він все ще буде вважатися належним до елемента, і подія `mouseleave` не буде спрацьовувати.

Подія `mouseout` спрацьовує, коли курсор миші покидає границі області елемента, на якому була зареєстрована подія, або будь-якого з його дочірніх елементів. Це означає, що якщо курсор миші знаходиться в межах дочірнього елемента, він все ще буде вважатися належним до елемента, але подія `mouseout` буде спрацьовувати.

Отже, різниця між цими подіями полягає у тому, як вони визначають границі області елемента. Якщо вам потрібно відслідковувати, коли курсор миші точно покидає границі елемента, використовуйте подію `mouseleave`. Якщо вам потрібно відслідковувати, коли курсор миші покидає границі елемента або будь-якого з його дочірніх елементів, використовуйте подію `mouseout`.

## 16. У якому порядку обробляються призначені для користувача події в DOM (click, mouseover тощо)? FIFO чи LIFO?

Події в DOM оброблюються у порядку FIFO (First In, First Out), тобто в тому порядку, в якому вони були зареєстровані. Це означає, що якщо користувач спочатку клікнув на елементі, а потім навів на нього курсор, то спочатку буде спрацьовувати подія `click`, а потім подія `mouseover`.

Однак, якщо є багато обробників для однієї події, вони будуть виконуватися в порядку, залежному від методу, який використовується для додавання обробника. Якщо використовується метод `addEventListener()`, то обробники виконуються у порядку, в якому вони були додані. Якщо ж використовується метод .`on()`, то обробники виконуються в зворотньому порядку, тобто останній обробник, який був доданий, буде виконаний першим.

Отже, порядок обробки подій в DOM зазвичай є FIFO, але може змінюватися залежно від методу додавання обробників.

## 17. Що таке Event bubbling та Event capturing?

Event bubbling та Event capturing - це два методи, за допомогою яких визначається порядок обробки подій в DOM.

Event capturing - це механізм обробки подій, в якому події спочатку сприймаються на найбільш зовнішньому елементі (наприклад, на `window`), а потім поступово передаються на більш внутрішні елементи, поки не досягнуть цільового елементу. Тобто, зверху вниз.

Event bubbling - це механізм, при якому події спочатку сприймаються на найменшому елементі, а потім поступово передаються на більш зовнішні елементи, поки не досягнуть цільового елементу. Тобто, знизу вгору.

За замовчуванням, більшість подій використовують механізм event bubbling. Це означає, що при спрацьовуванні події на дочірньому елементі, вона також спрацьовуватиме на всіх його батьківських елементах. Однак, цю поведінку можна змінити, використовуючи метод `addEventListener()` з параметром useCapture, в якому можна вказати, чи використовувати event capturing (значення true) або event bubbling (значення false).

Наприклад, для захоплення події на фазі event capturing можна використати наступний код:

```jsx
element.addEventListener('click', function(event) {
  // обробник події
}, true);
```

Де true - використовуємо event capturing.

Щодо використання цих механізмів у відомих фреймворках / бібліотеках, то, наприклад, у jQuery за замовчуванням використовується event bubbling, але можна використовувати event capturing за допомогою методу $(selector).on(event, childSelector, data, function, useCapture). У React також використовується event bubbling, але можна використовувати event capturing за допомогою параметра capture у компоненті.

## 18. Порівняйте методи об’єкта event stopPropagation та stopImmediateProparation.
Методи `stopPropagation()` та `stopImmediatePropagation()` в об'єкті події (Event) дозволяють припинити подальшу передачу події до інших обробників.

Метод `stopPropagation() `зупиняє подальшу передачу події до батьківських елементів, тобто використовуючи цей метод можна забезпечити те, що подія не буде передана до інших обробників на вищому рівні в DOM-дереві. При цьому, обробники на поточному елементі все ще будуть викликані.

Наприклад:

```jsx
element.addEventListener('click', function(event) {
    event.stopPropagation();
    // обробник події
});
```

Метод `stopImmediatePropagation()` зупиняє подальшу передачу події до інших обробників на поточному елементі, тобто використовуючи цей метод можна забезпечити те, що жоден інший обробник на поточному елементі не буде викликаний. Таким чином, якщо є декілька обробників на поточному елементі, вони не будуть викликані після використання цього методу.

Наприклад:

```jsx
element.addEventListener('click', function(event) {
    event.stopImmediatePropagation();
    // обробник події
});
```
Отже, різниця між методами полягає в тому, що `stopPropagation()` зупиняє подальшу передачу події до батьківських елементів, а `stopImmediatePropagation()` зупиняє передачу події до інших обробників на поточному елементі. Якщо потрібно забезпечити те, що жоден інший обробник на поточному елементі не буде викликаний, варто використовувати `stopImmediatePropagation()`, якщо ж потрібно зупинити подальшу передачу події до батьківських елементів, можна використовувати `stopPropagation()`.

## 19. Які є підходи оптимізації продуктивності вебсторінки?

Оптимізація продуктивності вебсторінки є важливим аспектом веб-розробки. Нижче перераховані деякі підходи до оптимізації продуктивності вебсторінки:
1. Зменшення кількості запитів до сервера - зменшення кількості запитів до сервера може покращити продуктивність вебсторінки. Наприклад, замість декількох запитів до сервера можна зібрати всю необхідну інформацію в один запит.
2. Кешування - кешування може покращити продуктивність вебсторінки, зменшивши кількість запитів до сервера та час відповіді.
3. Мінімізація та злиття файлів - мінімізація та злиття файлів CSS та JavaScript може зменшити кількість запитів до сервера та зменшити час завантаження сторінки.
4. Використання CDN - використання CDN може зменшити час завантаження статичних файлів, таких як зображення та CSS-файли.
5. Оптимізація зображень - оптимізація зображень може зменшити їх розмір та час завантаження, зокрема, можна використовувати формати зображень з високою стисненістю, наприклад, WebP або JPEG2000.
6. Використання асинхронного завантаження ресурсів - використання асинхронного завантаження ресурсів може зменшити час завантаження сторінки, оскільки деякі ресурси, такі як зображення або скрипти, можуть завантажуватись паралельно.
7. Використання кешування на клієнті - використання кешування на клієнті може зменшити кількість запитів до сервера та зменшити час відповіді. Наприклад, використання localStorage для збереження деякої інформації на клієнтському пристрою.
8. Оптимізація коду - оптимізація коду може покращити продуктивність вебсторінки. Наприклад, можна видалити непотрібний код, оптимізувати цикли та уникнути використання складних операцій. 
9. Використання lazy loading - використання lazy loading може зменшити час завантаження сторінки, оскільки зображення та інші ресурси завантажуватимуться тільки при необхідності, наприклад, при прокручуванні сторінки. 
10. Використання інструментів для аналізу продуктивності - використання інструментів для аналізу продуктивності може допомогти знайти проблемні місця та зробити покращення. Наприклад, можна використовувати Google PageSpeed Insights або Lighthouse.

Приклади фреймворків/бібліотек, які використовують підходи до оптимізації продуктивності:

- React - використовує віртуальний DOM та можливість оптимізувати виклики setState для покращення продуктивності.
- Angular - має вбудовану можливість lazy loading та оптимізацію шляхів.
- Vue.js - має вбудовану можливість оптимізації зображень та компонентів.
- jQuery - має можливість злиття та мінімізації файлів та використання CDN.

Приклади браузерних API для оптимізації продуктивності:

- Intersection Observer API - може використовуватись для lazy loading зображень та інших ресурсів.

- Web Workers API - може використовуватись для виконання фонових завдань, що може зменшити вплив на продуктивність основного потоку.

- Service Worker API - може використовуватись для кешування та офлайн-режиму веб-додатків.

- Cache API - може використовуватись для кешування статичних ресурсів
## 20. Як реалізований механізм same-origin policy в браузері? На які браузерні API він поширюється?
Same-origin policy - це механізм безпеки, який використовується в браузерах для обмеження можливостей скриптів, запущених на одному домені, від доступу до даних на іншому домені.

Згідно з принципами same-origin policy, скрипт на веб-сторінці може отримувати доступ до ресурсів (наприклад, даних з HTTP запитів), тільки якщо ці ресурси належать до того ж домену, що й сторінка, на якій запущений скрипт.

Same-origin policy застосовується до таких браузерних API, як XMLHttpRequest, fetch, Cookies, localStorage, IndexedDB, WebSockets, а також до взаємодії між фреймами і вікнами браузера.

Same-origin policy реалізований в браузерах за допомогою перевірки трьох складових URL - схеми, домену і порту. Якщо всі три складові збігаються, запит вважається в межах одного походження, і браузер дозволяє доступ до ресурсів.

Наприклад, якщо скрипт на сторінці https://example.com/js/script.js намагається отримати доступ до ресурсу на https://example.com/data.json, запит буде успішним, оскільки обидві URL мають однаковий протокол (https), домен (example.com) і порт (якщо не зазначений в URL, то використовується стандартний порт для протоколу, наприклад, 80 для HTTP і 443 для HTTPS).

Однак, якщо скрипт на сторінці https://example.com/js/script.js намагається отримати доступ до ресурсу на https://example.org/data.json, запит буде заблокований, оскільки домени не збігаються.

Same-origin policy є важливим механізмом безпеки в браузерах, що дозволяє запобігти зловживанням з боку зловмисників.

## 21. Назвіть способи зберігання даних у браузері. Порівняйте їх.

## 22. Web worker’и. Опишіть особливості передачі даних між worker’ами та основним потоком, між розділеними worker’ами.

## 23. Що таке Transferable-об’єкти?

## 24. Розкажіть про способи оптимізації виконання ресурсомістких операцій JS для поліпшення продуктивності рендерингу контенту на сторінці.

## 25. Чому ResizeObserver викликає події зміни розміру до відтворення елемента, а не після?

## 26. Розкажіть, як ви розумієте Web Accessibility?

## 27. Опишіть алгоритм створення функціоналу, що забезпечує читання вмісту .txt-файлу при перетягуванні його з файлової системи у вікно браузера.

## 28. Що таке Virtual DOM?

## 29.Розкажіть про функціональне програмування.

## 30.Що таке TDD (Test Driven Development) / BDD (Behavior Driven Development)?

## 31.Розкажіть детально про роботу HTTPS.

## 32.Який стек технологій можна обрати для реалізації клону якогось відомого проєкту і чому?

## 33.Є проєкт на старих технологіях, необхідно в нього вносити зміни. Як це зробити найкраще?

## 34.Якщо у кандидата є досвід роботи з кількома фреймворками: який будете використовувати для наступного проєкту? Які фактори будуть впливати на вибір?

## 35.Що таке V8 Engine?

## 36.Як браузер визначає, чи ми можемо спілкуватися між вкладками?

## 37.Що таке Content Security Policy?

## 38.Як уникнути завантаження кешованих файлів скриптів і стилів?

## 39.Що таке requestAnimationFrame?

## 40.Розкажіть про мікросервісну архітектуру Front-end App.

## 41.Що таке Shadow DOM?

## 42.Порівняйте nextElementSibling та nextSibling.

## 43.Які знаєте метрики вебсайту?
