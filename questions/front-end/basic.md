## 1. Що таке DOM?

**DOM** або **Document Object Model** (об'єктна модель документа) – це прикладний програмний інтерфейс (API) для роботи з HTML та XML документами. Коли браузер вперше читає (парсить) HTML документ, він формує великий об'єкт, дійсно великий об'єкт, заснований на документі - DOM.

DOM є деревоподібною структурою (дерево документа). DOM використовується для взаємодії та зміни самої структури DOM або його окремих елементів та вузлів.

## 2. Порівняйте атрибути підключення скрипту async і defer в HTML-документі.

Атрибути async і defer в HTML-документах використовуються для того, щоб вказати браузеру, як слід підключати зовнішні скрипти, що містяться у теґу `<script>`. 

**Вони відрізняються**

1. Часом виконання: async виконує скрипт одразу після завантаження, а defer - після завантаження всього DOM;
2. Порядком виконання: async виконує скрипти безпосередньо після завантаження, порядок виконання може випадково змінюватись, тоді як defer виконує скрипти в порядку їх підключення до сторінки;
3. Взаємодією з DOM: async може вплинути на DOM під час виконання, тоді як defer не впливає на DOM, оскільки виконується лише після завантаження всього DOM.

## 3. Яка різниця між властивостями HTML-елементів innerHTML і innerText?
І `innerHTML`, і `innerText` є властивостями елементів HTML. Ми можемо змінити вміст елемента HTML за допомогою цих властивостей.

Ми можемо призначити рядок HTML властивості `innerHTML`, яка відображається як звичайний HTML. Перевірте наведений нижче приклад.

```jsx
const titleEl = document.getElementById("title");
titleEl.innerHTML = '<span style="color:orange;">techukraine.net</span>';
```
Додайте один елемент із заголовком id до свого HTML і додайте наведений вище сценарій до файлу JavaScript. Запустіть код і подивіться результат. Ви будете techukraine.net в оранжевому кольорі. І якщо ви перевірите елемент, він буде всередині тегу span. Отже, `innerHTML` візьме рядок HTML і відтворить його як звичайний HTML.
`InnerText` з іншого боку візьме звичайний рядок і відобразить його таким, яким він є. Він не відображатиме жодного HTML, як `innerHTML`. Змініть `innerHTML` на `innerText` у наведеному вище коді та перевірте результат.

```jsx
const titleEl = document.getElementById("title");
titleEl.innerText='<span style="color:orange;">techukraine.net</span>';
```

Тепер ви побачите точний рядок, який ми надали на веб-сторінці.

## 4. Опишіть процес спливання (bubbling) подій у DOM.
Коли подія відбувається в елементі DOM, вона стосується не тільки цього елемента. Подія «спливає» (подібно до бульбашки повітря у воді), переходить від елемента, що викликав подію (event.target), до його батька, потім піднімається ще вище, до батька з батька елемента, поки не досягає об'єкта Window.

Візьмемо:

```jsx
<div class="grandparent">
    <div class="parent">
        <div class="child">1</div>
    </div>
</div>
```

І такий JS код:

```jsx
function addEvent(el, event, callback, isCapture = false) {
    if (!el || !event || !callback || typeof callback !== 'function') return

    if (typeof el === 'string') {
        el = document.querySelector(el)
    }
    el.addEventListener(event, callback, isCapture)
}

addEvent(document, 'DOMContentLoaded', () => {
    const child = document.querySelector('.child')
    const parent = document.querySelector('.parent')
    const grandparent = document.querySelector('.grandparent')

    addEvent(child, 'click', function(e) {
        console.log('child')
    })

    addEvent(parent, 'click', function(e) {
        console.log('parent')
    })

    addEvent(grandparent, 'click', function(e) {
        console.log('grandparent')
    })

    addEvent('html', 'click', function(e) {
        console.log('html')
    })

    addEvent(document, 'click', function(e) {
        console.log('document')
    })

    addEvent(window, 'click', function(e) {
        console.log('window')
    })
})
```

Метод addEventListener має третій необов'язковий параметр — useCapture. Коли його значення дорівнює false (за замовчуванням), подія починається з фази спливання. Коли його значення дорівнює true, подія починається з фази занурення (для «прослуховувачів» подій, прикріплених до мети події, подія знаходиться в цільовій фазі, а не у фазах занурення або спливання. Події в цільовій фазі ініціюють всі прослуховувачі на елементі в тому порядку, в якому вони були зареєстровані незалежно від параметра useCapture. Якщо ми клацнемо по елементу child, в консоль буде виведено: child, parent, grandparent, html, document, window. Ось що таке сплив події.

## 5. Як зупинити спливання (bubbling) події?

**Спливання (bubbling)** події - це процес, коли подія, спочатку оброблена на найвнутрішньому елементі, поширюється до батьківських елементів вгору по DOM-дереву.

Щоб зупинити спливання події, можна використовувати метод `stopPropagation()` на об'єкті події. Цей метод перешкоджає подальшому поширенню події до вище розташованих елементів.

Наприклад, якщо ви маєте на сторінці кнопку у блоку та ви хочете заборонити спливання події на блок, ви можете використовувати такий код:

const block = document.querySelector('.block');
const button = document.querySelector('.button');

```jsx
button.addEventListener('click', function(event) {
    console.log('Button clicked!');
    event.stopPropagation(); // зупинка спливання події
});

block.addEventListener('click', function(event) {
    console.log('Block clicked!');  
});
```

У цьому прикладі, коли ви клікаєте на кнопку, буде викликано обробник події кнопки, який виведе повідомлення у консолі. Обробник події блоку не буде викликаний через зупинку спливання події на кнопці. Якщо ви вилучите рядок `event.stopPropagation()`;, то обробник події блоку буде викликаний також.

## 6. Як зупинити дефолтну обробку події?

Для цього необхідно викликати метод `preventDefault()` на об'єкті події (event object), що передається у функцію обробника подій.

Наприклад дію, пов'язану з кліком на посиланні, можна зупинити так:

```jsx
document.querySelector('a').addEventListener('click', function(event) {
    event.preventDefault(); // відміна стандартної дії по переходу за посиланням
    // ваші власні дії, що повинні відбутися при кліку на посиланні
});
```

## 7. Чому дорівнює this в обробнику подій (event handler)?

Значення `this` в обробнику подій залежить від того, як ви оголошуєте і прив'язуєте функцію-обробник подій.

Якщо ви використовуєте звичайну функцію, то значення `this` буде встановлено на об'єкт, що викликав обробник подій. Наприклад:

```jsx
var button = document.querySelector('button');
button.addEventListener('click', function() {
    console.log(this); // button
});
```
Якщо ж ви використовуєте стрілкову функцію, то значення `this` буде встановлено на значення this контексту, у якому оголошена функція. Наприклад:

```jsx
    var obj = {
        name: 'John',
        handleClick: function() {
            var button = document.querySelector('button');
            button.addEventListener('click', () => {
                console.log(this.name); // John
            });
        }
    };
    
    obj.handleClick();
```
Якщо ви використовуєте метод об'єкта, то значення `this` буде встановлено на цей об'єкт. Наприклад:

```jsx
var obj = {
    name: 'John',
    handleClick: function() {
        var button = document.querySelector('button');
        button.addEventListener('click', function() {
            console.log(this.name); // John
        }.bind(this));
    }
};

obj.handleClick();
```
У цьому прикладі ми використали метод `bind()` для прив'язки значення `this` контексту метода `handleClick()` до функції-обробника подій. Таким чином, коли обробник подій викликається, значення `this` буде встановлено на об'єкт obj.

## 8. Що таке LocalStorage і SessionStorage? Який максимальний розмір LocalStorage?

`localStorage` та `sessionStorage` - це механізми для збереження даних в браузері, які дозволяють зберігати ключ-значення пари. Вони використовуються для зберігання даних між сесіями браузера, тобто дані залишаються на протязі кількох відкритих вкладок/вікон.

Основна відмінність між `localStorage` та `sessionStorage` полягає в тому, що дані, збережені в `localStorage`, не мають терміну дії та зберігаються до того часу, поки їх не буде видалено вручну або до того часу, поки не буде скинутий кеш браузера. Дані, збережені в `sessionStorage`, зберігаються лише під час поточної сесії браузера, тобто після закриття вкладки або вікна вони будуть втрачені.

Максимальний розмір `localStorage` залежить від браузера, який ви використовуєте. Зазвичай цей розмір складає 5-10 МБ, проте в різних браузерах цей розмір може бути більшим або меншим. Наприклад, в Firefox максимальний розмір `localStorage` становить 10 МБ, в Google Chrome - 5 МБ, а в Internet Explorer - 10 МБ для версій 8-10 та 250 МБ для версії 11. Для `sessionStorage` максимальний розмір зазвичай також складає 5-10 МБ, але цей розмір залежить від браузера та може відрізнятися.

## 9. Як отримати висоту блоку? Його положення щодо меж документа?

Щоб отримати висоту блоку та його положення щодо меж документа, можна використовувати властивості `offsetHeight` та `offsetTop`.

`offsetHeight` - це властивість, яка повертає висоту блоку, включаючи висоту границь (border), полей (padding) та вмісту (content), але без висоти верхнього і нижнього відступів (margin).

`offsetTop` - це властивість, яка повертає відстань від верхнього краю елемента до верхнього краю батьківського елемента.

Наприклад, якщо у вас є HTML-код такого блоку:

```jsx
<div id="myBlock" style="height: 200px; border: 1px solid black; padding: 10px; margin: 20px;">
  Some content here
</div>
```

То ви можете отримати його висоту та положення щодо меж документа таким JavaScript кодом:

```jsx
const myBlock = document.getElementById('myBlock');

// отримуємо висоту блоку
const blockHeight = myBlock.offsetHeight;
console.log(blockHeight); // 222 (200 + 1 + 20 + 1)

// отримуємо положення блоку щодо меж документа
const blockTop = myBlock.offsetTop;
console.log(blockTop); // 20
```

У прикладі вище, висота блоку myBlock дорівнює 222 пікселям, а його положення щодо меж документа - 20 пікселів. Обов'язково зверніть увагу, що для правильного отримання висоти та положення, елемент має бути вміщений в розмітці HTML.

## 10. Що таке webpack?

**Webpack** - це модульний збірник для JavaScript-програм, що дозволяє створювати багатофайлові програми для веб-браузерів.

**Webpack** дозволяє об'єднувати ваші JavaScript-файли та їх залежності в один або кілька бандлів (bundle), які можуть бути завантажені браузером. Крім того, він дозволяє застосовувати різноманітні трансформації (наприклад, компілювання TypeScript в JavaScript або зведення ECMAScript модулів в один файл) та плагіни (наприклад, оптимізація коду чи додаткова обробка ресурсів, таких як CSS та зображення).

**Webpack** забезпечує також можливість розробки за допомогою інших мов програмування, таких як TypeScript, CoffeeScript чи ES6.

В цілому, Webpack дозволяє управляти та оптимізувати завантаження ресурсів браузером, що робить його популярним інструментом для розробки веб-додатків.

## 11. Чим відрізняється dev-збірка від prod?

## 12. Як заборонити браузеру віддавати кеш на HTTP-запит?

## 13. Що таке XSS (Cross-Site Scripting)?

## 14. Розкажіть про патерни Observer, Pub / Sub. Яка між ними різниця? Наведіть приклади реалізації цих патернів у відомих фреймворках / бібліотеках / браузерних API.

## 15. У чому принципова різниця між подіями mouseleave і mouseout?
## 16. У якому порядку обробляються призначені для користувача події в DOM (click, mouseover тощо)? FIFO чи LIFO?
## 17. Що таке Event bubbling та Event capturing?
## 18. Порівняйте методи об’єкта event stopPropagation та stopImmediateProparation.
## 19. Які є підходи оптимізації продуктивності вебсторінки?
## 20. Як реалізований механізм same-origin policy в браузері? На які браузерні API він поширюється?
## 21. Назвіть способи зберігання даних у браузері. Порівняйте їх.
## 22. Web worker’и. Опишіть особливості передачі даних між worker’ами та основним потоком, між розділеними worker’ами.
## 23. Що таке Transferable-об’єкти?
## 24. Розкажіть про способи оптимізації виконання ресурсомістких операцій JS для поліпшення продуктивності рендерингу контенту на сторінці.
## 25. Чому ResizeObserver викликає події зміни розміру до відтворення елемента, а не після?
## 26. Розкажіть, як ви розумієте Web Accessibility?
## 27. Опишіть алгоритм створення функціоналу, що забезпечує читання вмісту .txt-файлу при перетягуванні його з файлової системи у вікно браузера.
## 28. Що таке Virtual DOM?
## 29.Розкажіть про функціональне програмування.
## 30.Що таке TDD (Test Driven Development) / BDD (Behavior Driven Development)?
## 31.Розкажіть детально про роботу HTTPS.
## 32.Який стек технологій можна обрати для реалізації клону якогось відомого проєкту і чому?
## 33.Є проєкт на старих технологіях, необхідно в нього вносити зміни. Як це зробити найкраще?
## 34.Якщо у кандидата є досвід роботи з кількома фреймворками: який будете використовувати для наступного проєкту? Які фактори будуть впливати на вибір?
## 35.Що таке V8 Engine?
## 36.Як браузер визначає, чи ми можемо спілкуватися між вкладками?
## 37.Що таке Content Security Policy?
## 38.Як уникнути завантаження кешованих файлів скриптів і стилів?
## 39.Що таке requestAnimationFrame?
## 40.Розкажіть про мікросервісну архітектуру Front-end App.
## 41.Що таке Shadow DOM?
## 42.Порівняйте nextElementSibling та nextSibling.
## 43.Які знаєте метрики вебсайту?
